////
; Copyright (c) uib gmbh (www.uib.de)
; This documentation is owned by uib
; and published under the german creative commons by-sa license
; see:
; http://creativecommons.org/licenses/by-sa/3.0/de/
; http://creativecommons.org/licenses/by-sa/3.0/de/legalcode
; english:
; http://creativecommons.org/licenses/by-sa/3.0/
; http://creativecommons.org/licenses/by-sa/3.0/legalcode
; 
; credits: http://www.opsi.org/credits/
////


:Author:    uib gmbh
:Email:     info@uib.de
:Date:      05.05.2011
:Revision:  4.0.1
:toclevels: 6

include::../common/opsi_terms.asciidoc[]


[[opsi-manual-backends]]
== Datenhaltung von opsi (Backends)

[[opsi-manual-backends-file]]
=== file-Backend

Bei Verwendung des '{file-Backend}s' liegen die Konfigurationsinformationen in Ini-Dateien auf dem Server.

Wesentliche Merkmale des Backends 'file' :

* Aktuelles Defaultbackend von opsi
* Die Dateien dieses Backends liegen unter `/var/lib/opsi`.

Inhalt und Aufbau dieser Dateien ist im Kapitel <<opsi-manual-important-files-filebackend>> näher erläutert.

[[opsi-manual-backends-ldap]]
=== ldap-Backend

Die opsi 4 Backends sind in `/etc/opsi/backends/*.conf` konfiguriert. Bei Verwendung des '{ldap-Backend}s' müssen hier die Daten eingetragen werden, die einen Zugriff auf den LDAP ermöglichen.

Weiterhin muss konfiguriert werden für welche Methoden auf das LDAP Backend zurückgegriffen wird. Lesen Sie dazu das Kapitel 'Backendkonfiguration' des Getting Started Handbuchs.

Unterhalb der LDAP-Basis liegt eine 'organizationalRole cn=opsi' (z.B. cn=opsi, dc=uib, dc=local). Unterhalb von opsi finden Sie die komplette LDAP-Datenhaltung. Diese läßt sich mit einem grafischen Frontend wie dem 'Jxplorer' (z.B. aus den 'opsi-adminutils') leicht erkunden.

.opsi ldap backend im Jxplorer
image::../images/opsi-ldap-backend-in-jxplorer.png["opsi ldap backend im Jxplorer",width=400]

[[opsi-manual-backends-mysql]]
=== mysql-Backend

[[opsi-manual-backends-mysql-inventory]]
==== mysql-Backend für Inventarisierungsdaten (Übersicht und Datenstruktur)

Die Daten der Hardware- und Softwareinventarisierung werden per default über das opsi '{file-Backend}' in Textdateien abgelegt. Diese Form der Ablage ist für freie Abfragen und Reports weniger geeignet. Hierfür bietet sich die Ablage der Daten in einer SQL-Datenbank an. 

Wesentliche Merkmale des Backends 'mysql' :

* Optional (nicht das default Backend)
* Für Inventarisierungsdaten kostenfrei, für die Nutzung für sonstige Daten benötigen Sie eine kostenpflichtige Freischaltung.

* Fein granulierte Datenstruktur zur Datenhaltung und zusätzlich vereinfachtes Datenmodell für Abfragen.
* Eine Historyfunktion, welche Änderungen an den Inventarisierungsdaten protokolliert.

Bedingt durch die sehr unterschiedliche Natur der zu inventarisierenden Hardwarekomponenten ist die Datenstruktur in etwa wie folgt aufgebaut:

* Eine Tabelle 'host' beschreibt alle bekannten Clients und stellt eine eindeutige 'host_id' bereit. 
* Für jeden Device-Typ gibt es zwei Tabellen: 
** 'HARDWARE_DEVICE_ ....' beschreibt das Device z.B. Netzwerkkartentyp mit PCI-Kennung
** 'HARDWARE_CONFIG...' beschreibt Konfiguration der konkreten Netzwerkkarte z.B. MAC-Adresse. Die beiden Tabellen sind über das Feld 'hardware_id' miteinander verbunden.

Ähnlich sieht es für die Softwareinventarisierung aus. Auch hier beschreibt die Tabelle 'Software' die insgesamt gefundene Software während die Tabelle 'Software_Config' die Client spezifische Konfiguration speichert.

Daraus ergibt sich folgende Liste von Tabellen:
[source,ini]
----
HARDWARE_CONFIG_1394_CONTROLLER
HARDWARE_CONFIG_AUDIO_CONTROLLER
HARDWARE_CONFIG_BASE_BOARD
HARDWARE_CONFIG_BIOS
HARDWARE_CONFIG_CACHE_MEMORY
HARDWARE_CONFIG_COMPUTER_SYSTEM
HARDWARE_CONFIG_DISK_PARTITION
HARDWARE_CONFIG_FLOPPY_CONTROLLER
HARDWARE_CONFIG_FLOPPY_DRIVE
HARDWARE_CONFIG_HARDDISK_DRIVE
HARDWARE_CONFIG_IDE_CONTROLLER
HARDWARE_CONFIG_KEYBOARD
HARDWARE_CONFIG_MEMORY_BANK
HARDWARE_CONFIG_MEMORY_MODULE
HARDWARE_CONFIG_MONITOR
HARDWARE_CONFIG_NETWORK_CONTROLLER
HARDWARE_CONFIG_OPTICAL_DRIVE
HARDWARE_CONFIG_PCI_DEVICE
HARDWARE_CONFIG_PCMCIA_CONTROLLER
HARDWARE_CONFIG_POINTING_DEVICE
HARDWARE_CONFIG_PORT_CONNECTOR
HARDWARE_CONFIG_PRINTER
HARDWARE_CONFIG_PROCESSOR
HARDWARE_CONFIG_SCSI_CONTROLLER
HARDWARE_CONFIG_SYSTEM_SLOT
HARDWARE_CONFIG_TAPE_DRIVE
HARDWARE_CONFIG_USB_CONTROLLER
HARDWARE_CONFIG_VIDEO_CONTROLLER
HARDWARE_DEVICE_1394_CONTROLLER
HARDWARE_DEVICE_AUDIO_CONTROLLER
HARDWARE_DEVICE_BASE_BOARD
HARDWARE_DEVICE_BIOS
HARDWARE_DEVICE_CACHE_MEMORY
HARDWARE_DEVICE_COMPUTER_SYSTEM
HARDWARE_DEVICE_DISK_PARTITION
HARDWARE_DEVICE_FLOPPY_CONTROLLER
HARDWARE_DEVICE_FLOPPY_DRIVE
HARDWARE_DEVICE_HARDDISK_DRIVE
HARDWARE_DEVICE_IDE_CONTROLLER
HARDWARE_DEVICE_KEYBOARD
HARDWARE_DEVICE_MEMORY_BANK
HARDWARE_DEVICE_MEMORY_MODULE
HARDWARE_DEVICE_MONITOR
HARDWARE_DEVICE_NETWORK_CONTROLLER
HARDWARE_DEVICE_OPTICAL_DRIVE
HARDWARE_DEVICE_PCI_DEVICE
HARDWARE_DEVICE_PCMCIA_CONTROLLER
HARDWARE_DEVICE_POINTING_DEVICE
HARDWARE_DEVICE_PORT_CONNECTOR
HARDWARE_DEVICE_PRINTER
HARDWARE_DEVICE_PROCESSOR
HARDWARE_DEVICE_SCSI_CONTROLLER
HARDWARE_DEVICE_SYSTEM_SLOT
HARDWARE_DEVICE_TAPE_DRIVE
HARDWARE_DEVICE_USB_CONTROLLER
HARDWARE_DEVICE_VIDEO_CONTROLLER
HOST
SOFTWARE
SOFTWARE_CONFIG
----

Die Zuordnung der Spaltennamen zu einzelnen Deviceklassen ergibt sich aus folgender Liste (`/etc/opsi/hwaudit/locales/de_DE`):

[source,ini]
----
DEVICE_ID.deviceType = Gerätetyp
DEVICE_ID.vendorId = Hersteller-ID
DEVICE_ID.deviceId = Geräte-ID
DEVICE_ID.subsystemVendorId = Subsystem-Hersteller-ID
DEVICE_ID.subsystemDeviceId = Subsystem-Geräte-ID
DEVICE_ID.revision= Revision
BASIC_INFO.name = Name
BASIC_INFO.description = Beschreibung
HARDWARE_DEVICE.vendor = Hersteller
HARDWARE_DEVICE.model = Modell
HARDWARE_DEVICE.serialNumber = Seriennummmer
COMPUTER_SYSTEM = Computer
COMPUTER_SYSTEM.systemType = Typ
COMPUTER_SYSTEM.totalPhysicalMemory = Arbeitsspeicher
BASE_BOARD = Hauptplatine
BASE_BOARD.product = Produkt
BIOS = BIOS
BIOS.version = Version
SYSTEM_SLOT = System-Steckplatz
SYSTEM_SLOT.currentUsage = Verwendung
SYSTEM_SLOT.status = Status
SYSTEM_SLOT.maxDataWidth = Max. Busbreite
PORT_CONNECTOR = Port
PORT_CONNECTOR.connectorType = Attribute
PORT_CONNECTOR.internalDesignator = Interne Bezeichnung
PORT_CONNECTOR.internalConnectorType = Interner Typ
PORT_CONNECTOR.externalDesignator = Externe Bezeichnung
PORT_CONNECTOR.externalConnectorType = Externer Typ
PROCESSOR = Prozessor
PROCESSOR.architecture = Architektur
PROCESSOR.family = Familie
PROCESSOR.currentClockSpeed = Momentane Taktung
PROCESSOR.maxClockSpeed = Maximale Taktung
PROCESSOR.extClock = Externe Taktung
PROCESSOR.processorId = Prozessor-ID
PROCESSOR.addressWidth = Adress-Bits
PROCESSOR.socketDesignation = Zugehöriger Sockel
PROCESSOR.voltage = Spannung
MEMORY_BANK = Speicher-Bank
MEMORY_BANK.location = Position
MEMORY_BANK.maxCapacity = Maximale Kapazität
MEMORY_BANK.slots = Steckplätze
MEMORY_MODULE = Speicher-Modul
MEMORY_MODULE.deviceLocator = Zugehöriger Sockel
MEMORY_MODULE.capacity = Kapazität
MEMORY_MODULE.formFactor = Bauart
MEMORY_MODULE.speed = Taktung
MEMORY_MODULE.memoryType = Speichertyp
MEMORY_MODULE.dataWidth = Datenbreite
MEMORY_MODULE.tag = Bezeichnung
CACHE_MEMORY = Zwischenspeicher
CACHE_MEMORY.installedSize = Installierte Größe
CACHE_MEMORY.maxSize = Maximale Größe
CACHE_MEMORY.location = Position
CACHE_MEMORY.level = Level
PCI_DEVICE = PCI-Gerät
PCI_DEVICE.busId = Bus-ID
NETWORK_CONTROLLER = Netzwerkkarte
NETWORK_CONTROLLER.adapterType = Adapter-Typ
NETWORK_CONTROLLER.maxSpeed = Maximale Geschwindigkeit
NETWORK_CONTROLLER.macAddress = MAC-Adresse
NETWORK_CONTROLLER.netConnectionStatus = Verbindungsstatus
NETWORK_CONTROLLER.autoSense = auto-sense
AUDIO_CONTROLLER = Audiokarte
IDE_CONTROLLER = IDE-Controller
SCSI_CONTROLLER = SCSI-Controller
FLOPPY_CONTROLLER = Floppy-Controller
USB_CONTROLLER = USB-Controller
1394_CONTROLLER = 1394-Controller
PCMCIA_CONTROLLER = PCMCIA-Controller
VIDEO_CONTROLLER = Grafikkarte
VIDEO_CONTROLLER.videoProcessor = Video-Prozessor
VIDEO_CONTROLLER.adapterRAM = Video-Speicher
DRIVE.size = Größe
FLOPPY_DRIVE = Floppylaufwerk
TAPE_DRIVE = Bandlaufwerk
HARDDISK_DRIVE = Festplatte
HARDDISK_DRIVE.cylinders = Cylinder
HARDDISK_DRIVE.heads = Heads
HARDDISK_DRIVE.sectors = Sektoren
HARDDISK_DRIVE.partitions = Partitionen
DISK_PARTITION = Partition
DISK_PARTITION.size = Größe
DISK_PARTITION.startingOffset = Start-Offset
DISK_PARTITION.index = Index
DISK_PARTITION.filesystem = Dateisystem
DISK_PARTITION.freeSpace = Freier Speicher
DISK_PARTITION.driveLetter = Laufwerksbuchstabe
OPTICAL_DRIVE = Optisches Laufwerk
OPTICAL_DRIVE.driveLetter = Laufwerksbuchstabe
MONITOR = Monitor
MONITOR.screenHeight = Vertikale Auflösung
MONITOR.screenWidth = Horizontale Auflösung
KEYBOARD = Tastatur
KEYBOARD.numberOfFunctionKeys = Anzahl Funktionstasten
POINTING_DEVICE = Zeigegerät
POINTING_DEVICE.numberOfButtons = Anzahl der Tasten
PRINTER = Drucker
PRINTER.horizontalResolution = Vertikale Auflösung
PRINTER.verticalResolution = Horizontale Auflösung
PRINTER.capabilities = Fähigkeiten
PRINTER.paperSizesSupported = Unterstützte Papierformate
PRINTER.driverName = Name des Treibers
PRINTER.port = Anschluss
----

Beispiele für Abfragen:
Liste aller Festplatten:
[source,prompt]
----
SELECT * FROM HARDWARE_DEVICE_HARDDISK_DRIVE D
LEFT OUTER JOIN HARDWARE_CONFIG_HARDDISK_DRIVE H ON D.hardware_id=H.hardware_id ;
----

Die Softwareinventarisierung verwendet als Hauptschlüssel die folgenden Felder:

* Name +
Dieser ist der 'windowsDisplayName' bzw. wenn dieser nicht vorhanden ist die 'windowsSoftwareId'. Beide werden aus der Registry ermittelt: +
'HKLM\SOFTWARE\Microsoft\Windows\CurrentVersion\Uninstall' bzw. +
'HKLM\SOFTWARE\Microsoft\Windows\CurrentVersion\Uninstall\<id> DisplayName'

* Version +
'HKLM\SOFTWARE\Microsoft\Windows\CurrentVersion\Uninstall\<id> DisplayVersion'

* SubVersion
* Language
* Architecture (32 Bit / 64 Bit)

In der Tabelle 'Software_config' sind diese Felder zum Feld 'config_id' zusammengefasst.

.Datenbankschema: Softwareinventarisierung
image::../images/mysql-schema-inventory-software.png["Datenbankschema: Softwareinventarisierung",width=400]


[[opsi-manual-backends-mysql-configdata-overview]]
==== mysql-Backend für Konfigurationsdaten (Übersicht)

Das '{mysql-Backend}' für Konfigurationsdaten steht seit opsi 4.0 zur Verfügung (zunächst als kostenpflichtiges Kofinanzierungsprojekt).

Das '{mysql-Backend}' hat den Vorteil der höheren Performanz insbesondere bei großen Installationen.

Hier eine Übersicht über die Datenstruktur:

.Datenbankschema: Konfigurationsdaten
image::../images/mysql-schema-configdata.png["Datenbankschema: Konfigurationsdaten",width=400]

[[opsi-manual-backends-mysql-initializing]]
==== Initialisierung des mysql-Backends

Wenn der mysql-server noch nicht installiert ist, muss dies zunächst erfolgen mit:
[source,prompt]
----
apt-get install mysql-server
----
Danach muss für der root Zugang von mysql ein Passwort gesetzt werden:
[source,prompt]
----
mysqladmin --user=root password linux123
----

Mit dem Befehl `opsi-setup --configure-mysql` kann nun die Datenbank aufgebaut werden.

Eine Beispiel-Sitzung:

.opsi-setup --configure-mysql: Eingabemaske
image::../images/mysql-config-input-mask.png["opsi-setup --configure-mysql: Eingabemaske",width=400]

.opsi-setup --configure-mysql: Ausgabe
image::../images/mysql-config-output.png["opsi-setup --configure-mysql: Ausgabe",width=400]


Bei den Abfragen können außer beim Passwort alle Vorgaben mit Enter bestätigt werden.

Als nächstes muss in der `/etc/opsi/backendManager/dispatch.conf` eingetragen werden, das das '{mysql-Backend}' auch verwendet werden soll. Eine genaue Beschreibung zu dieser Konfiguration finden Sie im Kapitel 'Backend-Konfiguration' des 'getting-started Handbuchs'. Die Datei selbst enthält eine Reihe von Beispielen typischer Konfigurationen.
Eine Konfiguration für '{mysql-Backend}' (ohne internen DHCPD) sieht so aus:
[source,opsifiles]
----
backend_.*         : mysql, opsipxeconfd
host_.*            : mysql, opsipxeconfd
productOnClient_.* : mysql, opsipxeconfd
configState_.*     : mysql, opsipxeconfd
.*                 : mysql
----

Nach Abschluss dieser Konfigurationsarbeit müssen Sie den folgenden Befehlen die Benutzung der jetzt konfigurierten und konvertierten Backend aktivieren:
[source,prompt]
----
opsi-setup --init-current-config
opsi-setup --set-rights
/etc/init.d/opsiconfd restart
/etc/init.d/opsipxeconfd restart
----

[[opsi-manual-backends-mysql-access-config]]
==== Konfigurieren der MySQL-Datenbank zum Zugriff von außen
### has to be written ###

[[opsi-manual-backends-hostcontrol]]
=== HostControl-Backend

Das HostControl-Backend speichert keine Konfigurationsdaten, sondern dient der Steuerung von opsi-Clients.
Hierzu gehören beispielsweise das Starten von Clients per Wake-On-LAN oder das Senden von Steuerungsbefehlen an den opsi-client-agent.

Die Konfiguration des HostControl-Backends wird in der Konfigurationsdatei `/etc/opsi/backends/hostcontrol.conf` vorgenommen. Konfigurations-Optionen sind hierbei:

* +opsiclientdPort+: +
Netzwerk-Port für die Verbindungsaufnahme zu einem {opsi-client-agent}.

* +hostRpcTimeout+: +
Timeout (in Sekunden) bei der Verbindungsaufnahme zu einem {opsi-client-agent}.

* +resolveHostAddress+: +
Steht diese Option auf +True+, wird bei einem Verbindungsaufbau vom {opsi-server} zu einem {opsi-client} die IP-Adresse des Clients bevorzugt über die Namensauflösung ermittelt.
Um die im Backend von opsi hinterlegte IP-Adresse zu bevorzugen ist die Option auf +False+ zu setzen.

* +maxConnections+: +
Maximale Anzahl simultaner Verbindungen zu {opsi-client-agent}s.

* +broadcastAddresses+: +
Liste von Broadcast-Adressen für das Versenden von Wake-On-LAN-Broadcasts.


[[opsi-manual-backends-convert]]
=== Konvertierung zwischen Backends
Der Befehl `opsi-convert` dient zum Konvertieren der opsi-Konfigurationsdaten zwischen verschiedenen Backends. Das Ziel oder Quelle kann auf verschieden Arten bestimmt werden:

* Backendnamen: +
Durch Angabe des Namen wird ein entsprechendes Backend auf dem aktuellen Server angegeben. So konvertiert  `opsi-convert file mysql` auf dem aktuellen Server vom '{file-Backend}' zum '{mysql-Backend}'.

* Service-Adresse +
Durch Angaben von Serviceadressen kann ein Server z.B. auch Remote angesprochen werden. Die Service Adresse hat die Form +
https://<username>@<ipadresse>:4447/rpc 
Nach den Passwörtern wird gefragt. +
Beispiel:
[source,prompt]
----
opsi-convert -s -l /tmp/log https://uib@192.168.2.162:4447/rpc \   https://opsi@192.168.2.42:4447/rpc
----

* Konfigurationsverzeichnis +
Durch Angabe von Konfigurationsverzeichnissen für die entsprechende Backendmanagerkonfiguration können Quelle bzw. Ziel sehr detailliert beschrieben werden.

[source,prompt]
----
opsi-convert --help

Usage: opsi-convert [options] <from> <to>
Convert an opsi database into an other.
Options:
    -h        show this help text
    -V        show version information
    -q        do not show progress
    -v        increase verbosity (can be used multiple times)
    -c        clean destination database before writing
    -s        use destination host as new server
    -l <file> log to this file

<from> and <to> can be:
     - the name of a backend as defined in /etc/opsi/backends (file, ldap, ...)
     - the url of a opsi configuration service
       http(s)://<user>@<host>:<port>/rpc
----

[[opsi-manual-backends-bootfiles]]
=== Bootdateien

Unter `/tftpboot/linux` finden sich die Bootdateien, die im Zusammenspiel mit den PXE-Bootproms benötigt werden.

[[opsi-manual-backends-securing-shares]]
=== Absicherung der Shares über verschlüsselte Passwörter

Der '{opsi-client-agent}' greift auf die vom '{opsi-server}' zur Verfügung gestellten Shares zu, um die dort liegende Software zu installieren zu können.

Hierzu wird der System-User 'pcpatch' verwendet. Die Absicherung dieser Shares und damit der Authentifizierungs­daten des Users pcpatch sind wichtig für die:
* allgemeine Systemsicherheit und Datenintegrität
* Absicherung der potenziell lizenzpflichtigen Softwarepakete gegen missbräuchliche Nutzung

Um dem '{opsi-client-agent}' ein Zugriff auf die Authentifizierungsdaten zu ermöglichen, wird für jeden Client bei seiner Erzeugung in opsi ein spezifischer Schlüssel ('{opsi-host-key}') erzeugt. Dieser Schlüssel wird zum einen (beim '{file-Backend}') in der Datei `/etc/opsi/pckeys` abgelegt und zum anderen dem PC bei der Reinstallation übergeben. Der übergebene Schlüssel wird im Rahmen der der Installation des '{opsi-client-agent}' in der Datei `c:\program files\opsi.org\opsi-client-agent\opsiclientd\opsiclientd.conf` so abgelegt, dass nur Administratoren Zugriff darauf haben. Ebenso hat auf dem '{opsi-server}' nur root und Mitglieder der Gruppe 'opsiadmin' Zugriff auf die Datei `/etc/opsi/pckeys`. Auf diese Weise verfügt jeder PC über einen Schlüssel, der nur dem PC und dem '{opsi-server}' bekannt ist und der gegenüber dem Zugriff durch normale Anwender geschützt ist. Mit diesem Schlüssel wird das aktuelle Passwort des system users 'pcpatch' auf dem '{opsi-server}' verschlüsselt und im Backend abgelegt. Dieses verschlüsselte Passwort wird vom Client bei jeder Aktivierung des '{opsi-client-agent}' neu gelesen, so dass eine Änderung des 'pcpatch' Passwortes jederzeit möglich ist und der Client auf verschlüsseltem Wege das veränderte Passwort erfährt.


