////
; Copyright (c) uib gmbh (www.uib.de)
; Cette documentation appartient à uib
; et publié sous licence Creative Commons by-sa allemande
; voir:
; https://creativecommons.org/licenses/by-sa/3.0/de/
; https://creativecommons.org/licenses/by-sa/3.0/de/legalcode
; anglais:
; https://creativecommons.org/licenses/by-sa/3.0/
; https://creativecommons.org/licenses/by-sa/3.0/legalcode
;
; crédits: http://www.opsi.org/credits/
////

:Author:    OpenSides sprl
:Email:     opsi@opensides.be
:Date:      12.10.2012
:Revision:  4.0.1
:toclevels: 6


include::../common/opsi_terms.asciidoc[]

[[opsi-manual-clientagent]]
== opsi-client-agent

[[opsi-manual-clientagent-overview]]
=== Présentation

Pour rendre la distribution de logiciels gérable pour l'administrateur système, un ordinateur client doit remarquer que les paquets de nouveaux logiciels ou mises à jour sont disponibles et les installer sans l'interaction de l'utilisateur. Il est important de rendre l'interaction de l'utilisateur complètement obsolètes, comme l'installation peut fonctionner sans surveillance, et que l'utilisateur ne puisse pas arrêter l'installation.

Ces exigences sont mises en œuvre dans opsi par le '{opsi-client-agent}':

Du côté du client le service 'opsiclientd' examine habituellement au moment du démarrage, avant que l'utilisateur se connecte, si une mise à jour doit être installé pour ce client.

S'il y a des paquets logiciels à installer sur le client, le programme de traitement de script 'opsi-winst' est mis en marche pour faire le travail d'installation. Le serveur fournit tous les scripts et fichiers d'installation de logiciels sur un partage de fichiers. À ce moment l'utilisateur n'a aucune chance d'interférer avec le processus d'installation.

En option, le module supplémentaire 'loginblocker' peut être installé pour empêcher une connexion de l'utilisateur avant que la fin de la procédure d'installation est atteinte.

Avant que tout logiciel puisse être installé avec le programme 'opsi-winst', il doit être préparé comme un '{opsi-product-package}'. Pour plus de détails voir le chapitre 'L'intégration des nouveaux paquets logiciels dans le déploiement de logiciels opsi' depuis le manuel 'getting started'.

[[opsi-manual-clientagent-directories]]
=== Répertoires de the opsi-client-agent

'{opsi-client-agent}' est installé dans `%ProgramFiles%\opsi.org\opsi-client-agent`.

Ce répertoire contient tous les programmes de '{opsi-client-agent}' comme par exemple '{opsiclientd}', '{opsiclientd-notifier}', '{opsi-winst}' et des bibliothèques nécessaires. Vous trouverez ici aussi les fichiers de configuration et les modèles graphiques (skins) des programmes mentionnés.

Le répertoire `%ProgramFiles%\opsi.org\opsi-client-agent` est protégé contre toute manipulation par les utilisateurs sans privilèges d'administrateur. +
Le répertoire `%ProgramFiles%\opsi.org\opsi-client-agent\opsiclientd` contient le fichier de configuration de '{opsiclientd}' et vous avez besoin des privilèges d'administrateur pour le lire.

Il y a aussi le répertoire `c:\opsi.org`.

Ce répertoire est utilisé (pour le moment) pour mettre en cache les fichiers d'installation et les données (voir l'extension WAN). A l'avenir, il aura encore plus de fonctions contenant des fichiers journaux. +
Vous devez disposer de privilèges d'administrateur pour lire le répertoire `c:\opsi.org`.

Vous trouverez les fichiers de log de '{opsi-client-agent}' dans `c:\tmp`.

[[opsi-manual-clientagent-service]]
=== Le service: opsiclientd

'{opsiclientd}' est le cœur de '{opsi-client-agent}'. '{opsiclientd}' débute au moment du démarrage et s'exécute avec des privilèges d'administrateur.

Les caractéristiques importantes sont:

* Le contrôle basé sur l'événement: +
L'activité de l'agent client opsi (opsiclientd) peut être déclenchée par différents événements dans le système client. D'après cet état de fait, le début de l'installation peut être déclenchée par le système de démarrage d'événements ou peut être configuré pour être déclenché par d'autres systèmes d'événements.

* Contrôle via le service web: +
Cette interface est utilisée pour 'pousser' les installations et aussi à des fins de maintenance.

* La configuration à distance: +
Les données de configuration pour les clients peuvent être modifiées (globalement ou spécifique au client) sur le serveur en éditant le 'Host parameters'.

'{opsi-client-agent}' est constitué de plusieurs composants :

* '{opsiclientd}': le principal service
* '{opsiclientd-notifier}': fenêtre d'information et de communication
* '{opsi-login-blocker}': bloque la connexion de l'utilisateur jusqu'à ce que l'installation est terminée

[[opsi-manual-clientagent-installation]]
==== Installation

En cas d'installation automatique du système d'exploitation avec opsi (pas basé sur une image), '{opsi-client-agent}' sera installé automatiquement.

Vous pouvez définir la demande d'action 'uninstall' pour désinstaller '{opsi-client-agent}'.

Pour une installation ultérieure sur un système Windows existant ou à des fins de réparation voir le manuel 'getting started'.

[[opsi-manual-clientagent-opsiclientd]]
==== opsiclientd

Composante essentielle de '{opsi-client-agent}' est le service '{opsiclientd}'. Ce service s'exécute au moment du démarrage.

'{opsiclientd}' a les tâches suivantes:

* Tandis que le système démarre et '{opsiclientd}' est en attente de l'interface graphique, 'block_login_notifier' est lancé et affiche un cadenas dans le coin supérieur droit de l'écran.

* Mise en action si l'événement de configuration a lieu. Dans le cas d'une action '{opsiclientd}' contacte le serveur opsi via le service web (JSON-RPC) et demande les données de configuration et les actions requises. +
L'événement par défaut est 'gui_startup' qui se déclenche au moment du démarrage avant le login utilisateur.

* Crée un canal de communication nommé qui est utilisé par '{opsi-login-blocker}' pour demander via JSON-RPC à '{opsiclientd}' quand débloquer la connexion.

* Démarrer '{opsiclientd-notifier}' comme un fil d'information et d'interaction avec l'utilisateur.

* Si nécessaire, il se connecte à '{opsi-depot}' pour mettre à jour l'installation locale de '{opsi-winst}' et puis il commence à traiter les '{action-requests}' (Installations de paquets logiciels).

[[opsi-manual-clientagent-opsiclientd-notifier]]
==== opsiclientd notifier

'{opsiclientd-notifier}' met en oeuvre l'interaction avec l'utilisateur. Il affiche des messages d'état et peut donner la possibilité d'interagir avec le processus.

Il existe différentes situations où '{opsiclientd-notifier}' deviendra actif de différentes façons:

blocking notifier::
Indique que '{opsi-login-blocker}' bloque la connexion.

.opsiclientd notification blocklogin
image::opsiclientd-blocklogin-notifier.png["opsiclientd notification blocklogin",width=80]

event notifier::
Affiche des informations sur l'événement en cours.

.opsiclientd notification événement
image::opsiclientd-event-notifier.png["opsiclientd notification événement",width=150]

action notifier::
Montre l'état ​​de traitement de l'événement.

.opsiclientd notification de l'action
image::opsiclientd-action-notifier.png["opsiclientd notification de l'action",width=150]

shutdown notifier::
Donne des informations sur le redémarrage / arrêt demandé.
(si +shutdown_warning_time+ > 0)

.opsiclientd notification d'arrêt
image::opsiclientd-shutdown-notifier.png["opsiclientd notification d'arrêt",width=150]

CAUTION: Les noms et les fonctions de notification ont changé de opsi 4.0 à opsi 4.0.1. +
Le notificateur d'événement de opsi 4.0 n'existe plus. +
Le notificateur d'événement de opsi 4.0.1 est égal au notifiant d'action de opsi 4.0. +
Le notificateur d'action de opsi 4.0.1 a presque la même fonctionnalité du notificateur d'événement de opsi 4.0, mais il ne sera activé que s'il existe une '{action-request}'.


[[opsi-manual-clientagent-loginblocker]]
==== {opsi-login-blocker}
'{opsi-login-blocker}' pour NT5 (Win2K/WinXP) est mis en oeuvre en tant que 'GINA'  ('opsigina.dll').
'GINA' attend jusqu'à ce que les rapports opsiclientd, que tous '{product-actions}' sont terminés ou, si opsiclientd n'est pas joignable, jusqu'à ce que le délai d'attente de connexion à opsiclientd est atteint (normalement 120 secondes). Puis le contrôle intégral est transmis à l'autre 'GINA', qui est normalement `msgina.dll`.

'{opsi-login-blocker}' pour NT6 (Vista/Win7) est mis en oeuvre en tant que 'filtre fournisseur d'informations d'identification' ('OpsiLoginBlocker.dll').
Ce "filtre fournisseur d'informations d'identification" bloque tous les 'credential providers' jusqu'à ce que les rapports opsiclientd, que tous '{product-actions}' sont terminés ou, si opsiclientd n'est pas joignable, jusqu'à ce que le délai d'attente de connexion à opsiclientd est atteint (normalement 120 secondes).

[[opsi-manual-clientagent-event-flow]]
==== Déroulement du processus

Le fonctionnement de opsiclientd peut être configuré dans de nombreux détails. Pour comprendre ces options de configuration, il est nécessaire de comprendre la séquence de traitement. Voici un aperçu du flux de travail d'un 'standard event' comme 'event_gui_startup'.

.flux de travail simplifié d'un 'standard event'
image::eventflowchsrt.png["flux de travail simplifié d'un 'standard event'",height=400]

Les paramètres les plus importants ont les relations suivantes:

TIP: S'il y a une erreur lors de la connexion à '{opsi-configserver}', les logs de ces problèmes ne peuvent pas être envoyés au serveur. Mais vous pouvez trouver les logs dans le fichier journal locale `opsiclientd.log` dans le répertoire des journaux (`c:\tmp`) sur le client.

. Si un événement se déclenche, +event_notifier_command+ est lancé. +
Maintenant, opsiclientd essaie d'atteindre '{opsi-configserver}' en utilisant l'adresse url. +
Si, après +user_cancelable_after+ secondes il n'existe toujours pas de connexion établie, alors '{opsiclientd-notifier}' activera un bouton 'abandonner'. Si aucune connexion n'a pu être établie dans +connection_timeout+ secondes, le processus de connexion 'opsiclientd' sera interrompue et l'événement se terminera par un message d'erreur. Pour éviter l'interruption de la part de l'utilisateur, réglez +user_cancelable_after+ = +connection_timeout+ .

. Après une connexion réussie au '{opsi-configserver}', 'opsiclientd' vérifie s'il y a une 'action requests' pour ce client. Si il y a des 'action requests' et +action_warning_time+ > 0, +action_notifier_command+ sera exécuté. +
C'est normalement '{opsiclientd-notifier}', qui affiche maintenant la liste des 'action requests' pour ce client pendant +action_warning_time+ secondes. +
Si +action_warning_time+ = 0 (par défaut) alors +action_notifier_command+ ne sera pas exécuté. +
Vous pouvez permettre à l'utilisateur de suspendre le processus en ce moment en mettant +action_user_cancelable+ >= 0. L'utilisateur peut suspendre les actions jusqu'à +action_user_cancelable+ fois. Apres +action_user_cancelable+ suspensions en séquence ou si +action_user_cancelable+ = 0 l'utilisateur n'obtient pas la faculté de suspendre les actions. +
Dans tous les cas, il y aura un bouton qui permettra à l'utilisateur de démarrer les installations immédiatement, sans attendre le décompte des +action_warning_time+ secondes. Les messages affichés par '{opsiclientd-notifier}' peut être configuré avec les options +action_message+ ou +action_message[lang]+ . Ces messages peuvent contenir des espaces réservés +%action_user_cancelable%+ (nombre total de permission de suspensions) et +%action_cancel_counter%+ (nombre de suspensions déjà utilisés par l'utilisateur). +
Si les actions ne sont pas suspendues par l'utilisateur, +action_cancel_counter+ se réinitialise et '{opsi-winst}' est exécutée pour le traitement de 'action requests'.

. Si '{opsi-winst}' se termine par une demande de redémarrage ou d'arrêt, +shutdown_notifier_command+ sera exécuté si +shutdown_warning_time+ > 0. +
+shutdown_notifier_command+ montre pendant +shutdown_warning_time+ secondes un message indiquant que le client va être redémarré. Si +shutdown_user_cancelable+ > 0 l'utilisateur peut suspendre le redémarrage jusqu'à +shutdown_user_cancelable+ fois en séquence. Si l'utilisateur suspend le redémarrage, +shutdown_notifier_command+ sera redémarré après +shutdown_warning_repetition_time+. +shutdown_notifier_command+ affiche un message qui peut être configuré par +shutdown_warning_message+ ou +shutdown_warning_message[lang]+. Ce message peut contenir les espaces réservés  +%shutdown_user_cancelable%+ (nombre maximum de permission de suspensions) et +%shutdown_cancel_counter%+ (nombre de suspensions déjà fait par l'utilisateur). +
Si le client est redémarré (par l'utilisateur ou 'opsi-client-agent') +%shutdown_cancel_counter%+ sera réinitialisé.

TIP: La séquence de traitement des événements et actions de l'utilisateur sont visualisées sous forme de graphique chronologique à la page d'information de '{opsiclientd}'.

(<<opsi-manual-clientagent-infopage>>).


.le flux de travail complét d'un événement
image::opsiclientd-event-processing-flow.png["le flux de travail complét d'un événement",height=650]

[[opsi-manual-clientagent-configuration]]
==== Configuration

[[opsi-manual-clientagent-configuration-events]]
===== Configuration de différents événements

Pour répondre aux exigences des différentes situations dans lesquelles '{opsi-client-agent}' devient actif, une configuration un peu complexe est nécessaire. Afin de réduire la complexité, le fichier de configuration utilise quelque chose comme héritage. +
Dans l'entête de la section de configuration de '{opsiclientd}' par exemple +[event_<config-id>]+ introduit une nouvelle section de configuration des événements. Une configuration d'événement peut être désactivée en réglant l'option de section +active = false+.

Il existe différents types de configurations d'événements (+type+).

* Il y a 'event configuration templates' (type = template). +
Les configurations d'événements peuvent hériter les configurations d'un autre événement. Dans ce cas, l'option +super+ points à l'autre événement pour hériter de tous ses paramètres (à l'exclusion du paramètre +active+). Ces paramètres hérités peuvent être remplacées par des paramètres locaux dans la section événement en cours. Donc une section événement a besoin uniquement des paramètres qui sont différents de l'événement +super+. +
Le réglage d'un événement à +active = false+ ne change rien dans le processus d'héritage.

* Les autres types d'événements sont: +
  - +gui startup+ +
Un événement +gui startup+ débute lors du démarrage du client et le chargement de l''interface graphique utilisateur' (GUI). C'est l'événement le plus utilisé, définie comme active dans la configuration par défaut.

  - +custom+ +
Les configurations d'événement du type +custom+ sont déclenchés par un événement +wql+. Un événement +wql+ est défini par la déclaration correspondante +wql+ dans la configuration des événements. Si la déclaration +wql+ est vide, l'événement ne sera jamais déclenché, mais peut être exécutée à partir de l'interface Web interactive.

  - +user login+ +
sera déclenchée lors de la connexion d'un utilisateur.

  - +timer+ +
sera déclenchée toutes les +interval+ secondes.

  - +sync completed+ +
sera déclenchée si la synchronisation des configurations (+sync_config_from_server+) ou des produits (+cache_products+) est complété.

  - +sw on demand+ +
sera déclenchée par l'utilisateur choisissant 'Démarrer les actions maintenant' dans la page Web 'software-on-demand' de opsiclientd. Elle ne sera jamais déclenchée si 'software-on-Demand' n'est pas utilisé.

* Il y a des 'Preconditions' +
'Preconditions' définit des états spéciaux du système (par exemple un utilisateur est connecté).
Dans la configuration de '{opsiclientd}' une entête de section de la forme +[precondition_<precondition-id>]+ débute la déclaration d'une 'Precondition'.
Une 'Precondition' est vrai, si toutes les options déclarées sont vraies.
Une option non déclarée (mais possible) est supposé comme vraie. +
Les options possibles pour 'Preconditions' sont:
  - +user_logged_in+: est vrai si un utilisateur est actuellement connecté.
  - +config_cached+: est vrai si la mise en cache des données de configuration est terminée (voir: +sync_config_from_server+).
  - +products_cached+: est vrai si la mise en cache des fichiers du produit est terminée (voir: +cache_products+).

* Une 'Precondition' peut être affecté à une configuration d'événement. +
Cela peut être fait en mettant 'precondition' entre accolades à la fin de l'en-tête de section de configuration d'événement (par exemple +[event_on_demand{user_logged_in}]+). +
Si il y a une 'Precondition' dans un entête de configuration des événements, il doit également avoir une configuration pour cet événement sans 'precondition'.
Par exemple pour une configuration d'événement +event_on_demand{user_logged_in}+, il doit aussi y avoir une configuration d'événement +event_on_demand+ !
La configuration des événements avec condition préalable hérite de tous les paramètres de la configuration des événements sans 'precondition'. +
Si l'événement est déclenché, d'abord, il sera vérifié que 'preconditions' sont vraies. S'il n'y a pas de 'precondition' vraie, la configuration sans 'precondition' est utilisé.
Si une 'precondition' est vraie, la configuration utilisé est lié à cette 'precondition'.
Si plus d'une des 'preconditions' sont vraies, la configuration d'événement la plus spécifique est utilisée (qui est la configuration avec les options les plus appariement).


Un petit exemple pour mieux comprendre: +
Lors de l'installation du logiciel, il peut être nécessaire de redémarrer l'ordinateur. S'il y a actuellement un utilisateur connecté, vous devriez le mettre en garde contre le redémarrage en attente. Cet avertissement devrait avoir un délai d'attente et il peut être judicieux de demander à l'utilisateur, si le redémarrage devrait être annulée (pour le moment). +
Si aucun utilisateur n'est connecté, n'a aucun sens de demander et d'attendre une réponse. Donc, dans ce cas, le redémarrage devrait avoir lieu immédiatement. +
Pour faire face à ces différentes situations, il faut configurer +event_on_demand+ de la façon suivante:

* Nous définissons une 'Precondition' +user_logged_in+ qui se réalise si un utilisateur est connecté au système (+user_logged_in = true+).

* Dans la configuration par défaut de l'événement +event_on_demand+ (sans aucune 'Precondition') on met +shutdown_warning_time = 0+ (redémarrage immédiat sans avertissement).

* Dans la configuration +event_on_demand\{user_logged_in\}+ on met  +shutdown_warning_time = 300+ (avertissement avec 300 secondes de délai d'attente).

[[opsi-manual-clientagent-configuration-file]]
===== Configuration via le fichier de configuration

Le fichier de configuration est dans: +
`c:\program files\opsi.org\opsi-client-agent\opsiclientd\opsiclientd.conf`

CAUTION: Ce fichier de configuration est codé en UTF-8. +
Toute modification à l'aide des éditeurs qui ne prennent pas en charge ce type de codage (par exemple notepad.exe) peut détruire tout tréma dans ce fichier.

La configuration écrite dans ce fichier peut être modifié par des données de configuration différentes, qui viennent par le biais du service Web après une connexion réussie au '{opsi-server}'.

Un exemple de `opsiclientd.conf`:
[source,ini]
----
; = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = =
; =     configuration file for opsiclientd                              =
; = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = =


; - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
; -     global settings                                                 -
; - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
[global]

# Location of the log file.
log_file = c:\\tmp\\opsiclientd.log

# Set the log (verbosity) level
# (0 <= log level <= 9)
# 0: nothing, 1: essential, 2: critical, 3: errors, 4: warnings, 5: notices
# 6: infos, 7: debug messages, 8: more debug messages, 9: passwords
log_level = 4

# Client id.
host_id =

# Opsi host key.
opsi_host_key =

# Verify opsi server certs
verify_server_cert = false

# Verify opsi server certs by ca
verify_server_cert_by_ca = false

# On every daemon startup the user login gets blocked
# If the gui starts up and no events are being processed the login gets unblocked
# If no gui startup is noticed after <wait_for_gui_timeout> the login gets unblocked
# Set to 0 to wait forever
wait_for_gui_timeout = 120

# Application to run while blocking login
block_login_notifier = %global.base_dir%\\notifier.exe -s notifier\\block_login.ini

; - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
; -     config service settings                                         -
; - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
[config_service]
# Service url.
# http(s)://<opsi config server address>:<port>/rpc
url = https://opsi.uib.local:4447/rpc

# Conection timeout.
connection_timeout = 30

# The time in seconds after which the user can cancel the connection establishment
user_cancelable_after = 30

; - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
; -     depot server settings                                           -
; - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
[depot_server]

# Depot server id
depot_id =

# Depot url.
# smb://<depot address>/<share name>/<path to products>
url =

# Local depot drive
drive =

# Username that is used for network connection [domain\]<username>
username = pcpatch

; - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
; -     cache service settings                                          -
; - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
[cache_service]
# Maximum product cache size in bytes
product_cache_max_size = 5000000000

; - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
; -     control server settings                                         -
; - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
[control_server]

# The network interfaces to bind to.
# This must be the IP address of an network interface.
# Use 0.0.0.0 to listen to all interfaces
interface = 0.0.0.0

# The port where opsiclientd will listen for HTTPS rpc requests.
port = 4441

# The location of the server certificate.
ssl_server_cert_file = %global.base_dir%\\opsiclientd\\opsiclientd.pem

# The location of the server private key
ssl_server_key_file = %global.base_dir%\\opsiclientd\\opsiclientd.pem

# The location of the static files
static_dir = %global.base_dir%\\opsiclientd\\static_html

; - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
; -     notification server settings                                    -
; - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
[notification_server]

# The network interfaces to bind to.
# This must be the IP address of an network interface.
# Use 0.0.0.0 to listen to all interfaces
interface = 127.0.0.1

# The first port where opsiclientd will listen for notification clients.
start_port = 44000

# Port for popup notification server
popup_port = 45000

; - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
; -     opsiclientd notifier settings                                   -
; - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
[opsiclientd_notifier]

# Notifier application command
command = %global.base_dir%\\notifier.exe -p %port% -i %id%

; - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
; -     opsiclientd rpc tool settings                                   -
; - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
[opsiclientd_rpc]

# RPC tool command
command = %global.base_dir%\\opsiclientd_rpc.exe "%global.host_id%" "%global.opsi_host_key%" "%control_server.port%"

; - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
; -     action processor settings                                       -
; - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
[action_processor]
# Locations of action processor
local_dir = %global.base_dir%\\opsi-winst
remote_dir = opsi-winst\\files\\opsi-winst
filename = winst32.exe

# Action processor command
command = "%action_processor.local_dir%\\%action_processor.filename%" /opsiservice "%service_url%" /clientid %global.host_id% /username %global.host_id% /password %global.opsi_host_key%

# Load profile / environment of %run_as_user%
create_environment = false

; - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
; -     events                                                          -
; - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
[event_default]
; === Event configuration
# Type of the event (string)
type = template
# Interval for timer events in seconds (int)
interval = -1
# Maximum number of event repetitions after which the event will be deactivated (int, -1 = forever)
max_repetitions = -1
# Time in seconds to wait before event becomes active (int, 0 to disable delay)
activation_delay = 0
# Time in seconds to wait before an event will be fired (int, 0 to disable delay)
notification_delay = 0
# Event notifier command (string)
event_notifier_command = %opsiclientd_notifier.command% -s notifier\\event.ini
# The desktop on which the event notifier will be shown on (current/default/winlogon)
event_notifier_desktop = current
# Block login while event is been executed (bool)
block_login = false
# Lock workstation on event occurrence (bool)
lock_workstation = false
# Logoff the current logged in user on event occurrence (bool)
logoff_current_user = false
# Get config settings from service (bool)
get_config_from_service = true
# Store config settings in config file (bool)
update_config_file = true
# Transmit log file to opsi service after the event processing has finished (bool)
write_log_to_service = true
# Shutdown machine after action processing has finished (bool)
shutdown = false
# Reboot machine after action processing has finished (bool)
reboot = false

; === Sync/cache settings
# Sync configuration from local config cache to server (bool)
sync_config_to_server = false
# Sync configuration from server to local config cache (bool)
sync_config_from_server = false
# Sync configuration from local config cache to server after action processing (bool)
post_sync_config_to_server = false
# Sync configuration from server to local config cache after action processing (bool)
post_sync_config_from_server = false
# Work on local config cache
use_cached_config = false
# Cache products for which actions should be executed in local depot cache (bool)
cache_products = false
# Maximum transfer rate when caching products in byte/s (int, 0 = no limit)
cache_max_bandwidth = 0
# Dynamically adapt bandwith to other network traffic (bool)
cache_dynamic_bandwidth = false
# Work on local depot cache
use_cached_products = false

; === Action notification (if product actions should be processed)
# Time in seconds for how long the action notification is shown (int, 0 to disable)
action_warning_time = 0
# Action notifier command (string)
action_notifier_command = %opsiclientd_notifier.command% -s notifier\\action.ini
# The desktop on which the action notifier will be shown on (current/default/winlogon)
action_notifier_desktop = current
# Message shown in the action notifier window (string)
action_message = Starting to process product actions. You are allowed to cancel this event a total of %action_user_cancelable% time(s). The event was already canceled %state.action_processing_cancel_counter% time(s).
# German translation (string)
action_message[de] = Starte die Bearbeitung von Produkt-Aktionen. Sie können diese Aktion insgesamt %action_user_cancelable% mal abbrechen. Die Aktion wurde bereits %state.action_processing_cancel_counter% mal abgebrochen.
# Number of times the user is allowed to cancel the execution of actions (int)
action_user_cancelable = 0

; === Action processing
# Should action be processed by action processor (bool)
process_actions = true
# Type of action processing (default/login)
action_type = default
# Update the action processor from server before starting it (bool)
update_action_processor = true
# Command which should be executed before start of action processor
pre_action_processor_command =
# Action processor command (string)
action_processor_command = %action_processor.command%
# The desktop on which the action processor command will be started on (current/default/winlogon)
action_processor_desktop = current
# Action processor timout in seconds (int)
action_processor_timeout = 10800
# Command which should be executed before after action processor has ended
post_action_processor_command =

; === Shutdown notification (if machine should be shut down or rebooted)
# Process shutdown requests from action processor
process_shutdown_requests = true
# Time in seconds for how long the shutdown notification is shown (int, 0 to disable)
shutdown_warning_time = 0
# Shutdown notifier command (string)
shutdown_notifier_command = %opsiclientd_notifier.command% -s notifier\\shutdown.ini
# The desktop on which the action notifier will be shown on (current/default/winlogon)
shutdown_notifier_desktop = current
# Message shown in the shutdown notifier window (string)
shutdown_warning_message = A reboot is required to complete software installation tasks. You are allowed to delay this reboot a total of %shutdown_user_cancelable% time(s). The reboot was already delayed %state.shutdown_cancel_counter% time(s).
# German translation (string)
shutdown_warning_message[de] = Ein Neustart wird benötigt um die Software-Installationen abzuschliessen. Sie können diesen Neustart insgesamt %shutdown_user_cancelable% mal verschieben. Der Neustart wurde bereits %state.shutdown_cancel_counter% mal verschoben.
# Number of times the user is allowed to cancel the shutdown (int)
shutdown_user_cancelable = 0
# Time in seconds after the shutdown notification will be shown again after the user has canceled the shutdown (int)
shutdown_warning_repetition_time = 3600

[event_gui_startup]
super = default
type = gui startup
name = gui_startup
block_login = true

[event_gui_startup{user_logged_in}]
name = gui_startup
shutdown_warning_time = 300
block_login = false

[event_gui_startup{cache_ready}]
use_cached_config = true
use_cached_products = true
action_user_cancelable = 3
action_warning_time = 60

[event_on_demand]
super = default
type = custom
name = on_demand

[event_on_demand{user_logged_in}]
name = on_demand
shutdown_warning_time = 300

[event_software_on_demand]
super = default
type = sw on demand

[event_sync]
super = default
type = template
process_actions = false
event_notifier_command =
sync_config_to_server = true
sync_config_from_server = true
cache_products = true
cache_dynamic_bandwidth = true

[event_timer]
super = sync
type = timer
active = false
interval = 3600

[event_net_connection]
super = sync
type = custom
active = false
wql = SELECT * FROM __InstanceModificationEvent WITHIN 2 WHERE TargetInstance ISA 'Win32_NetworkAdapter' AND TargetInstance.NetConnectionStatus = 2

[event_sync_completed]
super = default
type = sync completed
event_notifier_command =
process_actions = false
get_config_from_service = false
write_log_to_service = false

[event_sync_completed{cache_ready_user_logged_in}]
reboot = true
shutdown_user_cancelable = 10
shutdown_warning_time = 300

[event_sync_completed{cache_ready}]
reboot = true

[event_user_login]
super = default
type = user login
action_type = login
active = false
message = Starting to process user login actions.
message[de] = Beginne mit der Verarbeitung der Benutzer-Anmeldungs-Aktionen.
block_login = false
process_shutdown_requests = false
get_config_from_service = false
update_config_file = false
write_log_to_service = false
update_action_processor = false
action_notifier_command = %opsiclientd_notifier.command% -s notifier\\userlogin.ini
action_notifier_desktop = default
action_processor_command = %action_processor.command% /usercontext %event.user%
action_processor_desktop = default
action_processor_timeout = 300

[precondition_user_logged_in]
user_logged_in = true

[precondition_cache_ready]
config_cached = true
products_cached = true

[precondition_cache_ready_user_logged_in]
user_logged_in = true
config_cached = true
products_cached = true
----

[[opsi-manual-clientagent-configuration-webservice]]
===== Configuration via le web service (Host Parameter)

La configuration de opsiclientd peut être modifié par l'onglet 'Réseau et paramètres supplémentaires' dans l'interface de gestion OPSI.

Les entrées dans 'Réseau et paramètres supplémentaires' doivent être selon les modes suivants:

`opsiclientd.<nom de la section>.<nom de la clé>`

Exemple: +
`opsiclientd.event_gui_startup.action_warning_time = 20` +
définie dans le fichier configuration `opsiclientd.conf` dans la section +[event_gui_startup]+ la valeur de +action_warning_time+ à 20.

La figure ci-dessous montre comment changer la configuration générale du serveur via '{opsi-configed}'

.Réglage de la configuration du serveur par défaut pour opsiclientd
image::opsiclientd-configuration-via-configed-serverdefault.png["Réglage de la configuration du serveur par défaut pour opsiclientd",width=400]

Utilisant le menu contextuel, vous pouvez choisir 'ajouter une propriété' pour définir une nouvelle paire clé/valeur.

Pour supprimer un défaut du serveur, utilisez l'outil '{opsi-admin}':

Exemple:
[source,prompt]
----
opsi-admin -d method config_delete "opsiclientd.event_gui_startup.action_warning_time"
----

Il est également possible de manipuler ces entrées spécifiquement pour un client via '{opsi-configed}'.

Pour supprimer une entrée spécifique au client, utilisez l'outil '{opsi-admin}':

Exemple:

[source,prompt]
----
@opsi-admin> method configState_delete "opsiclientd.event_gui_startup.action_warning_time" "myclient.uib.local"
----

.configuration spécifique au client {opsiclientd} via {opsi-configed}
image::opsiclientd-configuration-via-configed.png["configuration spécifique au client {opsiclientd} via {opsi-configed}",width=400]


[[opsi-manual-clientagent-logging]]
==== Journalisation

'{opsiclientd}' ecrit ces logs dans: +
`c:\tmp\opsiclientd.log`.

Toutes les informations du journal seront transférés à '{opsi-configserver}' via le web service. Au niveau du serveur vous trouverez ces infos dans `/var/log/opsi/clientconnect/<ip-ou-nom-du-client>.log`. Ils sont présentés dans opsiconfiged à l'onglet 'Journaux systèmes / clientconnect'.

Chaque ligne du journal a le motif: +
+[<log level>] [<time stamp>] [message source] message+.

Il y a les niveaux de journalisation suivants:
....
# Set the log (verbosity) level
# (0 <= log level <= 9)
# 0: rien, 1: essentiel, 2: critique, 3: erreurs, 4: avertissements, 5: notices
# 6: infos, 7: messages de débogage, 8: plus de messages de débogage, 9: mots de passe
....

Exemple:
[source,opsilog]
----
(...)
[5] [Mar 22 10:17:46] [ event processing gui_startup  ] Event config 'sync_completed{cache_ready}' added to event generator 'sync_completed'   (Events.pyo|1107)
[5] [Mar 22 10:17:46] [ event processing gui_startup  ] Event config 'gui_startup' added to event generator 'gui_startup'   (Events.pyo|1107)
[5] [Mar 22 10:17:46] [ event processing gui_startup  ] Event config 'gui_startup{cache_ready}' added to event generator 'gui_startup'   (Events.pyo|1107)
[5] [Mar 22 10:17:46] [ event processing gui_startup  ] Event config 'on_demand' added to event generator 'on_demand'   (Events.pyo|1107)
[5] [Mar 22 10:17:46] [ event processing gui_startup  ] Event config 'sync_completed{cache_ready_user_logged_in}' added to event generator 'sync_completed'   (Events.pyo|1107)
[5] [Mar 22 10:17:46] [ event processing gui_startup  ] Event config 'gui_startup{user_logged_in}' added to event generator 'gui_startup'   (Events.pyo|1107)
[5] [Mar 22 10:17:46] [ event processing gui_startup  ] Event config 'sync_completed' added to event generator 'sync_completed'   (Events.pyo|1107)
[5] [Mar 22 10:17:46] [ event processing gui_startup  ] Event config 'software_on_demand' added to event generator 'software_on_demand'   (Events.pyo|1107)
[5] [Mar 22 10:17:46] [ event processing gui_startup  ] Event config 'on_demand{user_logged_in}' added to event generator 'on_demand'   (Events.pyo|1107)
[5] [Mar 22 10:17:46] [ event processing gui_startup  ] Updating config file: 'C:\Program Files (x86)\opsi.org\opsi-client-agent\opsiclientd\opsiclientd.conf'   (Config.pyo|287)
[5] [Mar 22 10:17:46] [ event processing gui_startup  ] No need to write config file 'C:\Program Files (x86)\opsi.org\opsi-client-agent\opsiclientd\opsiclientd.conf', config file is up to date   (Config.pyo|318)
[5] [Mar 22 10:17:46] [ event processing gui_startup  ] No product action requests set   (EventProcessing.pyo|591)
[5] [Mar 22 10:17:49] [ event processing gui_startup  ] Writing log to service   (EventProcessing.pyo|247)
[6] [Mar 22 10:17:49] [ opsiclientd                   ] shutdownRequested: 0   (Windows.pyo|340)
[6] [Mar 22 10:17:49] [ opsiclientd                   ] rebootRequested: 0   (Windows.pyo|326)
[5] [Mar 22 10:17:49] [ opsiclientd                   ] Block login now set to 'False'   (Opsiclientd.pyo|111)
[6] [Mar 22 10:17:49] [ opsiclientd                   ] Terminating block login notifier app (pid 1620)   (Opsiclientd.pyo|148)
[6] [Mar 22 10:17:49] [ event processing gui_startup  ] Stopping notification server   (EventProcessing.pyo|225)
[6] [Mar 22 10:17:51] [ control server                ] client connection lost   (Message.pyo|464)
[6] [Mar 22 10:17:52] [ event processing gui_startup  ] Notification server stopped   (Message.pyo|651)
[5] [Mar 22 10:17:52] [ event processing gui_startup  ] ============= EventProcessingThread for event 'gui_startup' ended =============   (EventProcessing.pyo|1172)
[5] [Mar 22 10:17:52] [ opsiclientd                   ] Done processing event '<ocdlib.Events.GUIStartupEvent object at 0x023CE330>'   (Opsiclientd.pyo|405)
[5] [Mar 22 10:19:41] [ opsiclientd                   ] Session 'HSzMB1wtOiBS6vHl7mh3ro5r6s3TanFu' from ip '127.0.0.1', application 'opsi jsonrpc module version 4.0.1' expired after 120 seconds   (Session.pyo|184)
[6] [Mar 22 10:19:41] [ opsiclientd                   ] Session timer <_Timer(Thread-20, started daemon 2636)> canceled   (Session.pyo|120)
[5] [Mar 22 10:19:41] [ opsiclientd                   ] Session 'HSzMB1wtOiBS6vHl7mh3ro5r6s3TanFu' from ip '127.0.0.1', application 'opsi jsonrpc module version 4.0.1' deleted   (Session.pyo|207)
[6] [Mar 22 10:27:55] [ control pipe                  ] Creating pipe \\.\pipe\opsiclientd   (ControlPipe.pyo|253)
[5] [Mar 22 10:27:55] [ event generator wait_for_gui  ] -----> Executing: getBlockLogin()   (JsonRpc.pyo|123)
[5] [Mar 22 10:27:55] [ opsiclientd                   ] rpc getBlockLogin: blockLogin is 'False'   (ControlPipe.pyo|428)
[6] [Mar 22 10:27:55] [ event generator wait_for_gui  ] Got result   (JsonRpc.pyo|131)
'
----

'{opsi-login-blocker}' enregistre dans le fichier journal: `c:\tmp\opsi_loginblocker.log`.

[[opsi-manual-clientagent-infopage]]
==== {opsiclientd} page d'information

D'après les fait qu'il existe un grand nombre de sous-composants de '{opsiclientd}' qui travaillent et journalisent en même temps, le fichier journal de '{opsiclientd}' devient complexe.

Afin de rendre plus facile à comprendre comment les différents sous-composants travaillent ensemble, '{opsiclientd}' a une propre "page d'information" qui permet de visualiser les tâches en cours d'exécution sur une chronologie. +
Vous pouvez voir cette "page d'information" dans le navigateur à l'adresse: +
https://<address-of-the-client>:4441/info.html

.Page d'information de {opsiclientd} après l'installation poussée avec le cache activé du produit
image::opsiclientd_infopage_event_on_demand.png["Page d'information de {opsiclientd} après l'installation poussée avec le cache activé du produit",width=400]

[[opsi-manual-clientagent-control]]
==== {opsi-client-agent} commande à distance

'{opsiclientd}' possède sa propre interface de service Web qui peut être utilisé pour transmettre des commandes à '{opsiclientd}'. Les commandes possibles peuvent être répartis dans les catégories suivantes:

* envoyer des messages (Popup)
* 'Pousser' les installations (démarrer l'événement 'on_demand')
* autres tâches de maintenance

Cela peut être fait en ligne de commande en utilisant l'outil '{opsi-admin}' en appelant l'une des méthodes +hostControl_*+. L'appel à une de ces méthodes prend le paramètre +*hostid+ qui:

* peut être déposé pour envoyer la commande à tous les clients
* peut être le nom d'un client (ex. "pcbon4.uib.local")
* peut être une liste de noms de client selon le schéma [ <client1>, <client2>] +
ex. ["pcbon1.uib.local", "pcbon2.uib.local"]
* peut contenir des jokers comme +*+
+
ex. "pcbon4.\*" or "pcbon*"

Si un client n'est pas joignable (par exemple hors tension) vous obtiendrez un message.

[[opsi-manual-clientagent-control-messages]]
===== L'envoi de messages pop-up

En utilisant '{opsi-configed}' vous pouvez envoyer des messages aux clients.
 <<opsi-manual-configuration-tools-opsi-configed-client-editing-send-message>>


Sur la ligne de commande, vous pouvez le faire avec l'outil '{opsi-admin}':
[source,prompt]
----
opsi-admin -d method hostControl_showPopup message *hostid
----

Exemple:
[source,prompt]
----
opsi-admin -d method hostControl_showPopup "This is my message" "myclient.uib.local"
----

[[opsi-manual-clientagent-control-fire-event]]
===== 'Pousser' les installations: démarrer l'événement 'à la demande'

'{opsi-server}' peut envoyer une commande au client que le client doit traiter les requêtes d'actions configurées immédiatement. Ceci est fait en activant l'événement 'on_demand' sur le client.

Ceci est possible en utilisant '{opsi-configed}' et il est décrit dans le chapitre:
'Pousser' l'installation: démarrer l'événement 'on demand'

A partir de '{opsi-server}' le client peut être invité à exécuter les '{product-actions}'.

L'exécution d'événements peut également être effectuée à partir de '{opsi-configed}'.
<<opsi-manual-configuration-tools-opsi-configed-client-editing-ondemand>>

Sur la ligne de commande, vous pouvez utiliser '{opsi-admin}' pour déclencher un événement:
[source,prompt]
----
opsi-admin -d method hostControl_fireEvent event *hostIds
----

Exemple:
[source,prompt]
----
opsi-admin -d method hostControl_fireEvent "on_demand" "myclient.uib.local"
----

[[opsi-manual-clientagent-control-misc]]
===== Tâches de maintenance supplémentaires (arrêt, redémarrage,.....)

En utilisant le port de contrôle du serveur vous pouvez contrôler à distance '{opsiclientd}'. Pour ce faire, vous devez vous authentifier auprès du service web. Cela pourrait se faire soit avec le compte d'administrateur local (avec un mot de passe non vide) ou avec le '{opsi-host-id}' (FQDN, le nom du client et le nom de domaine DNS) comme nom d'utilisateur et le opsi-hostkey comme mot de passe.

En utilisant '{opsi-configed}' vous pouvez choisir le menu 'opsiClient' ou le menu contextuel de l'onglet 'Selection des clients'.

.Service Web de {opsiclientd}
image::opsiclientd-control-server-web-interface.png["Service Web de {opsiclientd}",width=400]

Sur la ligne de commande, vous pouvez également démarrer un client:

arrêt:
[source,prompt]
----
opsi-admin -d method hostControl_shutdown *hostIds
----

redémarrage:
[source,prompt]
----
opsi-admin -d method hostControl_reboot *hostIds
----

[[opsi-manual-clientagent-loginblock]]
=== Blocage de la connexion de l'utilisateur avec opsi-Loginblocker

Pour éviter une connexion de l'utilisateur avant que toutes les installations sont terminées, opsi fournit l'option '{opsi-login-blocker}'.


[[opsi-manual-clientagent-loginblock-nt5]]
==== opsi loginblocker de Windows 2000 à XP (NT 5)

'{opsi-login-blocker}' est implémenté comme 'Gina' `opsigina.dll`. 'Gina' signifie 'Graphical Identification and Authentication' et c'est le hook officiel de Microsoft pour manipuler le processus de connexion.

Si vous avez déjà un particulier 'Gina-DLL' installé, qui est différent de l'original Microsoft 'msgina.dll' (ex. Novell 'nwgina.dll'), vous ne devez pas installer '{opsi-login-blocker}' sans consulter opensides ou https://forum.opsi.org. Il est possible de chaîner différentes gina.dll's, mais par conséquent l'installation doit être personnalisée. L'enchaînement correct des DLL Gina est une tâche très critique et peut entraîner un verrouillage de l'ordinateur si cela est fait incorrectement.

Que '{opsi-login-blocker}' est installé ou pas est configuré par le commutateur 'LoginBlockerStart=on/off' dans la section [opsi-client-agent-install] de la configuration du client.


[[opsi-manual-clientagent-loginblock-nt6]]
==== opsi loginblocker pour NT 6 (Win 7 & Co)
'{opsi-login-blocker}' dans Vista est implémenté comme un "Filtre fournisseur d'informations d'identification". Il bloque tous "informations d'identification" jusqu'à la libération par '{opsiclientd}' ou délai d'attente.

[[opsi-manual-clientagent-subsequent-installation]]
=== Installation ultérieure de opsi-client-agents
Les informations sur une 'Installation ultérieure de opsi-client-agent' vous les trouverez dans le manuel 'opsi-getting-started' (Chapitre 'Premières étapes').

[[opsi-manual-clientagent-image-installation]]
==== Installation de opsi-client-agent à partir d'une image maître ou comme exe
### doit être écrit ###




