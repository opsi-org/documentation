////
; Copyright (c) uib gmbh (www.uib.de)
; Cette documentation appartient à uib
; et publié sous licence Creative Commons by-sa allemande
; voir:
; https://creativecommons.org/licenses/by-sa/3.0/de/
; https://creativecommons.org/licenses/by-sa/3.0/de/legalcode
; anglais:
; https://creativecommons.org/licenses/by-sa/3.0/
; https://creativecommons.org/licenses/by-sa/3.0/legalcode
; 
; crédits: http://www.opsi.org/credits/
////


:Author:    uib gmbh
:Email:     info@uib.de
:Date:      11.07.2012
:Revision:  4.0.2
:doctype:	book

// Include common opsi terms
include::../common/opsi_terms.asciidoc[]



opsi-winst Manual (4.11.3)
============================

// Include common opsi copyright
include::../common/opsi_manual_copyright.asciidoc[]


[[opsi-winst-introduction]]
== Présentation

Le programme open source '{opsi-winst}' sert dans le contexte de OPSI – serveur d'intégration de pc (cf. www.opsi.org) – comme rôle central pour initier et effectuer l'installation automatique du logiciel. Il peut également être utilisé seul comme un outil pour les programmes d'installation pour n'importe quel logiciel. 

'{opsi-winst}' est fondamentalement un interprète pour un particulier, assez simple, langage de script qui peut être utilisé pour exprimer tous les éléments pertinents d'une installation de logiciel. 

Une installation du logiciel qui est décrit par un script '{opsi-winst}' et exécuté par l'exécution du script a plusieurs avantages par rapport aux installations qui sont gérées par un tas de commandes Shell (par exemple copie etc):

* '{opsi-winst}' montre dans le fichier journal très soigneusement toutes les opérations du processus d'installation. L'équipe de support peut vérifier les fichiers journal, et peut facilement détecter quand des erreurs sont survenues ou d'autres circonstances problématiques.

* Les actions de copie peut être configuré avec une grande variété d'options si les fichiers existants doivent être écrasés

* Surtout, il peut être configuré que les fichiers sont copiés selon leur version interne.

* Il y a différents modes pour écrire dans le registre Windows:
** écraser les valeurs existantes
** écrire seulement quand aucune valeur existe
** ajouter une valeur à une valeur existante.

* Le registre de Windows peut être patché pour tous les utilisateurs existant sur un poste de travail (y compris l'utilisateur par défaut, qui est utilisé comme prototype pour d'autres utilisateurs).

* Il y a une syntaxe sophistiquée pour un patch intégré des fichiers de configuration XML.


[[opsi-winst-cliparams]]
== Démarrage et options de la ligne de commande

Depuis la version 4.11.3, le programme '{opsi-winst}' contient un manifeste avec l'énoncé suivant: +
`<requestedExecutionLevel level="highestAvailable" />`. Cela signifie que si '{opsi-winst}' est appelée sur un OS NT6 par un administrateur, il fonctionnera comme un processus 'élevé'. Si '{opsi-winst}' est appelée avec des privilèges d'utilisateur normal, il s'exécutera avec les privilèges de cet utilisateur.

'{opsi-winst}' peut être démarré avec différents ensembles de paramètres dépendant du contexte et du but de l'utilisation. 

Il y a les suivants schémas syntaxique:

(1) Montrer l'utilisation (aide):

`opsi-winst /?` +
`opsi-winst /h`[elp]

(2 ) Exécuter un script 

`opsi-winst` <fichier de script> +
      [`/logfile` <fichier journal> ] +
      [`/batch` | `/histolist` <Chemin du fichier de config de opsi-winst>] +
      [`/usercontext` <[domaine\]nom d'utilisateur> ] +
      [`/parameter` <chaîne de paramètres>]

(3) Exécuter une liste de scripts (séparées par des virgules) un par un:

`opsi-winst` `/scriptfile` <fichier de script> [;<fichier de script>]* [ `/logfile` <fichier journal> ] +
      [`/batch` | `/silent` ] +
      [`/usercontext` <[domaine\]nom d'utilisateur> ] +
      [`/parameter` <chaîne de paramètres>] +

4) Lire la configuration du PC à partir du service OPSI et agir en conséquence, depuis '{opsi-winst}' 4.11.2

`opsi-winst /opsiservice` <URL du service OPSI> +
     `/clientid` <nom du client> +
     `/username` <nom d'utilisateur> +
     `/password` <mot de passe> +
     [`/sessionid` <id de la session>] +
     [`/usercontext` <[domaine\]nom d'utilisateur>] +
     [`/allloginscripts` | `/loginscripts`] +
     [`/silent`]  +
     
   
Quelques explications:

* Le nom par défaut du fichier de log est `c:\tmp\instlog.txt`

* La chaîne de paramètres, qui se caractérise par l'option `/parameter`, est accessible pour chaque script appelé de '{opsi-winst}' (via la fonction de chaîne `ParamStr`).


Explications pour (2) et (3) :

* Si l'option `/batch` est utilisé, alors '{opsi-winst}' montre seulement sa "batch surface" n'offrant aucune dialogues utilisateur. Par l'option `/silent` même la "batch surface" est supprimée. Sans l'aide de l'option `/batch` nous entrons dans le mode interactif où le fichier de script et le fichier journal peuvent être choisis de manière interactive (principalement pour des fins de test). 

* Le paramètre `winstconfigfilepath` qui est désigné par `/histofile` se réfère à un fichier au format ini qui contient (en mode interactif) les dernières noms de fichier de script utilisé. La surface de dialogue présente une zone de liste qui affiche ces noms de fichiers pour choisir le fichier suivant à interpréter. Si `winstconfigfilepath` se termine par "\" il est supposé être un nom de répertoire et `WINST.INI` sert de nom de fichier.

Explications pour (4):

* La valeur par défaut pour `clientid` est le nom d'ordinateur complet

* Quand il est appelé avec l'option `/allloginscripts` ou `/loginscripts` '{opsi-winst}' fait les configurations pour l'utilisateur de la session courante (particulièrement dans un contexte de profils Itinérants). C'est une option en co-financement - vous devez l'acheter pour pouvoir l'utiliser. +
Regardez le manuel d'opsi pôur plus d'information sur la 'Gestion des profils utilisateur'.

* Avec l'option `/silent` la surface "batch" est supprimée.


Le mode non interactif est implicite.
     
[[opsi-winst-logpath]]
=== Chemins des journaux système

Par défaut les journaux système sont écrits dans le répertoire `c:\tmp` qui  '{opsi-winst}' essaie de créer. Si '{opsi-winst}' n'a pas accès à ce répertoire, il utilise le répertoire temporaire de l'utilisateur. 

Le nom du journal système par défaut est `instlog.txt`. Le nom du fichier journal et l'emplacement seront écrasées par l'option spécifiques en ligne de commande. 

Dans le cas, que '{opsi-winst}' exécute un script dans le mode `/batch` et avec un contexte utilisateur (et de travail) spécifié, le chemin d'enregistrement par défaut est `opsi/tmp` dans le répertoire ApplicationData de l'utilisateur. Ce sera écrasé par un chemin de journal donné explicitement.

En plus, '{opsi-winst}' utilise le répertoire de journalisation pour la sauvegarde de certains fichiers temporaires.

[[opsi-winst-configuration-options]]
== Configurations supplémentaires 

[[opsi-winst-central-logging]]
=== Journalisation centrale des messages d'erreur

Si vous le souhaitez, '{opsi-winst}' écrit les données d'erreur dans un second fichier sur un lecteur réseau ou les envoie à un démon syslog.

La fonction peut être configuré dans le registre Windows:

Dans HKEY_LOCAL_MACHINE, nous avons, dans une installation standard, la clé  \SOFTWARE\opsi.org.  Nous pouvons créer une sous-clé syslogd avec une variable remoteerrorlogging. Sa valeur détermine si, et si oui par quelle méthode, une journalisation centrale doit avoir lieu.

En outre, dans +
'HKEY_LOCAL_MACHINE\SOFTWARE\opsi.org\syslogd' +
nous devons observer trois variables:

* Si remoteerrorlogging a la valeur 0, aucun log supplémentaires centrale a lieu (par défaut).

////
* Si remoteerrorlogging a la valeur 1, '{opsi-winst}' essaie d'ouvrir un $pcname$.err dans configshare, sous-répertoire pcpatch\pclog, et écrire les données. 
////

* Si remoteerrorlogging a la valeur 2, les rapports d'erreur sont envoyés à syslog démon. Le nom d'hôte du démon est lu dans la variable sysloghost (défaut localhost) , le numéro du canal syslog peut être configuré à partir de la valeur de la variable syslogfacility (par défaut 18, qui est local2).

Le tableau suivant montre les valeurs possibles:

[source,ini]
----
ID_SYSLOG_FACILITY_KERNEL     = 0;  // messages du kernel 
ID_SYSLOG_FACILITY_USER       = 1;  // messages du niveau utilisateur
ID_SYSLOG_FACILITY_MAIL       = 2;  // système de messagerie
ID_SYSLOG_FACILITY_SYS_DAEMON = 3;  // démons système
ID_SYSLOG_FACILITY_SECURITY1  = 4;  // sécurité / messages d'autorisation (1)
ID_SYSLOG_FACILITY_INTERNAL   = 5;  // messages générés en interne par syslogd
ID_SYSLOG_FACILITY_LPR        = 6;  // imprimante système
ID_SYSLOG_FACILITY_NNTP       = 7;  // sous-système de nouvelles du réseau
ID_SYSLOG_FACILITY_UUCP       = 8;  // UUCP sous-système
ID_SYSLOG_FACILITY_CLOCK1     = 9;  // démon horloge (1)
ID_SYSLOG_FACILITY_SECURITY2  = 10; // sécurité / messages d'autorisation (2)
ID_SYSLOG_FACILITY_FTP        = 11; // démon FTP
ID_SYSLOG_FACILITY_NTP        = 12; // sous-système NTP
ID_SYSLOG_FACILITY_AUDIT      = 13; // journal d'audit
ID_SYSLOG_FACILITY_ALERT      = 14; // journal d'alerte
ID_SYSLOG_FACILITY_CLOCK2     = 15; // démon horloge (2)
ID_SYSLOG_FACILITY_LOCAL0     = 16; // utilisation locale 0  (local0)
ID_SYSLOG_FACILITY_LOCAL1     = 17; // utilisation locale 1  (local1)
ID_SYSLOG_FACILITY_LOCAL2     = 18; // utilisation locale 2  (local2)
ID_SYSLOG_FACILITY_LOCAL3     = 19; // utilisation locale 3  (local3)
ID_SYSLOG_FACILITY_LOCAL4     = 20; // utilisation locale 4  (local4)
ID_SYSLOG_FACILITY_LOCAL5     = 21; // utilisation locale 5  (local5)
ID_SYSLOG_FACILITY_LOCAL6     = 22; // utilisation locale 6  (local6)
ID_SYSLOG_FACILITY_LOCAL7     = 23; // utilisation locale 7  (local7)
----

[[opsi-winst-skins]]
=== Thèmes {opsi-winst}

Depuis la version 3.6  '{opsi-winst}' l'interface peut être personnalisée. Les éléments de personnalisation sont situés dans un sous-répertoire winstskin du répertoire '{opsi-winst}'. Le fichier de configuration que vous pouvez éditer est skin.ini. 

Depuis la version 4.11.3.5 'opsi-winst' recherche le répertoire skin dans l'ordre suivant (le premier répertoire avec skin.ini trouvé l'emporte):

. `%WinstDir%\..\custom\winstskin`
. `%WinstDir%\winstskin`

Avec la commande `SetSkinDirectory` le répertoire skin à utiliser peut être défini dans le script. Si le chemin d'accès spécifié est vide ou non valide, le chemin par défaut sera utilisé.

Exemple:
[source,winst]
----
SetSkinDirectory "%ScriptPath%\testskin"
sleepseconds 1
SetSkinDirectory ""
----

[[opsi-winst-script]]
== Le script opsi-winst

En principe:  '{opsi-winst}' est un interprète pour un particulier, facile à utiliser, langage de script qui est adapté pour les besoins des installations de logiciels. Un script devrait être une description intégrée, et un moyen de contrôle, pour l'installation d'un logiciel.

La section suivante esquisses de la structure d'un script '{opsi-winst}'. Le but est d'identifier les signets d'un script: de quelle manière nous devons étudier la question pour comprendre son traitement.

Tous les éléments sont décrits plus en détail dans la section plus loin. Le but sera alors de montrer comment les scripts peuvent être modifiés ou développés.

[[opsi-winst-script-first-example]]
=== Un Exemple

Les scripts '{opsi-winst}' sont à peu près issus des fichiers .INI. Ils sont composés de sections, qui sont marquées par un titre (le nom de section), qui est écrite entre parenthèses []. 

Schématiquement un script '{opsi-winst}' ressemble à celui (ici avec une vérification de quel système d'exploitation est installé):

[source,winst]
----
[Actions]
Message "Installation de Mozilla"
SetLogLevel=6

;which Windows-Version?
DefVar $MSVersion$

Set $MSVersion$ = GetMsVersionInfo
if ($MSVersion$ >= "6")
     sub_install_win7
else
  if ( $MSVersion$ = "5.1" )
    sub_install_winXP
  else
    stop "ce n'est pas une version d'OS supporté"
  endif
endif
  

[sub_install_win7]
Files_copy_win7
WinBatch_Setup

[sub_install_winXP]
Files_copy_XP
WinBatch_SetupXP

[Files_copy_win7]
copy "%scriptpath%\files_win7\*.*" "c:\temp\installation"

[Files_copy_winxp]
copy "%scriptpath%\files_winxp\*.*" "c:\temp\installation"

[WinBatch_Setup]
c:\temp\installation\setup.exe

[WinBatch_SetupXP]
c:\temp\installation\install.exe
-----

Comment pouvons-nous lire les sections de ce script?

[[opsi-winst-kinds-of-sections]]
=== Sous-programmes primaires et secondaires d'un script opsi-winst

Le script dans son ensemble constitue un programme, une instruction pour une procédure d'installation. Ainsi chacune de ses sections peut être vu comme un sous-programme (ou "procedure" ou "method").  Le script est une collection de sous-programmes.

Le lecteur humain ainsi qu'un logiciel interprète, doivent savoir à partir de quel élément de cette collection doit commencer la lecture.

L'exécution d'un script '{opsi-winst}' commence sur les section [Actions]. Toutes les autres sections sont appelés comme sous-programmes. Ce processus n'est récursif que pour les sous-sections: Sub-sections ont la même syntaxe que les section Actions et peuvent contenir des appels à des sous-routines supplémentaires.

NOTE: Si un script est executé comme 'userLoginScript' et contient une section [ProfileActions], l'interprétation du script démarrera à la section `ProfleActions`.

Cela donne la raison de faire la distinction entre les sous-programmes primaire et secondaire:

Les sections de contrôle primaire ou générale comprennent 

* la section *Actions* 

* *Sub* sections (de 0 à n sous-programmes appelés par la section *Actions* qui sont des extensions syntaxiques et logiques de la section d'appel).

* la section *ProfileActions*, qui sera interpretée de differents façons selon le mode du script (Machine/Login).

La logique procédurale du script est déterminé par la séquence d'appels dans ces sections. 

Les sections secondaires ou spécifiques peuvent être appelés depuis n'importe quelle section primaire, mais ont une syntaxe différente. La syntaxe est dérivé des exigences fonctionnelles et des conditions de la bibliothèque et des conventions pour les fins spécifiques. Par conséquent, aucune autre section peut être appelé à partir d'une section secondaire.

En ce moment il y a les types suivants de sections secondaires:

* Files sections, 
* WinBatch sections,
* ShellScript sections,
* Registry sections
* Patches sections,
* PatchHosts sections,
* PatchTextFile sections,
* XMLPatch sections,
* LinkFolder sections,
* opsiServiceCall sections,
* ExecPython sections,
* ExecWith sections,
* LDAPsearch sections.

Sens et syntaxe des types de sections différentes sont traitées dans
<<opsi-winst-prim-section>>
et
<<opsi-winst-secsections>>.

[[opsi-winst-stringvalues]]
=== Expressions de chaîne dans un script opsi-winst

Les valeurs textuels (valeurs de chaîne) dans les sections primaires peuvent être donnés de façon différente:

* La valeur peut être directement cités, surtout par écrit en marques de citation (entre double). Exemples: +
'"Installation de Mozilla"' +
'"n:\home\nom d'utilisateur"'

* La valeur peut être donnée par une variable chaîne ou une constante chaîne, qui "contient" la valeur: +
La variable '$MsVersion$' peut se porter "6.1"  –  si elle a été affectée avant avec cette valeur.

* Une fonction récupère ou calcule une valeur par une procédure interne. Par exemple:
`EnvVar ("Username")` +
récupère une valeur de l'environnement système, dans ce cas, la valeur de la variable d'environnement 'Username'.  Les fonctions peuvent avoir n'importe quel nombre de paramètres, y compris le zéro: +
`GetMsVersionInfo` +
Sur un système Win7, cet appel de fonction donne la valeur "6.1" (non pas comme une variable, cette valeur doit être produite à chaque appel à nouveau). 

* Une valeur peut être construit par une expression adjuvant, où les valeurs de chaîne et d'expressions partielles sont concaténés - théoriquement "plus" peut être vu comme une fonction de deux paramètres: +
'$Home$ + "\mail"'


(Plus sur ce sujet dans <<opsi-winst-string>>)

Il n'y a pas de façon analogue d'utiliser des expressions de chaîne dans les sections secondaires. Ils y suivent une syntaxe de domaine spécifique. Par exemple pour les commandes de copie, similaire à la commande de copie en ligne de Windows. Jusqu'à ce moment, il n'y a pas de syntaxe d'échappement mis en œuvre pour le transport de la logique de section primaire vers une section secondaire.

La seule façon pour le transport de valeurs de chaîne dans les sections secondaires est l'utilisation des noms des variables et des constantes comme conteneur de valeur dans ces sections. Jetons un coup d'œil aux variables et aux constantes d'un script de '{opsi-winst}':

[[opsi-winst-var-const]]
== Définition et utilisation de variables et constantes dans un script opsi-winst 

[[opsi-winst-var-const-general]]
=== Général

Dans un script '{opsi-winst}', variables et constantes apparaissent comme "mots", qui sont interprétés par '{opsi-winst}' et "contiennent" des valeurs. "Mots"  sont des séquences de caractères comprenant des lettres, des chiffres et certains caractères spéciaux (en particulier ".", "-", "_", "$", "%"), mais pas des blancs, pas de crochets, parenthèses, ou les signes opérateur ("+") . 

Les variables et constantes '{opsi-winst}' ne sont pas sensibles à la casse.

Il existe les types suivants de variables ou de constantes:

* Constantes texte global, constantes courtes, +
contiennent des valeurs qui sont présents par le programme '{opsi-winst}' et ne peuvent être changé dans un script. Avant d'interpréter le script, '{opsi-winst}' remplace chaque occurrence du nom de constante avec sa valeur dans l'ensemble du script (substitution textuelle). +
Un exemple permettra de clarifier cela: +
La constante `%ScriptPath%` est le nom prédéfini de l'endroit où '{opsi-winst}', trouve et lit le script qu'il exécute. Cet emplacement peut être, par exemple,  `p:\product`. Puis nous devons écrire +
`"%ScriptPath%"` +
dans le script lorsque l'on veut faire obtenir la valeur +
`"p:\product"`. +
** respecter les guillemets qui incluent le délimiteur de la constante.

* Variables de texte ou chaîne, variables courtes, +
ont une apparence très semblable à toutes les variables (chaîne) dans un langage de programmation commune. Ils doivent être déclarés par une déclaration  `DefVar` avant qu'ils puissent être utilisés. Dans les sections primaires, les valeurs peuvent être assignées à des variables (une ou plusieurs fois). Ils peuvent être utilisés comme éléments dans les expressions composées (comme l'addition de chaînes) ou comme arguments de fonction.  +
Mais ils se comportent comme une constante dans une section secondaire, ils apparaissent comme un élément non-syntaxiques étrangers. Leur valeur est fixé et insérée par substitution textuelle pour leurs noms (quand une section est appelée, alors la substitution textuelle pour les constantes réelles a lieu avant de commencer l'exécution de l'ensemble du script).

* Variables de liste de chaînes +
sont renseignés par une déclaration `DefStringList`. Dans les sections primaires peuvent être utilisés à des fins multiples, par exemple collecte des chaînes, manipulation des chaînes, building sections. 

En détail:

[[opsi-winst-global-const]]
=== Constantes Global Text

Les scripts doivent travailler dans un des contextes différents, sans modification manuelle. Les contextes peuvent être caractérisées par des valeurs système comme la version de l'OS ou certains chemins. '{opsi-winst}'  introduit ces valeurs comme des constantes dans le script. 

[[opsi-winst-global-const-usage]]
==== Utilisation

La caractéristique fondamentale d'une constante texte est la manière avec laquelle les valeurs qu'elle représente entrent dans le processus d'interprétation du script:

Le nom de la constante, qui est une simple séquence de caractères, est remplacé par sa valeur fixe, dans le script entier avant commencer l'exécution du script.

Le remplacement ne tient pas compte de tout contexte syntaxique dans lequel le nom éventuellement se produit (exactement comme avec des variables dans les sections secondaires).

[[opsi-winst-global-const-exmple]]
==== Exemple
'{opsi-winst}' met en œuvre des constantes %ScriptPath%  pour l'emplacement du script interprété momentanément et %System% pour le nom du répertoire système de Windows. La sous-section suivante (Fichiers) définit une commande qui copie tous les fichiers du répertoire de script dans le répertoire système de Windows:
[source,winst]
----
[files_do_my_copying]
copy "%ScriptPath%\system\*.*" "%System%" 
----

En ce moment les constantes suivantes sont fournie:

[[opsi-winst-global-const-list]]
[[opsi-winst-global-const-list-system1]]
==== System paths

[[opsi-winst-global-const-list-system-base]]
===== Répertoires du système de base

`%ProgramFilesDir%`:	'c:\program files'

`%ProgramFiles32Dir%`:	'c:\Program Files (x86)'

`%ProgramFiles64Dir%`:	'c:\program files'

`%ProgramFilesSysnativeDir%` :	'c:\program files'

`%Systemroot%` :  	'c:\windows'

`%System%` :  	 	'c:\windows\system32'

`%Systemdrive%` :       	'c:'

`%ProfileDir%` :	        'c:\Documents and Settings'

[[opsi-winst-global-const-list-commondir]]
===== Répertoires communs (AllUsers)

`%AllUsersProfileDir%` ou `%CommonProfileDir%` : 'c:\Documents and Settings\All Users'

`%CommonStartMenuPath%` ou `%CommonStartmenuDir%` : 'c:\Documents and Settings\All Users\Startmenu'

`%CommonAppdataDir%` : 'c:\Documents and Settings\All Users\Application Data'

`%CommonDesktopDir%`

`%CommonStartupDir%`

`%CommonProgramsDir%`

[[opsi-winst-global-const-list-currentuser]]
===== Répertoires utilisateur courant (connecté ou contexte de l'utilisateur)

`%AppdataDir%` ou `%CurrentAppdataDir%` : 'c:\Documents and Settings\%USERNAME%\Application Data'

`%CurrentStartmenuDir%` 

`%CurrentDesktopDir%`

`%CurrentStartupDir%`

`%CurrentProgramsDir%`

`%CurrentSendToDir%`

`%CurrentProfileDir%`  //depuis 4.11.2.1

[[opsi-winst-global-const-list-allntuser]]
===== Répertoire constantes /AllNtUserProfiles

Dans les sections 'Files' qui sont appelés avec l'option `/AllNtUserProfiles` il y a une pseudo variable  +
`%UserProfileDir%` +
Lorsque la section est exécutée pour chaque utilisateur qui existe sur un poste de travail cette variable représente le nom du répertoire du profil de l'utilisateur venons de traiter. 

`%CurrentProfileDir%`  // depuis 4.11.2.1 +
doit être utilisé à la place de `%UserProfileDir%` pour avoir les `Files`-sections utilisable aussi pour 'userLoginScripts'.

[[opsi-winst-global-const-list-winst]]
==== Chemins et répertoires de '{opsi-winst}'

`%opsiScriptHelperPath%` +
Correspond à: `%ProgramFiles32Dir%\opsi.org\opsiScriptHelper` +
Chemin dans lequel le programme d'aide, bibliothèques, et les éléments nécessaires à l'exécution du script pourraient être installée. +
Depuis la version 4.11.3.2

`%ScriptPath%` ou `%ScriptDir%` : représente le chemin du script '{opsi-winst}' actuelle (sans dosseret de fermeture). En utilisant cette variable, nous pouvons construire chemin et les noms de fichier dans les scripts qui sont relatives à l'emplacement du script. Donc, tout peut être copié, appelé de son nouveau lieu, et tous fonctionne comme avant.

`%ScriptDrive%` : Il conduit où le script '{opsi-winst}' exécuté est situé (y compris le côlon).

`%WinstDir%` : L'emplacement de '{opsi-winst}' actuellement exécuté (sans dosseret de fermeture).

`%WinstVersion%` : Version de '{opsi-winst}' en cours d'exécution.

`%Logfile%` : Le nom du fichier de journalisation système utilisé par '{opsi-winst}'.

Exemple: +
Le code:
[source,winst]
----
	comment "Testing: "
	message "Testing constants: "+"%"+"winstversion" +"%"
	set $ConstTest$ = "%WinstVersion%"
	set $InterestingFile$ = "%winstdir%\winst.exe"
	if not (FileExists($InterestingFile$))
		set $InterestingFile$ = "%winstdir%\winst32.exe"
	endif
	set $INST_Resultlist$ = getFileInfoMap($InterestingFile$)
	set $CompValue$ = getValue("file version with dots", $INST_Resultlist$ )
	if ($ConstTest$ = $CompValue$)
		comment "passed"
	else
		set $TestResult$ = "not o.k."
		LogWarning "failed"
	endif
----
	
résultats dans le journal suivante:
[source,winst]
----
comment: Testing: 
message Testing constants: %winstversion%

Set  $ConstTest$ = "4.10.8.3"
  The value of the variable "$ConstTest$" is now: "4.10.8.3"

Set  $InterestingFile$ = "N:\develop\delphi\winst32\trunk\winst.exe"
  The value of the variable "$InterestingFile$" is now: "N:\develop\delphi\winst32\trunk\winst.exe"

If
    Starting query if file exist ...
  FileExists($InterestingFile$)   <<< result true
  not (FileExists($InterestingFile$))   <<< result false
Then
EndIf

Set  $INST_Resultlist$ = getFileInfoMap($InterestingFile$)
    retrieving strings from getFileInfoMap [switch to loglevel 7 for debugging]

Set  $CompValue$ = getValue("file version with dots", $INST_Resultlist$ )
    retrieving strings from $INST_Resultlist$ [switch to loglevel 7 for debugging]
  The value of the variable "$CompValue$" is now: "4.10.8.3"

If
  $ConstTest$ = $CompValue$   <<< result true
  ($ConstTest$ = $CompValue$)   <<< result true
Then
  comment: passed

Else
EndIf
----

[[opsi-winst-global-const-list-network]]
==== Information réseau

`%Host%` :	(Obsolète) La valeur de la variable d'environnement hôte (Traditionnellement, signifiant le nom du serveur OPSI, ne pas confondre avec  %HostID%  signifiant le nom du réseau du client).

`%PCName%`:	La valeur de la variable d'environnement +PCName+, quand existante. Sinon, la valeur de la variable d'environnement +computername+. (Doit être le nom NetBIOS de l'ordinateur) 

`%IPName%` : Le nom DNS de l'ordinateur. Habituellement identique au nom netbios et donc avec `%PCName%` outre que les noms NetBIOS, utilisé en majuscules. 

`%Username%` :	Nom de l'utilisateur connecté.

[[opsi-winst-global-const-list-service]]
==== Les données, pour et à partir, du service opsi

`%HostID%` :	Doit être le nom de domaine entièrement qualifié du client opsi car il est fourni par la ligne de commande ou autrement. 

`%opsiserviceURL%` : L'URL du service opsi (normalement https://).

`%opsiServer%` : Le nom du serveur dérivé de `%opsiserviceURL%`.

`%opsiserviceUser%` : L'ID utilisateur pour lequel il y a une connexion au service opsi.

`%opsiservicePassword%` : Le mot de passe d'utilisateur utilisé pour la connexion au service opsi. Le mot de passe est éliminée lors de la connexion par la fonction de journalisation standard de '{opsi-winst}'.

`%installingProdName%`: 	Le 'productid' du produit qui est réellement installée via l'appel par le service opsi. Vide si le script n'est pas lancé par le service opsi.

`%installingProdVersion%`:	Une chaîne combinées de +<productversion>-<packageversion>+ pour le produit qui est actuellement installée via l'appel par le service opsi. Vide si le script n'est pas lancé par le service opsi.

`%installingProduct%` :	(Obsolète) Le nom (productId) du produit pour lequel le service a appelé le script exécuté. Dans le cas où le script n'est pas exécuté via le service la chaîne est vide.

[[opsi-winst-strvar]]
=== Variables chaîne (ou texte)

[[opsi-winst-strvar-decl]]
==== Déclaration

Les variables chaîne doivent être déclarés avant qu'ils ne puissent être utilisées. La syntaxe de la déclaration est

`DefVar` <nom de la variable>

exemple:
[source,winst]
----
DefVar $MsVersion$
----

Explication:

* Les noms de variables ne sont pas nécessairement commencé ou terminé par un signe dollar, mais cela est recommandé comme une convention pour comprendre leur fonctionnement dans les sections secondaires.

* Les variables ne peuvent être déclaré que dans les sections primaires (Actions section and sub sections, ProfileActions).

* La déclaration ne devrait pas dépendre d'une condition. Ne doit pas être placée dans une branche d'une instruction if – else. Sinon, il pourrait arriver que la déclaration DefVar n'est pas exécuté pour une variable, mais une évaluation de la variable est essayé dans certains clause if (produisant une erreur de syntaxe).
Les variables sont initialisées avec une chaîne vide (""). 

Recommandation:

* La première lettre et la dernière du nom doit être '+$+'

* Définissez toutes les variables au début du script

[[opsi-winst-strvar-set]]
==== Affectation de valeur

Comme il est approprié pour une variable, il peut prendre en une seule valeur la réponse à une série de valeurs alors que le script progresse. Les valeurs sont affectées par des déclarations avec la syntaxe

`Set` <nom de la variable> `=` <Valeur>

<Valeur> désigne toute expression (valeur de chaîne). 

Exemples (Par Exemples voir <<opsi-winst-string>>):

[source,winst]
----
Set $OS$ = GetOS
Set $NTVersion$ = "nicht bestimmt"

if $OS$ = "Windows_NT"
  Set $NTVersion$ = GetNTVersion
endif

DefVar $Home$
Set $Home$ = "n:\home\user name"
DefVar $MailLocation$
Set $MailLocation$ = $Home$ + "\mail"
----

[[opsi-winst-strvar-usage]]
==== Utilisation de variables dans les expressions de chaîne

Dans les sections primaires d'un script '{opsi-winst}', une variable "détient" une valeur. Quand elle est déclaré, est initialisé avec la chaîne vide "".  Lorsqu'une nouvelle valeur est assignée à lui via la commande `set`, il représente cette valeur. 

Dans une section primaire une variable peut remplacer toute expression de chaîne respectivement peut être un élément d'une expression de chaîne, ex. 
[source,winst]
----
Set $MailLocation$ = $Home$ + "\mail"
----

Dans une section primaire le nom de la variable désigne un objet qui représente une chaîne, Si nous ajoutons la variable, nous entendons que la chaîne sous-jacente doit être ajouté en quelque sorte.

Cette chaîne de représentation est contextuel dans une section secondaire. Juste le nom de la variable se trouve maintenant pour la chaîne. 

[[opsi-winst-strvar-in-sections]]
==== Sections secondaire contre primaires

Quand une section secondaire est chargé, et '{opsi-winst}' commence son interprétation, la séquence de caractères d'un nom de variable est directement remplacée par la valeur de la variable.

Exemple: +
Une commande `copy` dans une section fichiers doit copier un fichier dans +
"+n:\home\user name\mail\backup+" +
copiés.

Nous avons mis `$MailLocation$` dans le répertoire au-dessus:
[source,winst]
----
DefVar $Home$
DefVar $MailLocation$
Set $Home$ = "n:\home\user name"
Set $MailLocation$ = $Home$ + "\mail"
----

$MailLocation$ maintenant contient +
"+n:\home\user name\mail+"

Dans une section primaire, nous pouvons désormais exprimer le répertoire +
"+n:\home\user name\mail\backup+" +
avec +
+$MailLocation$ + "\backup"+


Le même répertoire doit être désignée dans une section secondaire: +
`"$MailLocation$\backup"`

Une différence fondamentale entre la pensée de variables dans les sections primaires par rapport au secondaires, c'est que, dans une section primaire, nous pouvons former une expression d'assignation, comme +
`$MailLocation$ = $MailLocation$ + "\backup"`

Comme d'habitude, cela signifie que `$MailLocation$` a tout d'abord une valeur initiale et prend une nouvelle valeur en ajoutant quelques chaîne à la valeur initiale. La référence de la variable est dynamique, et peut avoir des antécédents. 

Dans une section secondaire telle expression ne serait rien (et éventuellement erronée), depuis `$MailLocation$` ne peut être que remplacée par une chaîne de caractères fixes (à toutes les occurrences quasiment au même moment).

[[opsi-winst-lstvar]]
=== Variables liste de chaînes

Les variables pour les listes de chaîne doivent être affecté dans une déclaration DefStringList, par exemple:
[source,winst]
----
DefStringList SMBMounts
----

Une liste de chaîne peut servir par exemple comme conteneur pour la sortie capturé d'un programme shell. Les chaînes collectées peuvent être manipulés dans un grand nombre de façons. Dans le détail ce sera traitée dans la section sur le traitement des listes de chaînes (voir <<opsi-winst-stringlist>>).

CAUTION: Si (imbriquées) les sous-sections seront confiés à des fichiers externes, les sections dites secondaires sont généralement placés dans le fichier, à partir de laquelle ils sont appelés. Selon la complexité de la syntaxe, ils peuvent avoir besoin *supplémentaires* également être logés dans le fichier principal.


[[opsi-winst-prim-section]]
== Syntaxe et signification des sections primaires d'une script opsi-winst 

Comme présenté brièvement dans le chapitre 4 la section Actions d'une script peut être considéré comme une méthode principale du script '{opsi-winst}' et décrit la séquence de traitement global. Il peut appeler des sous-routines - les sous-sections - qui peuvent ensuite appeler récursivement les sous-sections elles-mêmes.

Les sections suivantes expliquent la syntaxe et l'utilisation des sections primaires d'un script '{opsi-winst}'.

[[opsi-winst-prim-section-kinds]]
=== Sections primaires

Il y a trois sortes de sections primaires dans un script

* Une section `Initial` (peut être omise),

* Une section `Action`, 

* n'importe quel nombre de sections `Sub`

* une section `ProfileActions`

Les sections `Initial` et `Action` sont syntaxiquement équivalents (mais Initial doit garder la première place). Par convention,  dans la section Initial sont faits certains paramétrages de l'exécution du script (par exemple le niveau de journalisation). La section Action peut être considéré comme le programme principal dans un scripts '{opsi-winst}'. Il contient la séquence d'actions qui sont contrôlées par le script.

Les sous-sections sont ainsi syntaxiquement équivalents. Mais ils sont appelés depuis la section Action. Ensuite, ils peuvent appeler eux-mêmes des sous-sections `Sub`. 

Une sous-section `Sub` est déterminée par la création d'un nom qui commence par "Sub", par exemple `Sub_InstallBrowser`. En écrivant son nom dans la section Action nous produisons un appel à la sous-section. Le sens de cet appel est défini par le contenu de la section dans le script qui commence par le nom entre crochets, dans l'exemple  `[Sub_InstallBrowser]`

NOTE: Les sous-sections du second ordre et supérieur ne peuvent accueillir des sections internes. Au lieu de cela, leurs appels de procédure doit se référer aux sections définies dans le fichier script principal ou définies comme des sections externes (voir <<opsi-winst-commands-subcall>>).

CAUTION: Si (imbriqués) les sous-sections seront confiés à des fichiers externes, les sections appelées doivent être dans ce fichier d'où ils sont appelés. Selon la complexité du script ils peuvent parfois être placé *aussi* dans le fichier principal.

Une section `ProfileActions` dans un script d'installation typique peut être utilisè comme une sous-section avec une syntaxe spéciale. Dans un 'userLoginScript' cette section sera utilisée comme un script de démarrage (à la place de `Actions`). Voir le chapitre 'User Profile Management' dans le manuel d'opsi et <<opsi-winst-commands-loginscripts>>.


[[opsi-winst-params]]
=== Paramétrage de ospi-winst

Entrées typiques d'une section Initial définissent certains attributs d'exécution de '{opsi-winst}'. L'exemple suivant montre comment les réponses d'erreur peuvent être configuré:

[[opsi-winst-params-example]]
==== Exemple
[source,winst]
----
[Initial]
SetLogLevel=5
ExitOnError=false
ScriptErrorMessages=on
TraceMode=off
----
Cela signifie que: 

* le niveau de journalisation est réglé à 5

* quand une erreur survient winst vais essayer de continuer l'exécution du script

* Si une erreur de syntaxe de script survient, il doit être communiquée (ce sera dans une fenêtre spéciale)

* nous ne voulons pas activer le mode trace pour l'exécution du script (ce qui voudrait dire que nous avons une demande après chaque étape du programme, si nous voulons continuer).

Les valeurs ci-dessus sont les valeurs par défaut, '{opsi-winst}' va les assumer si ces déclarations sont manquants.

Pour les détails de la syntaxe et de la signification: 

[[opsi-winst-params-loglevel]]
==== Spécification du niveau de journalisation

CAUTION: L'ancienne fonction `LogLevel=` est obsolète depuis la version 4.10.3 de '{opsi-winst}'. Pour des raisons de compatibilité descendante Loglevels sera augmenté de 4 avant qu'ils ne soient utilisés.

Il y a deux variantes syntaxiques pour spécifier le niveau de journalisation:

SetLogLevel = <nombre> 
SetLogLevel = <expression de chaîne> 
À savoir le nombre peut être donnée comme une valeur entière ou comme une expression chaîne (voir section 6.3). Dans le second cas, '{opsi-winst}' tente d'évaluer l'expression de chaîne comme un nombre.
Il existe dix niveaux de 0 à 9. 

Il existe deux variantes similaires pour spécifier le niveau de log:

`SetLogLevel =` <nombre> 

`SetLogLevel =` <expression de chaîne>

À savoir le nombre peut être donnée comme une valeur entière ou comme une expression chaîne (voir section 6.3). Dans le second cas, '{opsi-winst}' tente d'évaluer l'expression de chaîne comme un nombre.

Ils existent dix niveaux de 0 à 9. 
****
                0 = rien (absolument rien)
                1 = essentielles ("informations essentielles")
                2 = critiques (des erreurs inattendues qui peuvent entraîner une interruption du programme)
                3 = erreur (Les erreurs qui n'arrêteront pas  l'exécution du programme)
                4 = avertissement (vous devriez jeter un oeil à ce)
                5 = notice (Important statements to the program flow)
                6 = info (Infos supplémentaires)
                7 = débogage (messages de débogage importants)
                8 = débogage2 (beaucoup plus d'informations de débogage et de données)
                9 = confidentielles (mots de passe et autres données de sécurité pertinentes)

****

[[opsi-winst-params-required-winst]]
==== Version requise de opsi-winst

La déclaration 

`requiredWinstVersion`   <symbole relationnel>   <chaîne de valeurs>

par exemple:
[source,winst]
----
requiredWinstVersion >= "4.3"
----

permet à '{opsi-winst}' de vérifier si l'état de la version désirée est donnée. Sinon un message d'erreur windows apparaît. 

Cette fonctionnalité existe depuis la version 4.3 de '{opsi-winst}'. Pour une version antérieure, la déclaration est inconnue, et la déclaration elle-même est un erreur de syntaxe qui sera indiquée par la fenêtre erreur de syntaxe (voir la section suivante). Par conséquent, la déclaration peut être utilisée indépendamment de la version de '{opsi-winst}' actuellement utilisée tant que la version requise est au moins la version 4.3.

[[opsi-winst-params-errors]]
==== Réaction sur ​​les erreurs

Il y a deux sortes d'erreurs qui sont traités de différentes manières:

. déclarations illégales qui ne peuvent pas être interprétées par '{opsi-winst}' (erreurs syntaxiques),

. faute de déclarations qui ne peuvent pas être exécutées à cause de raisons externes objectives (erreurs d'exécution).

En principe, les erreurs syntaxiques sont indiquées dans une fenêtre pop-up pour la correction immédiate, les erreurs d'exécution sont enregistrées dans un fichier journal pour être analysés plus tard.

Le comportement de '{opsi-winst}' quand il reconnaît une erreur de syntaxe est défini par la déclaration de configuration

* `ScriptErrorMessages =` <valeur booléenne> +
Si la valeur est vraie (défaut), les erreurs de syntaxe déclenchent une fenêtre popup avec quelques informations sur l'erreur. Ce genre d'erreurs ne sont pas enregistrées dans le fichier journal. Le fichier journal doit conserver des informations sur l'exécution réelle d'un script de syntaxe correcte. +
La valeur booléenne peut être true (vrai) ou false (faux). Les délimiteurs  `on` ou `off` peuvent être utilisés aussi bien.

*  `FatalOnSyntaxError =` <valeur booléenne> +
** 'true' = (défaut) Si une erreur de syntaxe se produit, l'exécution du script s'arrête et le résultat sera mis à 'failed'. En outre, le message 'Syntax Error' sera transmis au serveur opsi.
** 'false' = Si une erreur de syntaxe se produit, l'exécution du script +ne sera pas+ arrêté et le résultat sera mis à 'success'.

Dans les deux cas ci-dessus, l'erreur de syntaxe sera enregistré comme 'Critical'. +
Dans les deux cas ci-dessus, le compteur d'erreurs sera augmenté de 1. +
Depuis 4.11.3.2 +
Dans les anciennes versions il n'y avait pas la journalisation des erreurs de syntaxe, aucune augmentation de compteur d'erreur, et le résultat était toujours mis à 'success'.

Il y a deux options de configuration pour des erreurs d'exécution.

* `ExitOnError =` <valeur booléenne> +
Cette déclaration définit si l'exécution du script prend fin quand une erreur survient. Si la valeur est `true` ou `yes` le programme va arrêter l'exécution, sinon les erreurs sont simplement enregistré (défaut).

* `TraceMode =` <valeur booléenne> +
En TraceMode (défaut `false`) chaque entrée du journal systeme sera en plus affiché dans la fenêtre de message, avec un bouton OK.

[[opsi-winst-params-stayontop]]
==== Rester au-dessus 

*  `StayOnTop =` <valeur booléenne>

Avec StayOnTop = true (ou = on) nous demandons que - en mode batch - la fenêtre de '{opsi-winst}' soit sur ​​le dessus des fenêtres qui se partagent l'écran. Cela signifie qu'il devrait être visible dans le "premier plan" tant qu'aucune autre fenêtre aie le même statut. 
 
CAUTION: Selon le manuel du système la valeur ne peut pas être modifié pendant l'exécution du programme.  Mais il semble que nous pouvons donner une nouvelle valeur pour une fois. 

`StayOnTop` il est à `false` par défaut afin d'éviter que certains autres processus génère un message d'erreur qui peut éventuellement ne pas être vu si '{opsi-winst}' reste au-dessus.

[[opsi-winst-params-showmode]]
=== Montrer le mode fenêtre
Pour changer la façon dont la fenêtre '{opsi-winst}' est affichée, utilisez ces commandes:


* `NormalizeWinst` +
définit la fenêtre '{opsi-winst}' au mode 'normal'

* `IconizeWinst` +
définit la fenêtre '{opsi-winst}' au mode 'minimisé'

* `RestoreWinst` +
définit la fenêtre '{opsi-winst}' au mode 'maximisé'

[[opsi-winst-string]]
=== Expressions de chaîne, Valeurs de chaîne, et Fonctions de chaîne

Une expression de chaîne peut être

* une valeur de chaîne élémentaires
* une valeur de chaîne imbriquées
* une variable chaîne
* la concaténation d'autres expressions de type chaîne
* un appel de fonction d'une valeur de chaîne

[[opsi-winst-string-elementary]]
==== Valeur de chaîne élémentaires
Une valeur de chaîne élémentaires est une séquence de caractères qui est enfermé dans des guillemets double ou simple, formellement:

'"<séquence de caractères>"'

ou

''<séquence de caractères>''

Exemple:
[source,winst]
----
DefVar $ExampleString$
Set $ExampleString$ = "mon texte"
----

[[opsi-winst-string-nested]]
==== Chaînes dans des chaînes (valeur de chaîne imbriquées)

Si la séquence de caractères contient elle-même des guillemets, nous devons utiliser les autres types de guillemets pour l'entourer:
[source,winst]
----
DefVar $citation$
Set $citation$ = 'il a dit "Oui"'
----

Si la séquence de caractères contient les deux types de guillemets, nous devons utiliser l'expression spéciale suivante: +
`EscapeString:` <séquence de caractères> +
Par exemple nous pouvons écrire: +
[source,winst]
----
DefVar $Meta_citation$
Set $Meta_citation$ = EscapeString: Set $citation$ = 'il a dit "Oui"'
----
Alors la variable `$Meta_citation$` va exactement contenir la séquence complète de caractères qui suit la colonne après "EscapeString" (y compris le vide). `$Meta_citation$` contiendra la déclaration complète: +Set $citation$ = `'il a dit "Oui"'`+ 

[[opsi-winst-string-concat]]
==== Concaténation de chaînes 

Une concaténation de chaîne est écrite en utilisant le signe plus ("+") 

<expression de chaîne> `+` <expression de chaîne>

Exemple:
[source,winst]
----
DefVar $String1$
DefVar $String2$
DefVar $String3$
DefVar $String4$
Set $String1$ = "mon texte"
Set $String2$ = "et"
Set $String3$ = "ton texte"
Set $String4$ =  $String1$ + " " + $String2$ + " " + $String3$
----

$String4$ a alors la valeur "mon texte et ton texte".

[[opsi-winst-string-expressions]]
==== Variables chaîne

Une variables chaîne dans une section primaire "contient" une valeur de chaîne. Dans une expression de chaîne, il peut toujours remplacer une chaîne élémentaire. Pour savoir comment définir et configurer les variables de chaîne voir <<opsi-winst-strvar>>.

Les sections suivantes présentent une variété de fonctions de chaînes. 

[[opsi-winst-string-functions-os]]
==== Fonctions de chaîne qui renvoient le type de système d'exploitation

* `GetOS` +
La fonction indique le type de système d'exploitation en marche. +
Nous recommendon l'utilisation de `GetMsVersionInfo`. +
`GetOs` retourne l'une des valeurs suivantes: +
"Windows_16" +
"Windows_95" (y compris Windows 98 et ME) +
"Windows_NT" (y compris Windows 2000 et XP) +
"Linux"


* GetNtVersion +
Obsolete - utilisez `GetMsVersionInfo`. +
Un système d'exploitation Windows NT est caractérisé par un numéro de type et de sous-type Windows. GetNtVersion  retourne le nom de sous-type précis. Les valeurs possibles sont +
"NT3" +
"NT4" +
"Win2k" (Windows 5.0) +
"WinXP" (Windows 5.1) +
"Windows Vista" (Windows 6) +
Si le système d'exploitation NT est plus que la version 6 ou il y a une version pas explicitement connue, la fonction retourne "Win NT" et le numéro de version complet (5.2, ... , 6.0 ..) . Par exemple pour Windows Server 2003 R2 Enterprise Edition, nous obtenons +
"Win NT 5.2" +
Si le système d'exploitation n'est pas Windows NT la fonction retourne la valeur d'erreur +
"No OS of Windows NT type"

* GetMsVersionInfo +
pour les systèmes de type Windows NT renvoie les informations de version de Microsoft comme indiqué par l'API, par exemple un ordinateur Windows XP produit le résultat + 
"5.1"

.Versions de Windows
[options="header"]
|=======================
|GetMsVersionInfo|Versions de Windows
|5.0    |Windows 2000
|5.1    |Windows XP (Home, Prof)
|5.2    |XP 64 Bit, 2003, Home Server, 2003 R2
|6.0    |Vista, 2008
|6.1    |Windows 7, 2008 R2
|=======================
voir aussi `GetMsVersionMap`

*  `GetSystemType` +
vérifie l'installation de Windows OS, si on peut supposer que le système est de 64 bits. Dans ce cas, la valeur est '64 Bit System' autrement 'x86 System'.

[[opsi-winst-string-functions-env]]
==== Fonctions de chaîne pour la récupération de l'environnement ou de données en ligne de commande

La fonction lit et retourne la valeur momentanée d'une variable d'environnement système. 

Par exemple, nous pouvons récupérer l'utilisateur qui est connecté avec EnvVar ("Username").
ParamStr
La fonction passe la chaîne de paramètres de la ligne de commande de winst à savoir le paramètre de ligne de commande qui est indiqué par /parameter. S'il n'y a pas de paramètre  ParamStr renvoie la chaîne vide.
GetLastExitCode
retourne le code de sortie (aussi appelé ErroLevel) du dernièr appel WinBatch.
GetUserSID(<nom d'utilisateur Windows>)
retourne le SID pour un utilisateur donné (éventuellement avec le préfixe de domaine sous la forme 
DOMAINE\UTILISATEUR).

*  `EnvVar (` <string>`)` +
La fonction lit et retourne la valeur momentanée d'une variable d'environnement système. Par exemple, nous pouvons récupérer l'utilisateur qui est connecté avec `EnvVar ("Username")`.

*  `ParamStr` +
La fonction passe la chaîne de paramètres de la ligne de commande de '{opsi-winst}' à savoir le paramètre de ligne de commande qui est indiqué par /parameter. S'il n'y a pas de paramètre  ParamStr renvoie la chaîne vide.

*  `GetLastExitCode` +
retourne le code de sortie (aussi appelé ErroLevel) du dernièr appel WinBatch.

*  `GetUserSID(`<Windows Username>`)` +
retourne le SID pour un utilisateur donné (éventuellement avec le préfixe de domaine sous la forme 
DOMAINE\UTILISATEUR).

* `GetUsercontext` +
renvoie la chaîne qui a été donné à '{opsi-winst}' par le paramètre optionnel `/usercontext`. Si ce paramètre n'a pas été utilisé la chaîne retournée est vide.

[[opsi-winst-string-functions-reg]]
==== Lire des valeurs du registre Windows et transformer les valeurs en format Registre

*  `GetRegistryStringValue (`<chaîne>`)` +
essaie d'interpréter la valeur chaîne passée comme une expression de format +
'[KEY] X' +
Ensuite, la fonction tente d'ouvrir la clé de registre `KEY`, et, au cas où elle réussit, à lire et retourner la valeur de chaîne qui appartient au nom de la variable de registre `X` . 

Exemple
[source,winst]
----
GetRegistryStringValue ("[HKEY_LOCAL_MACHINE\SOFTWARE\Microsoft\Windows NT\CurrentVersion\Winlogon] Shell")
----

généralement donne  "Explorer.exe", la valeur par défaut du programme shell de Windows.

S'il n'y a pas de clé de registre `KEY` ou la variable `X` n'existe pas la fonction produit un message d'avertissement dans le fichier journal et retourne la chaîne vide.

Par exemple:
Si nous avons fait une 'standard entry' avec la valeur +standard entry+ à la clé +HKEY_LOCAL_MACHINE\SOFTWARE\opsi.org\opsi-script-test\test-4.0+, nous l'obtiendrons avec
[source,winst]
----
Set  $CompValue$ = GetRegistryStringValue32 ("[HKEY_LOCAL_MACHINE\SOFTWARE\opsi.org\opsi-script-test\test-4.0]")
----

le journal système suivant:
[source,winst]
----
Registry started with redirection (32 Bit)
Registry key [HKEY_LOCAL_MACHINE\SOFTWARE\opsi.org\opsi-script-test\test-4.0]  opened
Key closed
The value of the variable "$CompValue$" is now: "standard entry"
----


*  `GetRegistryStringValue32(`<chaîne>`)` ->	voir <<opsi-winst-64bit,Chapter 64 Bit>>

*  `GetRegistryStringValue64(`<chaîne>`)` ->	voir <<opsi-winst-64bit,Chapter 64 Bit>>

*  `GetRegistryStringValueSysNative(`<chaîne>`)` ->	voir <<opsi-winst-64bit,Chapter 64 Bit>>


*  `RegString(`<chaîne>`)` +
est utile pour transformer les noms de chemin dans le format qui est utilisé dans le Registre Windows. La barre oblique inverse est dupliqué. Par exemple, +
[source,winst]
----
RegString ("c:\windows\system\") 
----
donne +
'"c:\\windows\\system\\"'

[[opsi-winst-string-functions-ini]]
==== Lecture des valeurs de propriété à partir des fichiers ini

Pour des raisons historiques, Il y a trois fonctions pour la lecture des valeurs des fichiers de configuration qui ont le format de fichier ini. Depuis opsi 3.0 les propriétés de produits spécifiques sont récupérées à partir du démon de configuration de OPSI (qui peut les récupérer à partir d'un fichier de configuration ou de tout autre back-end conteneur de données).

En détail: +
Format de fichier Ini signifie que le fichier est un fichier texte et est composé de "sections" chacune contenant des paires de valeurs clés:
[source,winst]
----
[section1]
Varname1=Valeur1
Varname2=Valeur2
...
[section2]
...
----

La fonction la plus générale lit la valeur appartenant à une certaine clé dans une certaine section de certaines fichier INI. Tout paramètre peut être donnée comme une expression chaîne arbitraire:

*  `GetValueFromInifile (`<FICHIER>, <SECTION>, <CLE>, <VALEUR PAR DÉFAUT>`)` +
La fonction tente d'ouvrir le fichier ini `FICHIER`, récupérer la `SECTION` demandée et recherche la valeur spécifiée appartenant à la `CLEF` que de la fonction retournera. Si aucune de ces opérations échouent `VALEUR PAR DEFAUT` est retourné.

La deuxième fonction emprunte sa syntaxe du format de fichier INI même, et peut parfois être plus facile à utiliser. Mais depuis cette syntaxe compliquée tourne dans des circonstances plus général, elle est obsolète. La syntaxe lit:

*  `GetIni (` <expression de chaîne> [ <séquence de caractères> ] <séquence de caractères> `)` +
(Obsolète) L'<expression de chaîne> est interprété comme nom de fichier, la première <séquence de caractères> comme nom de la section, la seconde comme nom de clé.  

[[opsi-winst-string-functions-prodprop]]
==== Lecture des Propriétés du produit

* `GetProductProperty (` <Nom de la propriété>, <Valeur par défaut>`)` +
quand $PropertyName$ et $DefaultValue$ sont des expressions de chaîne. 
Si '{opsi-winst}' est connecté au service de configuration OPSI la propriété produit est récupéré du service. 
Si '{opsi-winst}' n'est pas connecté au service ou pour d'autres raisons, l'appel échoue, le donné +<Valeur par défaut>+ sera retourné.

Les propriétés du produit peuvent être utilisé pour configurer des variantes de l'installation.

Par exemple l'installation OPSI du viewer réseau UltraVNC peut être configuré en utilisant les options 

* viewer = <yes> | <no>

* policy = <factory_default> | 

Les branches de script d'installation, selon les valeurs choisies pour ces options, peuvent être récupérées par 
[source,winst]
----
GetProductProperty("viewer", "yes")
GetProductProperty("policy", "factory_default")
----


*  `IniVar(`<Nom de la propriété>`)` +
(obsolète: use GetProductProperty)

[[opsi-winst-string-functions-hosts]]
==== Récupération de données à partir de etc/hosts

*  `GetHostsName(`<chaîne>`)` +
retourne le nom d'hôte pour une adresse IP donnée car elle est déclarée dans le fichier hosts local. Si le système d'exploitation est "Windows_NT" (en fonction de la variable d'environnement de l'OS)  "%systemroot%\system32\drivers\etc\"  est supposé l'emplacement du fichier hôte, autrement  "C:\Windows\".

*  `GetHostsAddr(`<chaîne>`)` +
indique l'adresse IP à un hôte donné ou à un nom d'alias.

[[opsi-winst-string-functions-handling]]
==== Traitement des chaîne

*  `ExtractFilePath(`<chaîne>`)` +
interprète la valeur chaîne passée comme nom de fichier ou chemin et retourne la partie chemin (la chaîne jusqu'à la dernière "\", y compris).

*  `StringSplit (`VALEUR CHAÎNE1, VALEUR CHAÎNE2, INDEX`)` +
(obsolète: utilisez `splitString` / `takestring`)

*  `takeString(`<index>,<liste>`)` +
revient d'une liste de chaînes <liste> la chaîne avec l'indice <index>. +
Souvent utilisé en combinaison avec `splitstring`:
`takeString(`<index>, `splitString(`<chaîne1>, <chaîne2>`)` +
(voir aussi <<opsi-winst-stringlist>>). +
Le résultat est produit en coupant <chaîne1> où chaque tranche est délimité par une occurrence de <chaîne2>, puis en prenant la tranche avec l'index <index> (où le décompte commence avec 0).

Exemple:
[source,winst]
----
takeString(3, splitString ("\\server\share\directory",  "\"))
----

retourne '"share"', +
la chaîne donnée est découpé au "\" et retourne la liste de chaînes: +
Index 0 - "" (chaîne vide), car il n'y a rien avant le premier "\" +
Index 1 - "" (chaîne vide), car il n'y a rien avant le deuxième "\" +
Index 2 - "server" +
Index 3 - "share" +
Index 4 - "directory"

`takestring` compte vers le bas, si l'indice est négatif, à commencer par le nombre d'éléments. Par conséquent,
[source,winst]
----
takestring(-1, $list1$)
----

désigne le dernier élément de la liste de chaîne $list1$.

* `SubstringBefore(`<chaîne1>, <chaîne2>`)` +
(obsolète: utilisez `splitString` / `takestring`)
donne la séquence de caractères de chaîne1 jusqu'au début de la chaîne2. +
Exemple:
[source,winst]
----
SubstringBefore ("C:\programme\staroffice\program\soffice.exe", "\program\soffice.exe")
----
retourne '"C:\programme\staroffice"'.

* `takeFirstStringContaining(`<liste>,<chaîne de recherche>`)` +
retourne la première chaîne de <liste> qui contient <chaîne de recherche>. +
Retourne une chaîne vide si aucune chaîne correspondante est trouvé.

* `Trim(`<chaîne>`)` +
coupe les blancs entourant <chaîne>.

* `lower(`<chaîne>`)` +
retourne une <chaîne> avec des lettres minuscules.

* `contains(`<chaîne>, <sous-chaîne>`)` +
Une fonction booléenne qui retourne 'true' si <chaîne> contient <sous-chaîne>. Cette fonction est sensible à la casse. +
Disponible depuis 4.11.3 +
Exemple:
[source,winst]
----
set $ConstTest$ = "1xy451Xy451XY45"
set $CompValue$ ="xy"
if contains($ConstTest$, $CompValue$)
	comment "passed"
else
	set $TestResult$ = "not o.k."
	LogWarning "failed"
endif
set $CompValue$ ="xY"
if not(contains($ConstTest$, $CompValue$))
	comment "passed"
else
	set $TestResult$ = "not o.k."
	LogWarning "failed"
endif
----

* `stringReplace(`<chaîne>, <ancien-modèle>, <nouveau-modèle>`)` +
retourne une chaîne, qui présente toutes les occurrences de <ancien-modèle> remplacés par <nouveau-modèle> compte tenu de la chaîne d'entrée <chaîne>. +
Disponible depuis 4.11.3 +
Exemple:
[source,winst]
----
set $ConstTest$ = "123451234512345"
set $CompValue$ = stringReplace("1xy451Xy451XY45","xy","23")
if ($ConstTest$ = $CompValue$)
	comment "passed"
else
	set $TestResult$ = "not o.k."
	LogWarning "failed"
endif
----

* `strLength(`<chaîne>`)` +
Retourne le nombre de caractères dans <chaîne> +
Disponible depuis 4.11.3 +
Exemple:
[source,winst]
----
set $tmp$ = "123456789"
set $ConstTest$ = "9"
set $CompValue$ = strLength($tmp$)
if $ConstTest$ = $CompValue$
	comment "passed"
else
	set $TestResult$ = "not o.k."
	LogWarning "failed"
endif
set $tmp$ = ""
set $ConstTest$ = "0"
set $CompValue$ = strLength($tmp$)
if $ConstTest$ = $CompValue$
	comment "passed"
else
	set $TestResult$ = "not o.k."
	LogWarning "failed"
endif
----

* `strPos(`<chaîne>, <sous-chaîne>`)` +
Retourne la position de la première <sous-chaîne> dans <chaîne>. Si <sous-chaîne> n'est pas trouvé, la valeur de retour est "0". Cette fonction est sensible à la casse. +
Disponible depuis 4.11.3 +
Exemple:
[source,winst]
----
set $tmp$ = "1xY451Xy451xy45"
set $ConstTest$ = "7"
set $CompValue$ = strPos($tmp$,"Xy")
if $ConstTest$ = $CompValue$
	comment "passed"
else
	set $TestResult$ = "not o.k."
	LogWarning "failed"
endif
set $tmp$ = lower("1xY451Xy451xy45")
set $ConstTest$ = "2"
set $CompValue$ = strPos($tmp$,lower("xy"))
if $ConstTest$ = $CompValue$
	comment "passed"
else
	set $TestResult$ = "not o.k."
	LogWarning "failed"
endif
----

* `strPart(`<chaîne>, <position-de-départ>, <nombre-de-caractères>`)` +
retourne la partie de <chaîne> à partir de <position-de-départ> et qui incluent les suivants <nombre-de-caractères> caractères. Si il y a moins de <nombre-de-caractères> après <position-de-départ>, alors la chaîne retournée sera le reste des caractères après <position-de-départ>. +
Le comptage de caractères commence par 1. +
Disponible depuis 4.11.3 +
Exemple:
[source,winst]
----
set $tmp$ = "123456789"
set $ConstTest$ = "34"
set $CompValue$ = strPart($tmp$,"3","2")
if $ConstTest$ = $CompValue$
	comment "passed"
else
	set $TestResult$ = "not o.k."
	LogWarning "failed"
endif
set $tmp$ = "123456789"
set $ConstTest$ = "56789"
set $CompValue$ = strPart($tmp$, strPos($tmp$,"56"),strLength($tmp$))
if $ConstTest$ = $CompValue$
	comment "passed"
else
	set $TestResult$ = "not o.k."
	LogWarning "failed"
endif
----

* `unquote(`<chaîne>,<caractère-de-cote>`)` +
retourne la version non cotées de <chaîne>, si <chaîne> est cotée avec <caractère-de-cote> +
De <caractère-de-cote> seulement le premier caractèr est utilisé et les premiers espaces sont ignorés.
Disponible depuis 4.11.2.1
[source,winst]
----
set $ConstTest$ = "b"
set $CompValue$ = unquote("'b'", "'")
comment "compare values"
if ($ConstTest$ = $CompValue$)
	comment "passed"
else
	set $TestResult$ = "not o.k."
	LogWarning "failed"
endif
comment "double quote"
set $ConstTest$ = "b"
set $CompValue$ = unquote('"b"', '"')
comment "compare values"
if ($ConstTest$ = $CompValue$)
	comment "passed"
else
	set $TestResult$ = "not o.k."
	LogWarning "failed"
endif
comment "quote string will be trimmed and then only the first char is used"
comment "note: brackets are different chars"
set $ConstTest$ = "b]"
set $CompValue$ = unquote("[b]", " [{ ")
comment "compare values"
if ($ConstTest$ = $CompValue$)
	comment "passed"
else
	set $TestResult$ = "not o.k."
	LogWarning "failed"
endif
comment "not usable to remove brackets"
set $ConstTest$ = "b]"
set $CompValue$ = unquote("[b]", "[")
set $CompValue$ = unquote($CompValue$,"]")
set $CompValue$ = unquote("[b]", "]")
set $CompValue$ = unquote($CompValue$,"[")
set $CompValue$ = unquote(unquote("[b]", "["),"]")
comment "compare values"
if ($ConstTest$ = $CompValue$)
	comment "passed"
else
	set $TestResult$ = "not o.k."
	LogWarning "failed"
endif
comment "if string not quoted it will be come back without changes"
set $ConstTest$ = "b"
set $CompValue$ = unquote("b", "'")
comment "compare values"
if ($ConstTest$ = $CompValue$)
	comment "passed"
else
	set $TestResult$ = "not o.k."
	LogWarning "failed"
endif
----

* `HexStrToDecStr(`<chaîne>`)` +
Renvoie la représentation décimale de la chaîne d'entrée si cela a été la représentation hexadécimale d'un entier. Les caractères en tête comme '0x' ou '$' seront ignorés. En cas d'erreur de conversion, la fonction retourne une chaîne vide.

* `DecStrToHexStr(`<chaîne>`)`+
Renvoie la représentation hexadécimale de la chaîne d'entrée si cela a été la représentation décimale d'un entier. En cas d'erreur de conversion, la fonction retourne.

* `base64EncodeStr(`<chaîne>`)` +
renvoie la valeur codée en base64 de <chaîne>.

* `base64DecodeStr(`<chaîne>`)` +
renvoie la valeur décodées en base64 de <chaîne>.

[[opsi-winst-string-functions-others]]
==== Autres fonctions de chaîne

* `RandomStr` + 
renvoie une chaîne aléatoire de longueur 10, où les lettres en majuscule, les lettres minuscules et les chiffres sont mélangés (pour créer des mots de passe). Plus exactement: 2 caractères minuscules, 2 caractères majuscules, 2 caractères spéciaux et 4 chiffres. Les caractères possibles spéciales sont: +
'!','$','(',')','*','+','/',';','=','?','[',']','{','}','ß','~','§','°'

* `CompareDotSeparatedNumbers(`<chaîne1>, <chaîne2>`)` +
compare deux chaînes de la forme <nombre>.<nombre>[.<nombre>[.<nombre>]] +
Il retourne "0" si les chaînes sont égales, "1" si <chaîne1> est plus grande et "-1" si <chaîne1> est inférieur à <chaîne2>.

Exemple: +
Le code:
[source,winst]
----
	comment "Testing: "
	message "CompareDotSeparatedNumbers"
	set $string1$ = "1.2.3.4.5"
	set $string2$ = "1.2.3.4.5"
	set $ConstTest$ = "0"
	set $CompValue$ = CompareDotSeparatedNumbers($string1$, $string2$)
	if ($ConstTest$ = $CompValue$)
		comment "passed"
		comment $string1$+" is equal to "+$string2$
	else
		set $TestResult$ = "not o.k."
		LogWarning "failed"
	endif
	
	set $string1$ = "1.2.31.4.5"
	set $string2$ = "1.2.13.4.5"
	set $ConstTest$ = "1"
	set $CompValue$ = CompareDotSeparatedNumbers($string1$, $string2$)
	if ($ConstTest$ = $CompValue$)
		comment "passed"
		comment $string1$+" is higher then "+$string2$
	else
		set $TestResult$ = "not o.k."
		LogWarning "failed"
	endif

	set $string1$ = "1.2.3.4.5"
	set $string2$ = "1.2.13.4.5"
	set $ConstTest$ = "-1"
	set $CompValue$ = CompareDotSeparatedNumbers($string1$, $string2$)
	if ($ConstTest$ = $CompValue$)
		comment "passed"
		comment $string1$+" is lower then "+$string2$
	else
		set $TestResult$ = "not o.k."
		LogWarning "failed"
	endif

	comment ""
	comment "-------------------------------------"
	comment "Testing: "
	message "CompareDotSeparatedStrings"
	set $string1$ = "1.a.b.c.3"
	set $string2$ = "1.a.b.c.3"
	set $ConstTest$ = "0"
	set $CompValue$ = CompareDotSeparatedStrings($string1$, $string2$)
	if ($ConstTest$ = $CompValue$)
		comment "passed"
		comment $string1$+" is equal to "+$string2$
	else
		set $TestResult$ = "not o.k."
		LogWarning "failed"
	endif
----

entraîne le journal système suivant:
[source,winst]
----
comment: Testing: 
message CompareDotSeparatedNumbers

Set  $string1$ = "1.2.3.4.5"
  The value of the variable "$string1$" is now: "1.2.3.4.5"

Set  $string2$ = "1.2.3.4.5"
  The value of the variable "$string2$" is now: "1.2.3.4.5"

Set  $ConstTest$ = "0"
  The value of the variable "$ConstTest$" is now: "0"

Set  $CompValue$ = CompareDotSeparatedNumbers($string1$, $string2$)
  The value of the variable "$CompValue$" is now: "0"

If
  $ConstTest$ = $CompValue$   <<< result true
  ($ConstTest$ = $CompValue$)   <<< result true
Then
  comment: passed
  comment: 1.2.3.4.5 is equal to 1.2.3.4.5

Else
EndIf

Set  $string1$ = "1.2.31.4.5"
  The value of the variable "$string1$" is now: "1.2.31.4.5"

Set  $string2$ = "1.2.13.4.5"
  The value of the variable "$string2$" is now: "1.2.13.4.5"

Set  $ConstTest$ = "1"
  The value of the variable "$ConstTest$" is now: "1"

Set  $CompValue$ = CompareDotSeparatedNumbers($string1$, $string2$)
  The value of the variable "$CompValue$" is now: "1"

If
  $ConstTest$ = $CompValue$   <<< result true
  ($ConstTest$ = $CompValue$)   <<< result true
Then
  comment: passed
  comment: 1.2.31.4.5 is higher then 1.2.13.4.5

Else
EndIf

Set  $string1$ = "1.2.3.4.5"
  The value of the variable "$string1$" is now: "1.2.3.4.5"

Set  $string2$ = "1.2.13.4.5"
  The value of the variable "$string2$" is now: "1.2.13.4.5"

Set  $ConstTest$ = "-1"
  The value of the variable "$ConstTest$" is now: "-1"

Set  $CompValue$ = CompareDotSeparatedNumbers($string1$, $string2$)
  The value of the variable "$CompValue$" is now: "-1"

If
  $ConstTest$ = $CompValue$   <<< result true
  ($ConstTest$ = $CompValue$)   <<< result true
Then
  comment: passed
  comment: 1.2.3.4.5 is lower then 1.2.13.4.5

Else
EndIf
----

*  `CompareDotSeparatedStrings (`<chaîne1>, <chaîne2>`)` +
compare deux chaînes de la forme <chaîne>.<chaîne>[.<chaîne>[.<chaîne>]] +
Il retourne "0" si les chaînes sont égales, "1" si <chaîne1> est plus grande et "-1" si <chaîne1> est inférieure à <chaîne2>. La fonction n'est pas sensible à la casse.

Exemple: +
Le code:
[source,winst]
----
	comment "Testing: "
	message "CompareDotSeparatedStrings"
	set $string1$ = "1.a.b.c.3"
	set $string2$ = "1.a.b.c.3"
	set $ConstTest$ = "0"
	set $CompValue$ = CompareDotSeparatedStrings($string1$, $string2$)
	if ($ConstTest$ = $CompValue$)
		comment "passed"
		comment $string1$+" is equal to "+$string2$
	else
		set $TestResult$ = "not o.k."
		LogWarning "failed"
	endif

	set $string1$ = "1.a.b.c.3"
	set $string2$ = "1.A.B.C.3"
	set $ConstTest$ = "0"
	set $CompValue$ = CompareDotSeparatedStrings($string1$, $string2$)
	if ($ConstTest$ = $CompValue$)
		comment "passed"
		comment $string1$+" is equal to "+$string2$
	else
		set $TestResult$ = "not o.k."
		LogWarning "failed"
	endif

	set $string1$ = "1.a.cb.c.3"
	set $string2$ = "1.a.b.c.3"
	set $ConstTest$ = "1"
	set $CompValue$ = CompareDotSeparatedStrings($string1$, $string2$)
	if ($ConstTest$ = $CompValue$)
		comment "passed"
		comment $string1$+" is higher then "+$string2$
	else
		set $TestResult$ = "not o.k."
		LogWarning "failed"
	endif

	set $string1$ = "1.a.ab.c.3"
	set $string2$ = "1.a.b.c.3"
	set $ConstTest$ = "-1"
	set $CompValue$ = CompareDotSeparatedStrings($string1$, $string2$)
	if ($ConstTest$ = $CompValue$)
		comment "passed"
		comment $string1$+" is lower then "+$string2$
	else
		set $TestResult$ = "not o.k."
		LogWarning "failed"
	endif
	
	set $string1$ = "1.2.13.4.5"
	set $string2$ = "1.2.3.4.5"
	set $ConstTest$ = "-1"
	set $CompValue$ = CompareDotSeparatedStrings($string1$, $string2$)
	if ($ConstTest$ = $CompValue$)
		comment "passed"
		comment $string1$+" is lower then "+$string2$
		comment "using CompareDotSeparatedStrings give wrong results on numbers"
	else
		set $TestResult$ = "not o.k."
		LogWarning "failed"
	endif

	set $string1$ = "1.2.3.4.5"
	set $string2$ = "1.2.13.4.5"
	set $ConstTest$ = "1"
	set $CompValue$ = CompareDotSeparatedStrings($string1$, $string2$)
	if ($ConstTest$ = $CompValue$)
		comment "passed"
		comment $string1$+" is higher then "+$string2$
		comment "using CompareDotSeparatedStrings give wrong results on numbers"
	else
		set $TestResult$ = "not o.k."
		LogWarning "failed"
	endif
----

entraîne le journal système suivant:
[source,winst]
----
comment: Testing: 
message CompareDotSeparatedStrings

Set  $string1$ = "1.a.b.c.3"
  The value of the variable "$string1$" is now: "1.a.b.c.3"

Set  $string2$ = "1.a.b.c.3"
  The value of the variable "$string2$" is now: "1.a.b.c.3"

Set  $ConstTest$ = "0"
  The value of the variable "$ConstTest$" is now: "0"

Set  $CompValue$ = CompareDotSeparatedStrings($string1$, $string2$)
  The value of the variable "$CompValue$" is now: "0"

If
  $ConstTest$ = $CompValue$   <<< result true
  ($ConstTest$ = $CompValue$)   <<< result true
Then
  comment: passed
  comment: 1.a.b.c.3 is equal to 1.a.b.c.3

Else
EndIf

Set  $string1$ = "1.a.b.c.3"
  The value of the variable "$string1$" is now: "1.a.b.c.3"

Set  $string2$ = "1.A.B.C.3"
  The value of the variable "$string2$" is now: "1.A.B.C.3"

Set  $ConstTest$ = "0"
  The value of the variable "$ConstTest$" is now: "0"

Set  $CompValue$ = CompareDotSeparatedStrings($string1$, $string2$)
  The value of the variable "$CompValue$" is now: "0"

If
  $ConstTest$ = $CompValue$   <<< result true
  ($ConstTest$ = $CompValue$)   <<< result true
Then
  comment: passed
  comment: 1.a.b.c.3 is equal to 1.A.B.C.3

Else
EndIf

Set  $string1$ = "1.a.cb.c.3"
  The value of the variable "$string1$" is now: "1.a.cb.c.3"

Set  $string2$ = "1.a.b.c.3"
  The value of the variable "$string2$" is now: "1.a.b.c.3"

Set  $ConstTest$ = "1"
  The value of the variable "$ConstTest$" is now: "1"

Set  $CompValue$ = CompareDotSeparatedStrings($string1$, $string2$)
  The value of the variable "$CompValue$" is now: "1"

If
  $ConstTest$ = $CompValue$   <<< result true
  ($ConstTest$ = $CompValue$)   <<< result true
Then
  comment: passed
  comment: 1.a.cb.c.3 is higher then 1.a.b.c.3

Else
EndIf

Set  $string1$ = "1.a.ab.c.3"
  The value of the variable "$string1$" is now: "1.a.ab.c.3"

Set  $string2$ = "1.a.b.c.3"
  The value of the variable "$string2$" is now: "1.a.b.c.3"

Set  $ConstTest$ = "-1"
  The value of the variable "$ConstTest$" is now: "-1"

Set  $CompValue$ = CompareDotSeparatedStrings($string1$, $string2$)
  The value of the variable "$CompValue$" is now: "-1"

If
  $ConstTest$ = $CompValue$   <<< result true
  ($ConstTest$ = $CompValue$)   <<< result true
Then
  comment: passed
  comment: 1.a.ab.c.3 is lower then 1.a.b.c.3

Else
EndIf

Set  $string1$ = "1.2.13.4.5"
  The value of the variable "$string1$" is now: "1.2.13.4.5"

Set  $string2$ = "1.2.3.4.5"
  The value of the variable "$string2$" is now: "1.2.3.4.5"

Set  $ConstTest$ = "-1"
  The value of the variable "$ConstTest$" is now: "-1"

Set  $CompValue$ = CompareDotSeparatedStrings($string1$, $string2$)
  The value of the variable "$CompValue$" is now: "-1"

If
  $ConstTest$ = $CompValue$   <<< result true
  ($ConstTest$ = $CompValue$)   <<< result true
Then
  comment: passed
  comment: 1.2.13.4.5 is lower then 1.2.3.4.5
  comment: using CompareDotSeparatedStrings give wrong results on numbers

Else
EndIf

Set  $string1$ = "1.2.3.4.5"
  The value of the variable "$string1$" is now: "1.2.3.4.5"

Set  $string2$ = "1.2.13.4.5"
  The value of the variable "$string2$" is now: "1.2.13.4.5"

Set  $ConstTest$ = "1"
  The value of the variable "$ConstTest$" is now: "1"

Set  $CompValue$ = CompareDotSeparatedStrings($string1$, $string2$)
  The value of the variable "$CompValue$" is now: "1"

If
  $ConstTest$ = $CompValue$   <<< result true
  ($ConstTest$ = $CompValue$)   <<< result true
Then
  comment: passed
  comment: 1.2.3.4.5 is higher then 1.2.13.4.5
  comment: using CompareDotSeparatedStrings give wrong results on numbers

Else
EndIf
----

*  `getDiffTimeSec` +
retourne une chaîne avec le nombre entier de secondes écoulées depuis le dernier appel de `marktime`. +
Disponible depuis 4.11.3.1

* `SidToName(`<sid-connu>`)` +
retourne une chaîne avec le nom du groupe de <sid-connu>. Par exemple, si <sid-connu> est égal à 'S-1-5-32-544' alors `SidToName` il retourne 'Administrators'.  +
Disponible depuis 4.11.3.1

* `GetMyIpByTarget(`<adresse-ip-cible>`)` +
retourne une liste d'adresses IP, qui tentent de rejoindre le système d'exploitation à <adresse-ip-cible>. Cette fonction retourne une valeur qui est plus sûr que la constante `%IPAddress%`. +
Disponible depuis 4.11.3.1 +
Exemple:
[source,winst]
----
set $CompValue$ = getMyIpByTarget("%opsiServer%")
----

* `GetIpByName(`<ip addr / ip name>`)` +
renvoie les adresses IP des ordinateurs avec <ip addr / ip name> +
Disponible depuis 4.11.3.2
[source,winst]
----
set $ConstTest$ = "%IPAddress%"
set $string1$ = "%IPAddress%"
set $CompValue$ = getIpByName($string1$)
if ($ConstTest$ = $CompValue$)
	comment "passed"
else
	set $TestResult$ = "not o.k."
	LogWarning "failed"
endif
set $CompValue$ = getIpByName("%HostID%")
if ($ConstTest$ = $CompValue$)
	comment "passed"
else
	set $TestResult$ = "not o.k."
	LogWarning "failed"
endif
set $CompValue$ = getIpByName("%PCName%")
if ($ConstTest$ = $CompValue$)
	comment "passed"
else
	set $TestResult$ = "not o.k."
	LogWarning "failed"
endif
----

*  `getLastExitCode` +
Renvoie une chaîne qui contient la valeur du code de sortie du dernier processus appelé par une section WinBatch / ShellScript / ExecWith. +
Lorsque vous utilisez une section ShellScript ou ExecWith, vous obtiendrez normalement le code de sortie de l'interprète qui a été appelé. Pour obtenir le code de sortie de votre script, vous devez le définir explicitement.

Example:
[source,winst]
----
ShellScript_exit1
set $ConstTest$ = "1"
set $CompValue$ = getLastExitCode
if ($ConstTest$ = $CompValue$)
	comment "ShellScript exitcode passed"
else
	set $TestResult$ = "not o.k."
	LogWarning "ShellScript exitcode failed"
endif

[ShellScript_exit1]
rem create an errolevel= 1
VERIFY OTHER 2> NUL
echo %ERRORLEVEL%
exit %ERRORLEVEL%
----

[[opsi-winst-string-functions-license]]
==== (Chaîne-) Fonctions de gestion des licences

* `DemandLicenseKey(`poolId [, productId [,windowsSoftwareId]]`)` +
demande au service OPSI via la fonction getAndAssignSoftwareLicenseKey pour une réservation d'une licence pour le client. +
Le pool à partir duquel les licences sont prises peut être explicitement donné par son ID ou est identifié par un ID du produit associé ou de l'ID du Software Windows (possible, si ces associations sont définies dans la configuration des licences). +
'poolId', 'productId', 'windowsSoftwareId' sont des chaînes (expressions de type chaîne). +
Si aucun 'poolId' est explicitement donnée, le premier paramètre doit être une chaîne vide  "". La même procédure se fait avec d'autres Ids ne pas donné explicitement. +
La fonction retourne la clé de licence qui est tirée du pool.

Exemples:
[source,winst]
----
set $mykey$ = DemandLicenseKey ("pool_office2007")
set $mykey$ = DemandLicenseKey ("", "office2007")
set $mykey$ = DemandLicenseKey ("", "", "{3248F0A8-6813-11D6-A77B}")
----

* `FreeLicense (`poolId [, productId [,windowsSoftwareId]]]`)` +
demande au service OPSI, via la fonction freeSoftwareLicense, de libérer la licence actuelle de réservation.
La syntaxe est analogue à la syntaxe pour `DemandLicenseKey`

Exemple:
[source,winst]
----
DefVar $opsiresult$
set $opsiresult$ = FreeLicense("pool_office2007")
----

'$opsiresult$' devient la chaîne vide, si aucune erreur s'est produite, et, si une erreur survient, le texte d'info de l'erreur.

[[opsi-winst-string-functions-serviceerrors]]
==== Récupération Infos erreur des appels de service

* `getLastServiceErrorClass` +
Renvoie, comme son nom l'indique, le nom de classe de l'information d'erreur du dernier appel de service. Si le dernier appel de service n'a pas produit une erreur la fonction retourne la valeur "None".

* `getLastServiceErrorMessage` +
Renvoie la chaîne du message de la dernière information  d'erreur "None". +
Depuis la chaîne du message a plus de chances d'être changée, il est recommandé de baser la logique de script sur le nom de la classe.

Exemple:
[source,winst]
----
if getLastServiceErrorClass = "None"
    comment "kein Fehler aufgetreten"
endif
----

[[opsi-winst-stringlist]]
=== Fonctions de liste de chaînes et Traitement de liste de chaînes

Une liste de chaîne (ou une valeur de liste de chaînes) est une séquence de valeurs de chaîne. Pour ce genre de valeurs nous avons la variable de type `String list`. Elles sont définies par la déclaration

`DefStringList` <Nom de la variable>

Une valeur de liste de chaînes peut être affecté à la variable de liste de chaînes:

`Set` <Nom de la variable> `=` <StringListValue>

Les valeurs d'une liste de chaînes peuvent être données seulement comme résultat des expressions de chaîne. Il y a plusieurs façons de créer ou de capturer des listes de chaînes, et de nombreuses options pour les traiter, souvent donnant une nouvelles liste de chaînes. Elles sont présentées dans les paragraphes suivants. 

Pour les exemples suivants, nous déclarons une variable de liste de chaînes '$list1$':

[source,winst]
----
DefStringList $list1$
----

Si nous nous référons des variables nommées  String0, StringVal, .. on entend que ceux-ci représentent toutes les expressions de chaîne.

Nous commençons avec un type particulier et plutôt utile de listes de chaînes: 'maps' – également appelés hachages ou tableaux associatifs – qui se composent d'une ligne de la forme 'CLÉ'='VALEUR'. En fait, chaque 'map' devrait établir une fonction qui associe une 'VALEUR' à une 'CLÉ', et toute les 'CLÉ' devrait avoir lieu maximum une fois tant que première partie d'une ligne (alors différentes 'CLÉ's peuvent être associées avec les mêmes 'VALEUR').

[[opsi-winst-stringlist-maps]]
==== Informations sur Maps

*  `getMSVersionMap` +
récupère les informations sur le système d'exploitation et les enregistre dans une liste de chaînes table de hachage. +
Il y a les clés suivants:
* major_version
* minor_version
* build_number
* platform_id
* csd_version
* service_pack_major
* service_pack_minor
* suite_mask
* product_type_nr
* 2003r2

Les résultats de 'suite_mask' et 'product_type_nr' sont des entiers qui peuvent être bâtie par une opérations 'or' des valeurs suivantes.

product_type_nr
****
    0x0000001 (VER_NT_WORKSTATION)
    0x0000002 (VER_NT_DOMAIN_CONTROLLER)
    0x0000003 (VER_NT_SERVER)
****

SuiteMask
****
    0x00000001 (VER_SUITE_SMALLBUSINESS)
    0x00000002 (VER_SUITE_ENTERPRISE)
    0x00000004 (VER_SUITE_BACKOFFICE)
    0x00000008 (VER_SUITE_COMMUNICATIONS)
    0x00000010 (VER_SUITE_TERMINAL)
    0x00000020 (VER_SUITE_SMALLBUSINESS_RESTRICTED)
    0x00000040 (VER_SUITE_EMBEDDEDNT)
    0x00000080 (VER_SUITE_DATACENTER)
    0x00000100 (VER_SUITE_SINGLEUSERTS)
    0x00000200 (VER_SUITE_PERSONAL)
    0x00000400 (VER_SUITE_SERVERAPPLIANCE)
****

Exemple: +
Le code
[source,winst]
----
DefStringList $INST_Resultlist$
DefStringList $INST_Resultlist2$

message "getMSVersionMap"
comment "get value by winst function"
set $INST_Resultlist$ = getMSVersionMap
----

entraîne le journal système suivant:
[source,winst]
----
message getMSVersionMap
comment: get value by winst function

Set  $INST_Resultlist$ = getMSVersionMap
    retrieving strings from getMSVersionMap [switch to loglevel 7 for debugging]
        (string   0)major_version=5
        (string   1)minor_version=1
        (string   2)build_number=2600
        (string   3)platform_id=2
        (string   4)csd_version=Service Pack 3
        (string   5)service_pack_major=3
        (string   6)service_pack_minor=0
        (string   7)suite_mask=256
        (string   8)product_type_nr=1
        (string   9)2003r2=false
----

[NOTE]
==============================
Infos de base pour getMSVersionMap

* http://msdn.microsoft.com/en-us/library/ms724385%28VS.85%29.aspx
* http://msdn.microsoft.com/en-us/library/dd419805.aspx
* http://msdn.microsoft.com/en-us/library/ms724833%28VS.85%29.aspx

==============================

*  `getFileInfoMap(`<NOM DE FICHIER>`)` +
récupère les informations de version intégré dans le fichier  NOM DE FICHIER et les enregistre dans une liste de chaînes map.

En ce moment, il existe les clés,

* Comments
* CompanyName
* FileDescription
* FileVersion
* InternalName
* LegalCopyright
* LegalTrademarks
* OriginalFilename
* PrivateBuild
* ProductName
* ProductVersion
* SpecialBuild
* Language name <index>
* Language ID <index>
* file version with dots
* file version
* product version

Utilisation: Si nous définissons et appelons
[source,winst]
----
DefStringList FileInfo
DefVar $InterestingFile$
Set $InterestingFile$ = "c:\program files\my program.exe"
set FileInfo = getFileInfoMap($InterestingFile$)
----

nous obtenons la valeur associée à la clé "FileVersion" par l'appel 
[source,winst]
----
DefVar $result$
set $result$ = getValue("FileVersion", FileInfo)
----

(pour la fonction getValue voir <<opsi-winst-stringlist-getstring>>).

Exemple: +
Le code:
[source,winst]
----
set $InterestingFile$ = "%winstdir%\winst.exe"
if not (FileExists($InterestingFile$))
	set $InterestingFile$ = "%winstdir%\winst32.exe"
endif
set $INST_Resultlist$ = getFileInfoMap($InterestingFile$)
----

produit la sortie journal système suivante:
[source,winst]
----
Set  $InterestingFile$ = "N:\develop\delphi\winst32\trunk\winst.exe"
  The value of the variable is now: "N:\develop\delphi\winst32\trunk\winst.exe"

If
    Starting query if file exist ...
  FileExists($InterestingFile$)   <<< result true
  not (FileExists($InterestingFile$))   <<< result false
Then
EndIf

Set  $INST_Resultlist$ = getFileInfoMap($InterestingFile$)
    retrieving strings from getFileInfoMap [switch to loglevel 7 for debugging]
        (string   0)Language name 0=Deutsch (Deutschland)
        (string   1)Language ID 0=1031
        (string   2)file version=1125942857039872
        (string   3)file version with dots=4.10.8.0
        (string   4)product version=1125942857039872
        (string   5)Comments=
        (string   6)CompanyName=uib gmbh (www.uib.de)
        (string   7)FileDescription=opsi.org
        (string   8)FileVersion=4.10.8.0
        (string   9)InternalName=
        (string  10)LegalCopyright=uib gmbh under GPL
        (string  11)LegalTrademarks=opsi
        (string  12)OriginalFilename=
        (string  13)PrivateBuild=
        (string  14)ProductName=opsi-winst
        (string  15)ProductVersion=4.0
        (string  16)SpecialBuild=
----

*  `getLocaleInfoMap` +
récupère les informations du système sur la localisation et l'écrit dans une liste de chaînes map.

En ce moment, il existe les clés:

* language_id_2chars (version de deux lettres du nom de la langue par défaut du système)
* language_id (version de trois lettres, y compris les sous-type de la langue)
* localized_name_of_language
* English_name_of_language
* abbreviated_language_name
* native_name_of_language
* country_code
* localized_name_of_country
* English_name_of_country
* abbreviated_country_name
* native_name_of_country
* default_language_id
* default_language_id_decimal
* default_country_code
* default_oem_code_page
* default_ansi_code_page
* default_mac_code_page
* system_default_language_id	Hexadecimal Windows locale Id
* system_default_posix		Language_Region (Posix Style)
* system_default_lang_region	Language-Region (BCP 47 Style)

Les clés system_default donnent des informations sur la langue de l'OS installé. Les autres clés donnent des informations sur la localisation de l'interface graphique.

Exemple: +
Le code:
[source,winst]
----
message "Locale Infos"
set $INST_Resultlist$ = getLocaleInfoMap
----

produit par exemple le journal système:
[source,winst]
----
message Locale Infos

Set $INST_Resultlist$ = getLocaleInfoMap
    retrieving strings from getLocaleInfoMap [switch to loglevel 7 for debugging]
        (string   0)language_id_2chars=DE
        (string   1)language_id=DEU
        (string   2)localized_name_of_language=Deutsch (Deutschland)
        (string   3)English_name_of_language=German
        (string   4)abbreviated_language_name=DEU
        (string   5)native_name_of_language=Deutsch
        (string   6)country_code=49
        (string   7)localized_name_of_country=Deutschland
        (string   8)English_name_of_country=Germany
        (string   9)abbreviated_country_name=DEU
        (string  10)native_name_of_country=Deutschland
        (string  11)default_language_id=0407
        (string  12)default_language_id_decimal=1031
        (string  13)default_country_code=49
        (string  14)default_oem_code_page=850
        (string  15)default_ansi_code_page=1252
        (string  16)default_mac_code_page=10000
        (string  17)system_default_language_id=0407
        (string  18)system_default_posix=de_DE
        (string  19)system_default_lang_region=de-DE
----

Utilisation: Si nous définissons et appelons
[source,winst]
----
DefStringList $languageInfo$
set  $languageInfo$ = getLocaleInfoMap
----

nous obtenons la valeur associée à la clé "language_id_2chars" par l'appel 
[source,winst]
----
DefVar $result$
set $result$ = getValue("language_id_2chars", $languageInfo$)
----

(pour la fonction getValue voir <<opsi-winst-stringlist-getstring>>). Nous pouvons maintenant écrire des scripts en utilisant une construction comme
[source,winst]
----
if getValue("language_id_2chars", languageInfo) = "DE"
   ; installiere deutsche Version
else 
   if getValue("language_id_2chars", languageInfo) = "EN"
   ; installiere englische Version
   endif
endif 
----

[NOTE]
==============================

Infos de base pour getLocaleInfoMap:

* http://msdn.microsoft.com/en-us/library/cc233968.aspx
* http://msdn.microsoft.com/en-us/library/0h88fahh.aspx
* bcp 47 validator: +
http://schneegans.de/lv/?tags=de-de-1996&format=text

* http://www.iana.org/assignments/language-subtag-registry
* http://www.the-localization-tool.com/?p=698

==============================

*  `getLocaleInfo` +
(obsolète): utilisez `GetLocaleInfoMap` .

* `getProductMap` // depuis 4.11.2.1 +
retourne une carte d'information du produit opsi que vous venez d'installer. +
Il fonctionne uniquement si '{opsi-winst}' s'exécute en mode service d'opsi. +
les clés sont: id, name, description, advice, productversion, packageversion, priority, installationstate, lastactionrequest, lastactionresult, installedversion, installedpackage, installedmodificationtime


Exemple:
[source,winst]
----
set $INST_Resultlist$ = getProductMap
set $string1$ = getValue("id", $INST_Resultlist$)
----

produit par exemple le journal système:
[source,winst]
----
Set  $INST_Resultlist$ = getProductMap
    retrieving strings from getProductMap [switch to loglevel 7 for debugging]
        (string   0)id=opsi-script-test
        (string   1)name=opsi-winst test
        (string   2)description=Test  and example script for opsi-winst
        (string   3)advice=
        (string   4)productversion=4.11.2
        (string   5)packageversion=1
        (string   6)priority=0
        (string   7)installationstate=unknown
        (string   8)lastactionrequest=setup
        (string   9)lastactionresult=successful
        (string  10)installedversion=4.11.2
        (string  11)installedpackage=1
        (string  12)installedmodificationtime=
        

Set  $string1$ = getValue("id", $INST_Resultlist$)
    retrieving strings from $INST_Resultlist$ [switch to loglevel 7 for debugging]
        (string   0)id=opsi-script-test
        (string   1)name=opsi-winst test
        (string   2)description=Test  and example script for opsi-winst
        (string   3)advice=
        (string   4)productversion=4.11.2
        (string   5)packageversion=1
        (string   6)priority=0
        (string   7)installationstate=unknown
        (string   8)lastactionrequest=setup
        (string   9)lastactionresult=successful
        (string  10)installedversion=4.11.2
        (string  11)installedpackage=1
        (string  12)installedmodificationtime=
        
  The value of the variable "$string1$" is now: "opsi-script-test"
----  

[[opsi-winst-stringlist-create-by-value]]
==== Produire des listes de chaînes à partir des chaînes

* `createStringList (`chaîne0, chaîne1 ,... `)` +
forme une liste de chaînes à partir des valeurs des expressions chaîne énumérés. Par exemple, avec
[source,winst]
----
set $list1$ = createStringList ('a','b', 'c', 'd')
----

nous obtenons une liste des quatre premières lettres de l'alphabet. 

Les deux fonctions suivantes produisent une liste de chaînes en séparant des chaîne:

* `splitString (`<chaîne1>, <chaîne2>`)` +
génère la liste partielle des chaînes de <chaîne1> (y compris les chaînes vides) avant respectivement entre les occurrences de <chaîne2>.  Ex., 
[source,winst]
----
set $list1$ = splitString ("\\server\share\directory",  "\")
----
définit la liste  +
'"", "", "server", "share", "directory"'

* `splitStringOnWhiteSpace (`<chaîne>`)` +
coupes StringVal par le "blancs" dedans. Par exemple 
[source,winst]
----
set $list1$ = splitStringOnWhiteSpace("Status   Lokal     Remote         Netzwerk")
----
produit la liste +
'"Status", "Lokal", "Remote", "Netzwerk"' +
peu importe combien d'espaces ou des tabulations constituent l'espace blanc entre les mots.

[[opsi-winst-stringlist-create-by-file]]
==== Chargement des lignes d'un fichier texte dans une liste de chaînes

* `loadTextFile (`<nom de fichier>`)` +
lit le fichier <nom de fichier> et génère la liste de chaînes, qui contient toutes les lignes du fichier.


* `loadUnicodeTextFile (`<nom de fichier>`)` +
lit le fichier texte unicode <nom de fichier> et génère la liste de chaînes, qui contient toutes les lignes du fichier. +
Par cet appel, les chaînes sont converties dans le code par défaut du système 8 bits.

* `getSectionNames (`<nom de fichier>`)` +
interprète le fichier spécifié comme un fichier ini, regardant pour la liste toutes les lignes de la forme +
'[<SectionName>]' +
et renvoie les noms de section (sans parenthèses).

[[opsi-winst-stringlist-getstring]]
==== Valeurs de chaîne simple générés à partir des listes de chaînes
 
* `composeString (`<liste de chaînes>, <liens de chaîne>`)` +
Grâce à cette fonction, les éléments d'une liste chaîne peuvent être collés les uns aux autres, médiée par un "colle de chaîne". +
Par exemple si '$list1$' représente la liste 'a', 'b', 'c', 'd', 'e' +
avec 
[source,winst]
----
$line$ = composeString ($list1$, " | ")
----
nous attribuons la valeur  '"a | b | c | d | e".' à '$line$'.

* `takeString(`<index>,<liste>`)` +
Par exemple si  $list1$ représente la liste des cinq premières lettres de l'alphabet, avec +
[source,winst]
----
takeString (2, $list1$)
----
on obtient la chaîne "c" (puisque le comptage de liste commence par 0). +
Les valeurs négatives de l'indice vont vers le bas de la valeur de comptage de liste. Par exemple, 
[source,winst]
----
takeString (-1, $list1$)
----
retourne le dernièr élément de la liste, qui est  "e".

* `takeFirstStringContaining(`<liste>,<chaîne de recherche>`)` +
retourne la première chaîne de la liste qui contient la <chaîne de recherche>. +
Retourne une chaîne vide si aucune chaîne correspondant n'a été trouvé.

* `getValue(`<clé>, <liste>`)` +
Cette fonction tente d'interpréter une liste de chaînes comme liste de lignes de la forme 
'clé=valeur' +
Il examine la première ligne, où la chaîne <clé> est suivi par le signe égal, et renvoie le reste de la ligne ('valeur', la chaîne qui commence après le signe égal). S'il n'y a pas de ligne de raccord, elle retourne la chaîne 'NULL'. +
La fonction est requise pour l'utilisation des fonctions `getLocaleInfoMap` et `getFileVersionMap` (voir <<opsi-winst-stringlist-maps>>).

* `getValueBySeparator(`<chaîne clef>,<chaîne de séparation>,<liste de chaînes de hachage> `)` //depuis 4.11.2.1 +
fonctionne comme `getValue` mais vous devez donner la <chaîne de séparation> de sorte que peut également travailler avec des hachages, comme +
'key:value' 


* `count (`<liste>`)` +
renvoie le nombre d'éléments de la liste de chaînes <liste> en tant que chaîne. +
par exemple pour $list1$ composé comme +
'a', 'b', 'c', 'd', 'e' +
`count ($list1$)` a la valeur "5".

[[opsi-winst-stringlist-create-by-section]]
==== Produire des listes de chaîne à partir des sections opsi-winst

* `retrieveSection (`nom de la section`)` +
donne les lignes de la section spécifiée comme liste de chaînes.

* `getOutStreamFromSection (`nom de la section`)` +
invoque la section et – à ce moment mis en œuvre uniquement pour les appels `ShellScript`,`ExecWith` et `ExecPython` – capture la sortie standard et des erreurs de la commande invoquée pour les écrire dans une liste de chaînes. Par exemple: +
[source,winst]
----
set $list$ = getOutStreamFromSection ('ShellScript_netuse')

[ShellScript_netuse]
net use
----
`$list1$` contient, parmi les quelques trucs environnantes, la liste de toutes les partages montée d'un PC. 


* `getReturnListFromSection (`nom de la section`)` +
Pour certains types de section - à ce moment mis en œuvre uniquement pour les sections `XMLPatch` et `opsiServiceCall` -  il y a une déclaration spécifique `return` qui donne un résultat de l'exécution de la section (supposé être de type liste de chaîne).  +
Par exemple nous pouvons utiliser l'instruction
[source,winst]
----
set list1 = getReturnListFromSection ('XMLPatch_mime "c:\mimetypes.rdf"')
----
pour obtenir une liste de noeud spécifique du fichier XML `mimetypes.rdf`. (Plus d'infos pour les sections XMLPatch dans <<opsi-winst-xmlpatch>> du manuel). +
Ou la liste des clients OPSI est produite par la référence à un appel de service OPSI: +
[source,winst]
----
DefStringList $result$
Set $result$=getReturnListFromSection("opsiservicecall_clientIdsList")

[opsiservicecall_clientIdsList]
"method":"getClientIds_list"
"params":[]
----

[[opsi-winst-stringlist-create-by-registry]]
=== Les listes de chaînes à partir du Registre

* `getRegistryKeyList32(`<clé-de-registre>`)` +
Retourne une liste de chaînes avec les noms de toutes les clés à l'intérieur de <clé-de-registre>. +
Mode 32 bits (avec la redirection). Disponible depuis 4.11.3

* `getRegistryKeyList64(`<clé-de-registre>`)` +
Retourne une liste de chaînes avec les noms de toutes les clés à l'intérieur de <clé-de-registre>. +
Mode 64 bits (sans la redirection). Disponible depuis 4.11.3

* `getRegistryKeyListSysnative(`<clé-de-registre>`)` +
Retourne une liste de chaînes avec les noms de toutes les clés à l'intérieur de <clé-de-registre>. +
Le mode (redirection) dépend de l'architecture du système d'exploitation. Disponible depuis 4.11.3

* `getRegistryVarList32(`<clé-de-registre>`)` +
Retourne une liste de chaînes avec le noms de toutes les entrées de valeur associée à la clé <clé-de-registre>. +
Mode 32 bits (avec la redirection). Disponible depuis 4.11.3

* `getRegistryVarList64(`<clé-de-registre>`)` +
Retourne une liste de chaînes avec le noms de toutes les entrées de valeur associée à la clé <clé-de-registre>. +
Mode 64 bits (sans la redirection). Disponible depuis 4.11.3

* `getRegistryVarListSysnative(`<clé-de-registre>`)` +
Retourne une liste de chaînes avec le noms de toutes les entrées de valeur associée à la clé <clé-de-registre>. +
Le mode (redirection) dépend de l'architecture du système d'exploitation. Disponible depuis 4.11.3

* `getRegistryVarMap32(`<clé-de-registre>`)` +
Fournit une carte de toutes les paires nom = valeur dans la clé de registre donnée <clé-de-registre>. +
Mode 32 bits (avec la redirection). Disponible depuis 4.11.3

* `getRegistryVarMap64(`<clé-de-registre>`)` +
Fournit une carte de toutes les paires nom = valeur dans la clé de registre donnée <clé-de-registre>. +
Mode 64 bits (avec la redirection). Disponible depuis 4.11.3

* `getRegistryVarMapSysnative(`<clé-de-registre>`)` +
Fournit une carte de toutes les paires nom = valeur dans la clé de registre donnée <clé-de-registre>. +
Le mode dépend de l'architecture du système d'exploitation. Disponible depuis 4.11.3

Exemple: +
Dans un premier temps, nous avons créé des entrées dans la base de registre avec l'exemple de code suivant: +
[source,winst]
----
Registry_createkeys /32Bit

[Registry_createkeys]
openkey [HKEY_LOCAL_MACHINE\SOFTWARE\opsi.org\opsi-script-test]
set "var1" = "value1"
set "var2" = REG_SZ:"value2"
set "var3" = REG_EXPAND_SZ:"value3"
set "var4" = REG_DWORD:444
set "var5" = REG_BINARY:05 05 05 0F 10
set "var6" = REG_MULTI_SZ:"value6|value7|de"
openkey [HKEY_LOCAL_MACHINE\SOFTWARE\opsi.org\opsi-script-test\key1]
openkey [HKEY_LOCAL_MACHINE\SOFTWARE\opsi.org\opsi-script-test\key2]
openkey [HKEY_LOCAL_MACHINE\SOFTWARE\opsi.org\opsi-script-test\key3]
openkey [HKEY_LOCAL_MACHINE\SOFTWARE\opsi.org\opsi-script-test\key4]
----
Compte tenu des entrées de registre dans l'exemple ci-dessus, et le code ci-dessous:
[source,winst]
----
set $list$ = getRegistryVarList32("hklm\software\opsi.org\opsi-script-test")
----
nous allons voir les valeurs suivantes dans le log: 
----
Set  $list$ = GetRegistryVarList32("hklm\software\opsi.org\opsi-script-test")
Registry started with redirection (32 Bit)
    retrieving strings from GetRegistryVarList32 [switch to loglevel 7 for debugging]
        (string   0)var1
        (string   1)var2
        (string   2)var3
        (string   3)var4
        (string   4)var5
        (string   5)var6
----

Ensuite, nous appelons:
[source,winst]
----
set $list$ = getRegistryVarMap32("hklm\software\opsi.org\opsi-script-test")
----
Le Log suivant: 
----
Set  $list$ = GetRegistryVarMap32("hklm\software\opsi.org\opsi-script-test")
retrieving strings from GetRegistryVarMap32 [switch to loglevel 7 for debugging]
    (string   0)var1=value1
    (string   1)var2=value2
    (string   2)var3=value3
    (string   3)var4=444
    (string   4)var5=05 05 05 0F 10
    (string   5)var6=value6
----

Compte tenu des entrées de registre dans l'exemple ci-dessus, et le code ci-dessous:
[source,winst]
----
set $list$ = getRegistryKeyList32("hklm\software\opsi.org\opsi-script-test")
----
nous aurons la clé suivante dans le log:
----
Set  $list$ = GetRegistryKeyList32("hklm\software\opsi.org\opsi-script-test")
Registry started with redirection (32 Bit)
    retrieving strings from GetRegistryKeyList32 [switch to loglevel 7 for debugging]
        (string   1)key1
        (string   2)key2
        (string   3)key3
        (string   4)key4
----

[[opsi-winst-stringlist-create-by-propery]]
==== Les listes de chaînes provenant des Propriétés du produit

* `getProductPropertyList(`<nom-de-la-propriété>,<valeurs-par-défaut>`)` +
retourne une liste de chaînes de valeurs qui sont désignés par la propriété des produits à valeurs multiples <nom-de-la-propriété>. S'il n'y a pas de connexion avec le serveur opsi, alors la liste des chaînes résultante ne contient que des <valeurs-par-défaut>. +
Si vous appelez la fonction `GetProductProperty` avec une propriété à valeurs multiples, alors vous obtiendrez les valeurs sélectionnées dans un format de chaîne séparée par des virgules. Ce qui conduira à des problèmes si les valeurs retournées contiennent des caractères séparés par des virgules qui ne sont pas destinés à être analysés. +
Disponible depuis 4.11.3 +
Exemple:
[source,winst]
----
;Property "dummymulti" has the values: ("ab", "cd", "ef", "g,h")
set $list$ = GetProductPropertyList ("dummymulti","True")
if not ("" = takeFirstStringContaining($list$,"g,h"))
	comment "GetProductPropertyList passed"
else
	set $TestResult$ = "not o.k."
	LogWarning "GetProductPropertyList failed"
endif

set $ConstTest$ = "ab,cd,ef,g,h"
set $CompValue$ = GetProductProperty ("dummymulti","True")
if ($ConstTest$ = $CompValue$)
	comment "GetProductProperty passed"
else
	set $TestResult$ = "not o.k."
	LogWarning "GetProductProperty failed"
endif
----

[[opsi-winst-stringlist-transform]]
==== Transformer les listes de chaînes

* `getSubList (`<index de démarrage>, <index de fin>, <liste> `)` +
retourne une liste partielle d'une liste donnée. +
Par exemple, si 'liste' représente la liste des lettres 'a', 'b', 'c', 'd', 'e', par la déclaration:
[source,winst]
----
set $list1$ = getSubList(1 : 3, $list$)
----
on obtient la liste partielle 'b', 'c', 'd' . L'index de démarrage ainsi que l'index de fin doivent être interprétées comme l'indice du premièr et du dernier éléments de la liste incluse. Le comptage commence par 0. +
L'index de début par défaut est 0, l'indice de fin par défaut est l'indice du dernier élément de la liste. +
Par conséquent, (pour la list1 définie ci-dessus) la commande +
[source,winst]
----
set $list1$ = getSubList(1 : , $list$)
----
donne la liste 'b', 'c', 'd', 'e'. 
[source,winst]
----
set $list1$ = getSubList(:, $list$)
----
produit une copie de la liste originale. +
Il est possible de compter à rebours afin de déterminer le dernier indice: 
[source,winst]
----
set $list1$ = getSubList(1 : -1, $list$)
----
définit la liste des éléments à commencer par le premièr et se terminant du deuxième au dernier élément de la liste –  dans l'exemple ci-dessus on obtient à nouveau la liste 'b', 'c', 'd'.

* `getListContaining(`<liste>,<chaîne de recherche>`)` +
retourne la première chaîne à partir de <liste> qui contient la <chaîne de recherche>. Retourne une chaîne vide si la <chaîne de recherche> n'est pas trouvée.

* `takeFirstStringContaining(`<liste>,<chaîne de recherche>`)` +
Retourne la première chaîne de <liste> qui contient la <chaîne de recherche>. + Retourne une chaîne vide si la <chaîne de recherche> n'est pas trouvée.

* `addtolist(`<liste>,<chaîne>`)` +
Ajoute <chaîne> à la liste <liste>.

* `addlisttolist(`<liste1>,<liste2>`)` +
Ajoute la liste <liste2> à la liste <liste1>.

* `reverse (`<liste>`)` +
Produit la liste inversée, +
si  $list$ est 'a', 'b', 'c', 'd', 'e', avec +
[source,winst]
----
set $list1$ = reverse ($list$)
----
nous obtenons la $list1$ 'e', 'd', 'c', 'b', 'a'.

[[opsi-winst-stringlist-misc]]
==== Autres Listes de chaînes

* `getProfilesDirList` +
Fournit une liste de chemins d'accès aux profils locaux. +
Les profils qui contiennent les mots suivants *ne seront pas* considérés: +

** 'localservice'

** 'networkservice'

** 'systemprofile'

Le profil des 'Default Users' est inclus dans la liste. +
`All User` ou `Public` ne sont pas inclus dans la liste.

Exemple:
[source,winst]
----
set $list1$ = getProfilesDirList
----
entraîne le log suivant:
----
Set  $list1$ = getProfilesDirList
Registry started with redirection (32 Bit)
    retrieving strings from getProfilesDirList [switch to loglevel 7 for debugging]
        (string   0)C:\Users\Administrator
        (string   1)C:\Users\Default
----

[[opsi-winst-stringlist-iteration]]
==== Itération à travers les listes de chaînes

Une utilisation importante de listes de chaînes est basé sur la possibilité que le script s'exécute à travers tous les éléments d'une liste exécutant quelques opérations sur chaque élément de la chaîne.

La syntaxe pour définir cette répétition est:

* `for` %s% `in` <liste> `do` <une déclaration | une sous-section>

Cette expression définit localement une variable de chaîne %s% qui prend une à une les valeurs des éléments de la liste.
<une déclaration> peut être n'importe quelle instruction unique qui peut exister dans une section primaire ou (et plus intéressant) il peut être un appel à une sous-section. L'indice d'itération définis localement %s% existe dans l'ensemble du contexte de la déclaration, en particulier dans la sous-section si la déclaration est un appel à la sous-section. 

CAUTION: Le mécanisme de remplacement pour %s% fonctionne toujours comme ça pour les constantes:  Le nom de la variable est remplacée par les valeurs des éléments. Si l'on parcourt une liste 'a','b','c' et l'indice d'itération est nommé %s%, nous obtenons pour %s% un à un  a, b, c  –   pas les valeurs de la chaîne. Pour reproduire la liste originale des éléments nous devons enfermer %s% entre guillemets.

Exemple: Que $list1$ soit la liste  'a', 'b', 'c', 'd', 'e', et $line$ une variable chaîne. La déclaration  
[source,winst]
----
for %s% in $list1$ do  set $line$ = $line$ + "%s%"
----
parcourt les éléments de la liste interne exécutant
[source,winst]
----
$line$ = $line$ + "a"
$line$ = $line$ + "b"
$line$ = $line$ + "c"
$line$ = $line$ + "d"
$line$ = $line$ + "e"
----
A la fin la ligne a la valeur 'abcde' . Si nous avons omis les guillemets autour de %s% nous obtiendrions une erreur de syntaxe pour chaque étape d'itération.

Remarque: La variable note n'est valable que dans la procédure appelée directement. Si elle est nécessaire dans les sous-programmes de celui-ci sa valeur doit être transféré à une variable globale.

[[opsi-winst-numbers]]
=== Calcul avec des nombres

Les scripts 'opsi-winst' n'ont pas un type particulier de varibles pour les numéros. Mais il y a certaines fonctions pour aider à calculer avec des nombres.

* `calculate(`<chaîne>`)` +
cette fonction de chaîne, calcule l'expression arithmétique de la chaîne <chaîne> et renvoie le résultat nombre entier comme une chaîne. +
En interne, les calculs sont effectués avec des nombres réels. Cette fonction accepte les opérateurs `+`, `-`, `*`, `/` et les parenthèses `(`,`)`. +
En cas d'erreur, une chaîne vide est retournée et le compteur d'erreurs est incrémenté. Si la chaîne passée contient des caractères autres que des chiffres, des opérateurs valides et des parenthèses, il en résulte une erreur. +
Si le second opérande est manquant, le premier opérande est également pris comme deuxième opérande: 5+ = 10 ; 5* = 25. Ainsi, les chaînes qui sont utilisées pour assembler l'argument doivent être validées par la fonction `isNumber`. +
(Depuis la version 4.11.3.5)

Exemple:
[source,winst]
----
set $ConstTest$ = "0"
set $CompValue$ = calculate("-1+1")
if ($ConstTest$ = $CompValue$)
	comment "passed"
else
	set $TestResult$ = "not o.k."
	LogWarning "failed"
endif
set $ConstTest$ = "1"
set $CompValue$ = calculate("0+1")
if ($ConstTest$ = $CompValue$)
	comment "passed"
else
	set $TestResult$ = "not o.k."
	LogWarning "failed"
endif
set $ConstTest$ = "-1"
set $CompValue$ = calculate("0-1")
if ($ConstTest$ = $CompValue$)
	comment "passed"
else
	set $TestResult$ = "not o.k."
	LogWarning "failed"
endif
set $string1$ = "5"
set $string2$ = "5"
set $ConstTest$ = "25"
set $CompValue$ = calculate($string1$+"*"+$string2$)
if ($ConstTest$ = $CompValue$)
	comment "passed"
else
	set $TestResult$ = "not o.k."
	LogWarning "failed"
endif
set $string1$ = "5"
set $string2$ = "5"
set $ConstTest$ = "1"
set $CompValue$ = calculate($string1$+"/"+$string2$)
if ($ConstTest$ = $CompValue$)
	comment "passed"
else
	set $TestResult$ = "not o.k."
	LogWarning "failed"
endif
set $string1$ = "5"
set $string2$ = "0"
set $ConstTest$ = ""
comment " expecting devision by zero error and empty string result"
set $CompValue$ = calculate($string1$+"/"+$string2$)
if ($ConstTest$ = $CompValue$)
	comment "passed"
else
	set $TestResult$ = "not o.k."
	LogWarning "failed"
endif
set $string1$ = "9"
set $string2$ = "10"
set $ConstTest$ = "1"
comment "result 0.9 is rounded to 1 "
set $CompValue$ = calculate($string1$+"/"+$string2$)
if ($ConstTest$ = $CompValue$)
	comment "passed"
else
	set $TestResult$ = "not o.k."
	LogWarning "failed"
endif
set $string1$ = "10"
set $string2$ = "9"
set $ConstTest$ = "1"
comment "result 1.1111 is rounded to 1 "
set $CompValue$ = calculate($string1$+"/"+$string2$)
if ($ConstTest$ = $CompValue$)
	comment "passed"
else
	set $TestResult$ = "not o.k."
	LogWarning "failed"
endif
set $string1$ = "5"
set $string2$ = "5"
set $ConstTest$ = "55"
comment " rule * before +"
set $CompValue$ = calculate($string1$+"+"+$string2$+"*10")
if ($ConstTest$ = $CompValue$)
	comment "passed"
else
	set $TestResult$ = "not o.k."
	LogWarning "failed"
endif
set $string1$ = "5"
set $string2$ = "5"
set $ConstTest$ = "100"
comment "brackets before  rule * before + "
set $CompValue$ = calculate("("+$string1$+"+"+$string2$+")*10")
if ($ConstTest$ = $CompValue$)
	comment "passed"
else
	set $TestResult$ = "not o.k."
	LogWarning "failed"
endif
set $string1$ = "5"
set $string2$ = "ten"
set $ConstTest$ = ""
comment "invalid char error"
set $CompValue$ = calculate($string1$+"*"+$string2$)
if ($ConstTest$ = $CompValue$)
	comment "passed"
else
	set $TestResult$ = "not o.k."
	LogWarning "failed"
endif
set $string1$ = "5"
set $string2$ = ""
set $ConstTest$ = "25"
comment "5* is interpreted as 5*5"
set $CompValue$ = calculate($string1$+"*")
if ($ConstTest$ = $CompValue$)
	comment "passed"
else
	set $TestResult$ = "not o.k."
	LogWarning "failed"
endif
set $string1$ = "5"
set $string2$ = ""
set $ConstTest$ = "10"
comment "5+ is interpreted as 5+5"
set $CompValue$ = calculate($string1$+"+")
if ($ConstTest$ = $CompValue$)
	comment "passed"
else
	set $TestResult$ = "not o.k."
	LogWarning "failed"
endif
set $string1$ = "nothing"
set $string2$ = "foo"
set $ConstTest$ = ""
comment "invalid char error"
set $CompValue$ = calculate($string1$+"*"+$string2$)
if ($ConstTest$ = $CompValue$)
	comment "passed"
else
	set $TestResult$ = "not o.k."
	LogWarning "failed"
endif
set $string1$ = "5"
set $string2$ = "foo"
set $ConstTest$ = ""
comment "invalid char error"
set $CompValue$ = calculate($string1$+"/"+$string2$)
if ($ConstTest$ = $CompValue$)
	comment "passed"
else
	set $TestResult$ = "not o.k."
	LogWarning "failed"
endif
----
Pour plus d'exemples faites référence au produit 'opsi-script-test'
à la section '$Flag_calculate$ = "on"'


[[opsi-winst-special-commands]]
=== Commandes spéciales

* `Killtask` <processus>
tente d'arrêter tous les processus qui exécutent le programme nommé par l'expression de chaîne. +
Par exemple
[source,winst]
----
killtask "winword.exe"
----

*   `ChangeDirectory` <répertoire>   //depuis 4.11.2.6
Définir le répertoire donné en tant que répertoire de travail de '{opsi-winst}'. Affecte toutes les actions subséquentes (par exemple les sections winbatch) et sera remis à zéro à la fin d'un script.  
Exemple:
[source,winst]
----
ChangeDirectory "%SCRIPTPATH%\programm"
----

*  `sleepSeconds` <Entier> +
brise l'exécution du programme pour <Entier> secondes.

*  `markTime` +
établit l'horodatage pour l'actuel heure du système et ecris dans le juornal système. 

* `diffTime` +
enregistre le temps écoulé depuis le dernier `marktime`.


[[opsi-winst-commands-logging]]
=== Commandes pour contrôler la journalisation

* `comment` <chaîne> or `comment` = <const chaîne> +
écrit la valeur de l'expression de chaîne respectivement la séquence de caractères dans le journal système.

* `LogError` <chaîne> or `LogError` = <const chaîne> +
écrit des messages d'erreur supplémentaires dans le journal système et incrémente par un le compteur d'erreur.

* `LogWarning` <chaîne> or `LogWarning` = <const chaîne> +
écrit des messages d'avertissement additionnels dans le journal système et incrémente par un le compteur d'avertissement.

* `includelog` <nom de fichier> <taille de la queue>   //depuis 4.11.2.1 +
Inclut le fichier <nom de fichier> dans le journal système. Seule la dernière ligne <taille de la queue> sera incluse. Si vous démarrez un autre programmequi produit un fichier de log, vous pouviez voir que l'autre programme inclue les informations dans le fichier de log de '{opsi-winst}' utilisant cette commande. +
Depuis la version 4.11.3.2, une valeur négative de <taille de la queue> peut être proposée, qui inclura alors les premieres lignes <taille de la queue> à partir de la partie supérieure du fichier de log (dénommé mode 'Head'). + 
Exemple: 
[source,winst]
----
includelog "%Scriptpath%\test-files\10lines.txt" "5"
----

* `SetConfidential` <chaîne secrète> +
Cela empêche à des informations confidentielles (comme les mots de passe) d'être enregistré dans les logs. Dans le fichier de log les informations confidentielles seront remplacés par '"***(confidential)***"'. +
Lorsque le niveau de journalisation est défini sur '9', les informations confidentielles seront enregistrées. +
(depuis la version 4.11.3.5)

Exemple:
[source,winst]
----
message "SetConfidential"
SetConfidential "forbidden"
comment "This is a forbidden string"
comment "shown in the should be in the log file: This is a ***(confidential)*** string"
----
Log:
[source,winst]
----
message SetConfidential
comment: This is a ***(secret)*** string
comment: should be in the log file: This is a ***(confidential)*** string
----

[[opsi-winst-commands-information]]
=== Commandes d'information sur l'utilisateur et l'interaction utilisateur

*  `Message` <expression chaîne> +
ou +
`Message` = <séquence de caractères> +
permet à '{opsi-winst}' d'afficher la valeur de l'expression de chaîne respectivement la séquence de caractères dans la fenêtre des traitements par lots, dans la ligne d'information en haut. Le texte est conservé aussi longtemps qu'aucun nouveau `message` est défini. +
Exemple:
[source,winst]
----
Message "Installation von "+$productid$
----

* `ShowMessageFile` <nom de fichier> +
interprète l'expression de chaîne comme nom de fichier texte, essaie de lire le texte et de l'afficher dans une fenêtre d'informations utilisateur. L'exécution s'arrête jusqu'à ce que l'utilisateur confirme la lecture.  Par exemple par une commande comme 
[source,winst]
----
ShowMessageFile "p:\login\day.msg"
----
on peut réaliser un "Message du jour".

* `ShowBitMap` [<nom de l'image>] [<inscription>] +
place l'image dénotée par <nom de l'image> (dans le format BMP, JPEG ou PNG, de taille 160x160 pixel) et montre l'inscription. + 
<nom de l'image> et <inscription> sont des expressions de chaîne. +
Exemple: +
[source,winst]
----
ShowBitmap "%scriptpath%\" + $ProductId$ + ".png"  "$ProductId$"
----


* `Pause` <chaîne> ou `Pause` = <const chaîne> +
afficher le texte donné comme une expression chaîne ou comme une séquence de caractères dans une fenêtre d'information en attente jusqu'à ce que l'utilisateur confirme la poursuite. 

* `Stop` <chaîne> ou `stop` = <const chaîne> +
arrêt l'exécution du programme si l'utilisateur le confirme. L'expression de chaîne ou la séquence de caractères (éventuellement vide) explique à l'utilisateur ce qui est censé être arrêté.

[[opsi-winst-commands-loginscripts]]
=== Commandes pour userLoginScripts / Support de profil itinérant
NOTE: Le module 'Support de profil itinérant' est sous co-financement. Cela signifie que ces fonctionnalités ne sont pas libres encore (05.10.2011)

* `GetScriptMode`   //depuis 4.11.2.1 +
donne l'une des valeurs possibles 'Machine','Login': +
** 'Machine' - le script *ne* s'exécute *pas* en tant que 'userLoginScript'
** 'Login' - le script s'exécute en tant que 'userLoginScript'

* `GetUserSID(`<Nom d'utilisateur Windows>`)`

* `GetLoggedInUser`   //depuis 4.11.1.2

* `GetUsercontext`   //depuis 4.11.1.2 +
retourne le nom d'utilisateur dans le contexte duquel '{opsi-winst}' est en cours d'exécution.

* `saveVersionToProfile` //depuis 4.11.2.1 +
enregistre +productversion+-+packageversion+ dans le profil local  +
Il est conçu pour être utilisé dans 'userLoginScripts'. +
Cette commande est utilisée en combinaison avec `readVersionFromProfile` ou `scriptWasExecutedBefore`. Il marque que le 'userLoginScript' pour ce produit dans cette version du produit et cette version du paquet a été exécuté pour l'utilisateur actuel. Les informations sont enregistrées dans le fichier "%CurrentAppdataDir%\.opsi.org\userLoginScripts.ini"

* `readVersionFromProfile` //depuis 4.11.2.1 +
retourne une chaîne avec le +productversion+-+packageversion+ pour le produit opsi en cours d'exécution qui a été lue à partir du profil local. Voir aussi: `saveVersionToProfile` +
Il est conçu pour être utilisé dans 'userLoginScripts'.

* `scriptWasExecutedBefore` //depuis 4.11.2.1 +
Cette fonction booléenne `scriptWasExecutedBefore` vérifie si il y a un cachet de version dans le profil (comme vous pouvez le faire avec la commande `readVersionFromProfile`). Il retourne 'true' si +productversion+-+packageversion+ sauvegardés et cours d'exécution son identiques. Puis il crée une nouvelle empreinte du profil (comme vous pouvez le faire avec la commande `saveVersionToProfile`).  Vous pouvez donc simplement utiliser cette commande uniquement dans une déclaration +if+. +
Il est conçu pour être utilisé dans 'userLoginScripts'. 

* `isLoginScript`    //depuis 4.11.2.1 +
Cette fonction booléenne retourne 'true' si le script s'exécute en tant que 'userLoginScript'. Voir aussi: `GetScriptMode`



[[opsi-winst-commands-if-else]]
=== Instructions conditionnelles (déclarations if)

Dans les sections primaires, l'exécution d'une instruction ou d'une séquence d'instructions peut être subordonnée à certaines conditions.

Exemple
[source,winst]
----
;Quelle version de Windows?
DefVar $MSVersion$

Set $MSVersion$ = GetMsVersionInfo
if ($MSVersion$ >= "6")
     sub_install_win7
else
  if ( $MSVersion$ = "5.1" )
    sub_install_winXP
  else
    stop "not a supported OS-Version"
  endif
endif
----

[[opsi-winst-commands-if-else-syntax]]
==== Syntaxe générale

La syntaxe de l'instruction `if` complète est: +
`if` <condition> +
  <séquence d'instructions> +
`else` +
  <séquence d'instructions> +
`endif`

La partie `else` peut être omise.

Les déclarations `if` peuvent être imbriquées. A savoir, dans la séquence d'instructions qui dépendent d'une clause if (peu importe si if est à l'intérieur d'un if ou d'une partie else) une autre déclaration if peut se produire. 

<condition> est une <expression booléenne> . Une expression booléenne (ou logique) peut être construite comme une (chaîne) comparaison des valeurs, par les opérateurs booléens, ou par certains appels de fonctions qui permettent d'évaluer à vrai ou faux. Jusqu'à présent, ces valeurs booléennes ne peuvent pas être explicitement représentée dans un script '{opsi-winst}').

[[opsi-winst-commands-if-else-bool-functions]]
==== Les expressions booléennes

La comparaison de chaînes (ce qui est une expression booléenne) a la forme +
+<expression de chaîne> <signe de comparaison> <expression de chaîne>+ +
où <signe de comparaison> est l'un des signes +
`<`  `<=`  `=`  `>=`  `>`

Les comparaisons de chaînes sont des cas indépendant dans '{opsi-winst}'. 

L'inégalité doit être exprimée par un `NOT()` expression qui est présenté ci-dessous.

Il y a ainsi une expression de comparaison pour comparer des chaînes de chiffres (entier). Si aucun d'entre eux ne peuvent pas être convertie en chiffres, un erreur sera indiquée. +
Cette expression de comparaison de chiffres a la même forme que la comparaison des chaînes mais avec un préfixe INT du signe de comparaison: +
+<expression de chaîne> INT<signe de comparaison> <expression de chaîne>+ +
Ainsi, nous pouvons construire des expressions comme
[source,winst]
----
if $Nom1$ INT<= $Nom2$
----

ou
[source,winst]
----
if $chiffre1$ INT>= $chiffre2$
----

Les opérateurs booléens sont `AND`, `OR`, et `NOT()` (Peu importe la casse). Si  b1, b2 et b3 sont des expressions booléennes des expressions combinées +
b1 `AND` b2 +
b1 `OR` b2 +
`NOT(` b3 `)` +
sont des expressions booléennes ainsi dénotant respectivement la conjonction (`AND`), la disjonction (`OR`) et la négation (`NOT`).

Une expression booléenne peut être mis entre parenthèses (produisant une nouvelle expression booléenne avec la même valeur).

Les règles communes de priorité des opérateurs booléens ("and" avant "or") à cet instant ne sont pas appliqué.  Une expression avec plus d'un opérateur est interprétée de gauche à droite. Pour plus de clarté, dans une expression booléenne qui combine les opérateurs `AND` et `OR`  les parenthèses doivent être employés, par exemple nous devrions écrire explicitement
b1 `OR` (b2 `AND` b3) +
ou +
(b1 `OR` b2) `AND` b3 +
Le deuxième exemple décrit ce que serait exécuté s'il n'y avait pas de parenthèses - alors que l'interprétation commune irait comme l'autre ligne indique.

Les opérateurs booléens peuvent être conçus comme des fonctions de valeur Booléenne spéciaux (l'opérateur de négation le démontre très clairement).

Il y a quelques fonctions booléenne en plus mis en œuvre. Chaque appel d'une telle fonction constitue une expression booléenne ainsi:

* `FileExists`(<nom de fichier>) +
Renvoie 'true' si le fichier ou le répertoire notée existe autrement 'false'.  

* `FileExists32`(<nom de fichier>)	voir <<opsi-winst-64bit,Chapter 64 Bit support>>

* `FileExists64`(<nom de fichier>)	voir <<opsi-winst-64bit,Chapter 64 Bit support>>

* `FileExistsSysNative`(<nom de fichier>) voir <<opsi-winst-64bit,Chapter 64 Bit support>>

* `LineExistsIn`(<ligne>, <nom de fichier>) +
Renvoie 'true' si le fichier texte désigné par <nom de fichier> contient une ligne tel que spécifié dans le premier paramètre, où chaque paramètre est une expression chaîne. Sinon (ou si le fichier n'existe pas) il renvoie 'false'.

* `LineBeginning_ExistsIn`(<chaîne>, <nom de fichier>)  +
Renvoie 'true' si il y a une ligne qui commence par <chaîne> dans le fichier texte désigné par <nom de fichier> (chaque paramètre étant une expression chaîne). Sinon (ou si le fichier n'existe pas) il renvoie 'false'.

* `XMLAddNamespace`(<nom de fichier XML>, <nom de l'élément XML>, <XMLnamespace>) +
insère une définition XML namespace dans le premier élément XML avec le nom donné (si non existant). Il restitue si une insertion a eu lieu. (La section patch XML de '{opsi-winst}' a besoin de la définition de namespace.) +
Le fichier doit être formaté comme une balise de l'élément sans de saut de ligne dedans.  
Pour un exemple, voir les recettes <<opsi-winst-cookbook-xmlnamespace>>. 

* `XMLRemoveNamespace`(<nom de fichier XML>, <nom de l'élément XML>, <XMLnamespace>)  +
supprime la définition XML namespace à partir de XML element. Il restitue si un retrait a eu lieu. Nous avons besoin de cela pour simuler que le fichier original reste inchangé. Pour un exemple, voir les recettes <<opsi-winst-cookbook-xmlnamespace>>.

* `HasMinimumSpace`(<Nom du disque>, <Capacité>) +
renvoie vrai si au moins une capacité reste sur le disque  <Nom du disque>.  <Capacité> ainsi que  <Nom du disque> syntaxiquement sont expressions de chaîne. La capacité peut être donné comme une chiffre sans spécification d'unité (ensuite interprété comme octets) ou avec les unité "kB", "MB", or "GB" (la casse est indépendante). +
Exemple:
[source,winst]
----
if not (HasMinimumSpace ("%SYSTEMDRIVE%", "500 MB"))
  LogError "Not enough space on %SystemDrive%, 500MB on drive %SystemDrive% needed"
  isFatalError
endif
----

* `opsiLicenseManagementEnabled` +
Renvoie 'true' si le module de gestion des licences opsi est activé.

* `runningAsAdmin` +
Renvoie 'true' si le script en cours d'exécution est exécuté depuis un compte administrateur.
Disponible depuis 4.11.1.1

* `isLoginScript` +
Renvoie 'true' si le script en cours d'exécution a été appelé comme 'userLoginScript' utilisant l'extension opsi 'Gestion des profils utilisateur'. +
Disponible depuis 4.11.2.1

* `contains(`<chaîne>, <sous-chaîne>`)` +
Fonction booléenne qui retourne 'true' si <chaîne> contient <sous-chaîne>. Cette fonction est sensible à la casse. +
Disponible depuis 4.11.3 

* `isNumber(`<chaîne>`)` +
Fonction booléenne qui retourne 'true' si <chaîne> représente un nombre entier. +
Disponible depuis 4.11.3


[[opsi-winst-commands-include]]
==== Commandes Include

CAUTION: L'utilisation des commandes Include peut conduire à la confusion du code. +
Utilisez avec prudence si vous êtes un débutant.

[[opsi-winst-commands-include-syntax]]
===== Commandes Include: Syntaxe

Les commandes `include_*` peuvent être utilisés pour ajouter des fichiers de script externes au script en cours d'exécution lors de son exécution. Les commandes `include_*` peuvent inclure des fichiers de script externes, soit sous forme d'encart (après la ligne en cours) ou comme un ajout (après la dernière ligne). Les commandes include peuvent être utilisés n'importe où dans une section primaire. Les fichiers de script externes peuvent contenir leurs propres commandes include. +
Disponible depuis 4.11.3

* `include_insert` <nom-du-fichier> +
insère <nom-du-fichier> après la ligne courante dans le script en cours d'exécution. Ainsi, la première ligne du fichier inclus est la ligne suivante qui sera exécutée par '{opsi-winst}'.

* `include_append` <nom-du-fichier> +
ajoute le contenu de <nom-du-fichier> au script actuellement exécuté. Ce type d'insertion est normalement utilisée pour inclure des sections d'une bibliothèque.

Dans les deux cas, <nom-du-fichier> est: +

* Un chemin d'accès complet à un fichier existant.

* Un fichier existant dans `%ScriptPath%`

* Un fichier dans `%opsiScriptHelperPath%\lib` +
Est équivalent à: '%ProgramFiles32Dir%\opsi.org\opsiScriptHelper\lib'

* Un fichier existant dans `%WinstDir%\lib`

Les tests pour la localisation du <nom-du-fichier> sont effectuées dans l'ordre ci-dessus. '{opsi-winst}' utilise le premier fichier qu'il trouve qui a un nom correspondant.

Exemple: +
Lorsque nous exécutons les commandes suivantes:
[source,winst]
----
[Actions]
include_append "section_Files_del_tmp_dummy.opsiinc"
include_insert "include-test1.opsiinc"
----

Le fichier `include-test1.opsiinc` est exécuté en premier.  Le contenu du fichier inclus `include-test1.opsiinc` est:
[source,winst]
----
DefVar $inctestvar$
set $inctestvar$ = "inctest"
Files_del_tmp_dummy
include_append "section_Files_copy_inctest.opsiinc"
Files_copy_inctest

if fileExists("c:\opsi.org\tmp\dummy.txt") 
	comment "passed"
else
	comment "failed"
	set $TestResult$ = "not o.k."
	LogWarning "include test failed"
endif

if fileExists("%scriptpath%\test-files\dummy.txt") 
	comment "passed"
else
	comment "failed"
	set $TestResult$ = "not o.k."
	LogWarning "include test failed"
endif
Files_del_tmp_dummy
----

Le contenu du fichier inclus `section_Files_copy_inctest.opsiinc` est:
[source,winst]
----
[Files_copy_inctest]
copy "%scriptpath%\test-files\dummy.txt" "c:\opsi.org\tmp"
----

Puisque l'appel à Files_del_tmp_dummy se passe dans `include-test1.opsiinc` sans que `section_Files_del_tmp_dummy.opsiinc` soit référencé à l'intérieur de `include-test1.opsiinc`, nous devons appeler include_append "section_Files_del_tmp_dummy.opsiinc" au tout début de notre script. Autrement, opsi-winst relèvera que Files_del_tmp_dummy n'est pas défini. +
Le contenu du fichier inclus `section_Files_del_tmp_dummy.opsiinc` est:
[source,winst]
----
[Files_del_tmp_dummy]
del -f "c:\opsi.org\tmp\dummyt.txt"
----

[[opsi-winst-commands-include-library]]
===== Commandes Include: Library

Les suivants fichiers include sont fourni avec la version 4.11.3, et sont situés dans `%WinstDir%\lib`:

`insert_check_exit_code.opsiinc`:
[source,winst]
----
; opsi include file

DefVar $ExitCode$

include_append "section_sub_check_exitcode.opsiinc"
----

`insert_get_licensekey.opsiinc`:
[source,winst]
----
; opsi include file

DefVar $LicenseRequired$
DefVar $LicenseKey$
DefVar $LicensePool$

include_append "section_sub_get_licensekey.opsiinc"
----

`section_sub_check_exit_code.opsiinc`:
[source,winst]
----
;opsi include file

[Sub_check_exitcode]
comment "Test for installation success via exit code"
set $ExitCode$ = getLastExitCode
; informations to exit codes see
; http://msdn.microsoft.com/en-us/library/aa372835(VS.85).aspx
; http://msdn.microsoft.com/en-us/library/aa368542.aspx
if ($ExitCode$ = "0")
	comment "Looks good: setup program gives exitcode zero"
else
	comment "Setup program gives a exitcode unequal zero: " + $ExitCode$
	if ($ExitCode$ = "1605")
		comment "ERROR_UNKNOWN_PRODUCT	1605	This action is only valid for products that are currently installed."
		comment "Uninstall of a not installed product failed - no problem"
	else
		if ($ExitCode$ = "1641")
			comment "looks good: setup program gives exitcode 1641"
			comment "ERROR_SUCCESS_REBOOT_INITIATED	1641	The installer has initiated a restart. This message is indicative of a success."
			ExitWindows /Reboot
		else
			if ($ExitCode$ = "3010")
				comment "looks good: setup program gives exitcode 3010"
				comment "ERROR_SUCCESS_REBOOT_REQUIRED	3010	A restart is required to complete the install. This message is indicative of a success."
				ExitWindows /Reboot
			else
				logError "Fatal: Setup program gives an unknown exitcode unequal zero: " + $ExitCode$
				isFatalError "Exit Code: "+ $ExitCode$
			endif
		endif
	endif
endif
----

`section_sub_get_licensekey.opsiinc`:
[source,winst]
----
; opsi include file

[Sub_get_licensekey]
if opsiLicenseManagementEnabled
	comment "License management is enabled and will be used"

	comment "Trying to get a license key"
	Set $LicenseKey$ = demandLicenseKey ($LicensePool$)
	; If there is an assignment of exactly one license pool to the product the following call is possible:
	; Set $LicenseKey$ = demandLicenseKey ("", $ProductId$)
	;
	; If there is an assignment of a license pool to a windows software id, it is possible to use:
	; DefVar $WindowsSoftwareId$
	; $WindowsSoftwareId$ = "..."
	; Set $LicenseKey$ = demandLicenseKey ("", "", $WindowsSoftwareId$)
	
	DefVar $ServiceErrorClass$
	set $ServiceErrorClass$ = getLastServiceErrorClass
	comment "Error class: " + $ServiceErrorClass$
	
	if $ServiceErrorClass$ = "None"
		comment "Everything fine, we got the license key '" + $LicenseKey$ + "'"
	else
		if $ServiceErrorClass$ = "LicenseConfigurationError"
			LogError "Fatal: license configuration must be corrected"
			LogError getLastServiceErrorMessage
			isFatalError $ServiceErrorClass$
		else 
			if $ServiceErrorClass$ = "LicenseMissingError"
				LogError "Fatal: required license is not supplied"
				isFatalError $ServiceErrorClass$
			endif
		endif
	endif
else
	LogError "Fatal: license required, but license management not enabled"
	isFatalError "No Licensemanagement"
endif
----

[[opsi-winst-commands-subcall]]
=== Appels de Sous-programme

Les déclarations dans les sections primaires qui désignent des instructions déclaré ailleurs sont des appels de sous-programme.,

[source,winst]
----
if ($MSVersion$ >= "6")
     sub_install_win7
else
  if ( $MSVersion$ = "5.1" )
    sub_install_winXP
  else
    stop "not a supported OS-Version"
  endif
endif
----
Dans cet exemple la déclaration:
[source,winst]
----
sub_install_winXP
----
"appelle" la section intitulée [sub_install_winXP] qui est placé quelque part ailleurs dans le script. Par exemple nous pouvons avoir
[source,winst]
----
[sub_install_winXP]
Files_copy_XP
WinBatch_SetupXP
----

Généralement, Il y a trois façons de placer les instructions mentionnées:

* La cible la plus courante d'un appel de sous-programme est une autre section interne dans le fichier de script où la déclaration d'appel est placé (comme dans l'exemple).

* Nous pouvons mettre les instructions mentionnées dans un autre fichier servant de section externe.

* Toute liste de chaînes peuvent être utilisés comme liste d'instructions pour un appel de sous-programme.

Nous décrivons la syntaxe des appels de sous-programme dans le détail:

[[opsi-winst-commands-subcall-components]]
==== Syntaxe de procédure d'appel

Formellement, la syntaxe peut être donnée par +
'<type de proc.>(<nom de proc.> | <Fichier Extern de proc.> | <Fonction de liste de chaînes> )'

Cette expression peut être complétée par un ou plusieurs paramètres (dépendant du type de procédure). 

Cela signifie que: Un appel de procédure se compose de trois parties principales.

La première partie est le spécificateur de type de sous-programme. +
Exemples de noms de type sont 'Sub' (nous appelons une procédure de type 'sub' qui est à nouveau une section primaire) ou 'Files' et 'WinBatch' (appels des sections secondaires spéciales). La vue d'ensemble complète des types de sous-programme existants figure à <<opsi-winst-commands-subcall>>.

La deuxième partie détermine où et comment on trouve les lignes de sous-programme.

. Le sous-programme est une séquence de lignes situées dans le script '{opsi-winst}' en exécution, comme une autre section interne. Puis un nom (constitué à partir de lettres, de chiffres et de caractères spéciaux) doit être ajouté au spécificateur de type (sans espaces) afin de former un nom de section unique. +
`sub_install_winXP` +
ou +
`files_copy_winXP` +
Section names sont indépendentes de la casse comme toute autre chaîne. 

. Si le spécificateur de type est unique, une expression de liste de chaînes ou une expression de chaîne est attendue. Si l'expression suivant le spécificateur de type ne peut pas être résolue comme un'expression de liste de chaînes (voir case (3)) il est supposé être une expression chaîne. La chaîne est alors interprétée comme un nom de fichier. '{opsi-winst}' essaie d'ouvrir le fichier comme un fichier texte et interprète ses lignes comme une section externe du type spécifié. +
Par exemple: +
`sub "p:\install\opsiutils\mainroutine.ins"`
essaie d'exécuter les lignes de mainroutine.ins comme des déclarations d'une sous-section. 

. Si l'expression suivant le spécificateur de type de section pure est résoluble comme une expression liste de chaîne les lignes de la liste sont interprétés comme des déclarations de la section. +
Ce mécanisme peut par exemple être utilisés pour charger un fichier au format Unicode et ensuite la traiter par les mécanismes habituels
[source,winst]
----
registry loadUnicodeTextFile("%scriptpath%/opsiorgkey.reg") /regedit
----

Syntaxiquement, cette ligne est composée de trois parties principales: +
* `registry`, la déclaration coeur, spécifiant le type de section, +
* `loadUnicodeTextFile(...)`, une expression de liste de chaînes spécifiant la façon d'obtenir les lignes d'une section registre respectivement son substitut. +
* `/regedit`, paramétrage de l'appel de registre. 

Dans cet exemple, le paramètre d'appel donne déjà un exemple pour la troisième partie d'un appel desous-section:

La troisième partie d'une procédure d'appel comprend les options d'appel spécifique du type. 

Pour une référence des options d'appel voir les descriptions des appels de section dans <<opsi-winst-secsections>>.

[[opsi-winst-commands-reboot]]
=== Contrôle du redémarrage

La commande `ExitWindows` est utilisé pour contrôler le redémarrage, l'arrêt et des actions similaires qui devrait se dérouler après la fin de l'exécution de '{opsi-winst}'. Le nom de la commande et le fait qu'il n'y ait pas de 'ExitWindows' sans modificateur a des raisons historiques: Dans Windows 3.1 vous pourriez quitter Windows pour revenir au niveau DOS.

* `ExitWindows /RebootWanted` +
DEPRECATED: une demande de redémarrage est enregistré qui devrait être exécutée lorsque toutes les demandes d'installations sont traitées, et le dernier script est terminé. +
En fait, cette commande est maintenant traitée comme un `ExitWindows /Reboot` (car sinon une installation pourrait échouer parce qu'un produit nécessaire n'est pas encore complètement installé).

* `ExitWindows /Reboot` +
déclenche le redémarrage après que '{opsi-winst}' a terminé le script actuellement traités.

* `ExitWindows /ImmediateReboot` +
brise l'exécution normale d'un script n'importe où dedans. Lorsque cette commande est appelée '{opsi-winst}' s'exécute aussi directement que possible jusqu'au bout entraînant l'appel système ExitWindows. Dans le contexte d'un opsi-client-agent installé il est garanti que après le redémarrage '{opsi-winst}' s'exécute à nouveau dans le script qui a avorté. Par conséquent, le script doit prendre des dispositions que l'exécution continue après le point où elle a été laissée la fois avant (sinon on peut obtenir une boucle infinie ...) Voir l'exemple dans cette section.

* `ExitWindows /ImmediateLogout` +
L'exécution normale d'un script se coupe au point de l'appel, et '{opsi-winst}' s'arrête. Ce comportement est nécessaire si une connexion automatisé doit avoir lieu pour un utilisateur (voir <<opsi-winst-cookbook-local-admin>>).

* `ExitWindows /ShutdownWanted` +
positionne un drapeau dans le registre que le PC s'éteint lorsque toutes les demandes d'installations sont traitées, et le dernier script est terminé. 

Par le fragment de code suivant nous démontrons la manière dont des drapeaux peuvent être définis pour s'assurer que le script ne s'exécute pas dans une boucle infinie lorsque l'on appelle `ExitWindows /ImmediateReboot`:
[source,winst]
----
DefVar $OS$
DefVar $Flag$
DefVar $WinstRegKey$
DefVar $RebootRegVar$

set $OS$=EnvVar("OS")

if $OS$="Windows_NT"
   
  Set $WinstRegKey$ = "HKLM\SOFTWARE\opsi.org\winst"
  Set $Flag$ = GetRegistryStringValue("["+$WinstRegKey$+"] "+"RebootFlag")

  if not ($Flag$ = "1")
     ;========================= 
     ; Statements BEFORE Reboot 

     Files_doSomething    

     ; initialize reboot ...
     Set $Flag$ = "1"
     Registry_SaveRebootFlag
     ExitWindows /ImmediateReboot

  else 
     ;========================= 
     ; Statements AFTER Reboot

     ; set back reboot flag
     Set $Flag$ = "0"
     Registry_SaveRebootFlag

     ; the work part after reboot:

     Files_doMore

  endif

endif   


[Registry_SaveRebootFlag]
openKey [$WinstRegKey$]
set "RebootFlag" = "$Flag$"

[Files_doSomething]
; une section exécutée avant le redémarrage 

[Files_doMore]
; une section exécutée après le redémarrage
----

[[opsi-winst-commands-isfatalerror]]
=== Garder la trace des installations qui ont échoué

Si une installation de produit échoue cela devrait être signalé au serveur.

Selon le fait qu'il n'y a pas d'automatisme pour détecter une installation qui a échoué cela doit être fait par les commandes du script. 

Pour indiquer dans un script '{opsi-winst}' que l'installation a échoué nous devons appeler la déclaration: +
`isFatalError` +
Si cette déclaration est appelé '{opsi-winst}' arrête l'exécution normale du script et définit le résultat du produit à 'failed' (sinon, il est à 'success'). +

Depuis la version 4.11.3.2 il existe une nouvelle variante de cette commande:

* `isFatalError` <chaîne> +
dans ce cas, une courte chaîne de message d'erreur est passé comme 'actionProgress' au {opsi-server} et affiché dans {opsi-configed}.

Par exemple, une "erreur fatale" doit être déclenchée s'il n'y a pas beaucoup d'espace disque libre nécessaire pour une installation: 
[source,winst]
----
DefVar $SpaceNeeded$"
Set $SpaceNeeded$" = "200 MB"

DefVar $LogErrorMessage$ 
Set $LogErrorMessage$ = "Not enough space on drive . Required " 
Set $LogErrorMessage$ = $LogErrorMessage$ + $SpaceNeeded$" 

if not(HasMinimumSpace ("%SYSTEMDRIVE%", $SpaceNeeded$))
  LogError $LogErrorMessage$
  isFatalError
  ; finish execution and set ProductState to failed

 else
  ; we start the installation 
  ; ...
 endif
----

Il est aussi possible d'indiquer +
`isFatalError` +
selon le nombre d'erreurs qui sont survenues dans une partie critique d'un script d'installation. Pour ce faire, on initialise le compteur d'erreur par la commande +
* `markErrorNumber` +
Le nombre d'erreurs d'exécution qui se produisent après le réglage du compteur peut être interrogé par la fonction +
* `errorsOccuredSinceMark` +
Nous pouvons évaluer le résultat dans une condition de comparaison numérique (que n'est encore mis en œuvre pour cette expression). Par exemple, on peut indiquer: +
* `if errorsOccuredSinceMark > 0` +
et, si cela semble logique, indiquer ensuite: +
`isFatalError` +
Pour augmenter le nombre d'erreurs compté en fonction de certaines circonstances (qui ne produisent pas directement d'erreur) nous pouvons utiliser la déclaration `logError`. 

Nous pouvons le tester avec le script de l'exemple suivant:
[source,winst]
----
markErrorNumber
; Les erreurs survenant après cette marque sont comptés and 
; et seront éventuellement considérés comme fatales

logError "test error"
; nous écrivons "test error" dans le journal système
; et augmentons le nombre d'erreurs de 1
; pour les tests, commentez cette ligne 


if errorsOccuredSinceMark > 0
    ; nous terminons l'exécution du script le plus rapidement possible
    ; et nous mettons, l'état du produit à "failed"

    isFatalError
    ; mais l'écriture des commentaires n'est pas arrêté 

    comment "error occured"

else
    ; aucune erreur n'est survenue, nous allons journaliser ceci:

    comment "no error occured"
endif
----

[[opsi-winst-secsections]]
== Sections Secondaires

Les sections secondaires peuvent être appelés depuis n'importe quelle section primaire mais elles ont une syntaxe différente. La syntaxe est dérivé des exigences fonctionnelles, des conditions de la bibliothèque et des conventions pour les besoins spécifiques. Donc à partir d'une section secondaire, aucune autre section peut être appelée.

Les sections secondaires sont spécifiques à chaque zone fonctionnelle. Il s'agit de l'objet de la fonctionnalité, par exemple le système de fichier en général, le registre de Windows, ou les fichiers XML. Mais il se réfère encore plus au dispositif qui est appliquée en interne. Cela peut être démontré par les variantes des sections batch (qui appellent des programmes ou des scripts externes). 

Le contexte fonctionnel est reflété dans la syntaxe spécifique du type de section particulière. 

[[opsi-winst-files]]
=== Les sections Files (Fichiers)

Une section Fichiers propose principalement des fonctions qui correspondent aux commandes de copie du système d'exploitation sous-jacent. La plus-value lorsque vous utilisez les commandes '{opsi-winst}' est la journalisation détaillée et la vérification de toutes les opérations si nécessaire. Si vous le souhaitez l'écrasement des fichiers peut être interdit si des nouvelles versions d'un fichier (par exemple un nouveau fichier dll) sont déjà installés sur le système. 

[[opsi-winst-files-example]]
==== Exemple 

Une simple section Files pourrait être:

[source,winst]
----
[Files_do_some_copying]
copy -sV "p:\install\instnsc\netscape\*.*" "C:\netscape"
copy -sV "p:\install\instnsc\windows\*.*" "%SYSTEMROOT%"
----

Ces commandes font en sorte que tous les fichiers du répertoire
 'p:\install\instnsc\netscape' sont copiés dans le répertoire `C:\netscape`, et ensuite tous les fichiers de `p:\install\instnsc\windows` dans le répertoire système de Windows (sa valeur est automatiquement inséré dans la constante `%SYSTEMROOT%`).
L'option `-s` signifie que tous les sous-répertoires sont aussi bien copiés, `-V` active le contrôle de version pour les fichiers de la bibliothèque.

[[opsi-winst-files-params]]
==== Modificateur

Dans la plupart des cas, une section Files sera appelé sans paramètres.

Il y a seulement quelques utilisations spéciales d'une section Files où la cible d'actions de copie est défini ou modifié d'une certaine manière spécifiée. Nous avons obtenu les deux paramètres optionnels

* `/AllNTUserProfiles` ou
* `/AllNTUserSendTo`

Les deux variantes signifient: +
La section Files appelée est exécuté une fois pour chaque utilisateur local Windows NT.
Chaque commande de copie dans la section est associée à un répertoire d'utilisateurs spécifiques. 

Dans d'autres cas nous avons besoin de construire d'autres noms de chemins spécifiques aux utilisateurs, alors nous pouvons utiliser la variable, définie automatiquement, `%UserProfileDir%` ou `%CurrentProfileDir%` depuis la version 4.11.2 de '{opsi-winst}'. 
Avec l'option `/AllNTUserProfiles` le répertoire cible spécifique aux utilisateurs pour les tâches de copie, est le répertoire du profil utilisateur (qui est habituellement désigné par le nom de l'utilisateur et est située par défaut comme un sous-répertoire du répertoire userappdata. En cas d'option `/AllNTUserSendTo` le répertoire cible est le chemin du dossier utilisateur spécifique 'SendTo' (pour les liens du menu contextuel de l'explorateur de Windows).

La règle exacte pour déterminer le chemin cible pour une commande de copie, comporte trois parties:

. Si seulement la source d'une action de copie est spécifié, les fichiers sont copiés directement dans le répertoire cible de l'utilisateur. Nous avons la syntaxe +
`copy <fichier(s) source>` +
Elle sera équivalente +
`copy <fichier(s) source> "%UserProfileDir%"`
ou depuis 4.11.2 +
`copy <fichier(s) source> "%CurrentProfileDir%"`


. Si un targetdir est spécifié et targetdir est une description de chemin relatif (commencent ni avec un nom de lecteur, ni un anti-slash) alors targetdir est le nom d'un sous-répertoire du répertoire spécifique de l'utilisateur. Par exemple +
`copy <fichier(s) source> <targetdir>` +
est interprété comme: +
`copy <fichier(s) source> "%UserProfileDir%\targetdir"`
ou depuis 4.11.2 +
`copy <fichier(s) source> "%CurrentProfileDir%\targetdir"`

L'usage de `%CurrentProfileDir%` a l'avantage que vous pouvez avoir la même section 'Files' avec `/AllNTUserProfiles` si elle ne s'èxecute pas comme 'userLoginScript' (dans le mode 'Machine' du script) et sans `/AllNTUserProfiles` si elle s'exécute comme 'userLoginScript' (dans le mode 'Login' du script).


. Si targetdir est un chemin absolu il est utilisé comme chemin cible statique de l'action de copie.

Il y a aussi les options:

* `/32Bit`
* `/64Bit`
* `/SysNative`

qui manipulent les 'file redirection' sur les systèmes 64 bits. 
Pour plus de détails, voir <<opsi-winst-64bit>>
 
==== Commandes

Dans une section Files sont définies les commandes suivantes:

* `Copy`

* `Delete`

* `del`

* `SourcePath`

* `CheckTargetPath`

`Copy` et `Delete` correspondent grosso modo aux commandes shell Windows xcopy et del. 

`SourcePath` et `CheckTargetPath` definissent l'origine et la destination des actions à venir de copie (comme si nous allions ouvrir deux fenêtres d'explorateur pour les tâches de copie entre eux). Si le chemin cible n'existe pas il sera créé.


Les définitions de syntaxe sont: 

* `Copy` [-svdunxwnr] <source(masque)> <chemin cible>
+ 
Les fichiers source peuvent être désigné explicitement, en utilisant le caractere joker (”* ”) ou par un nom de répertoire.  
+
CAUTION: Le <chemin cible> est toujours entendue comme un nom de répertoire. Renommer en copiant n'est pas possible. Si le chemin cible n'existe pas il sera créé (cas échéant, une hiérarchie de répertoires). 
+
Les modificateurs optionnels de la commande Copy signifient (l'ordre est insignifiante): 

** `s` -> récursif dans les sous-répertoires.

** `e` -> sous-répertoires vides. +
S'il y a des sous-répertoires vides dans le chemin source ils seront créés aussi bien dans le répertoire cible.

** `V` -> vérification de version +
Une nouvelle version d'un fichier de bibliothèque de Windows n'est pas écrasée par un ancien (conformément principalement au numero de version interne du fichier). S'il y a des doutes quant à la priorité des fichiers un avertissement est ajouté au fichier journal système.

** `v` -> (Ne pas utiliser) +
Avec le contrôle de version: +
Obsolète: Ne pas utiliser sur des systèmes supérieurs à win2k. Parce qu'il vérifie non seulement le répertoire cible, mais aussi %System%.
utiliser `-V` à la place.

** `d` -> Avec vérification de la date: +
Un nouveau fichier .exe n'est pas écrasé par un ancien. 

** `u` -> seulement mise à jour des fichiers: +
Un fichier n'est pas copié s'il y a un nouveau fichier ou tout aussi un ancien du même nom. 

** `x` -> extraire +
Si un fichier est une archive zip, il sera déballé (extrait) à la copie. +
Attention: Les archives zip ne sont pas caractérisés par leur nom mais par une définition interne. Par exemple un fichier jar java est un fichier zip. S'il est déballé l'appel à application ne fonctionnera pas.

** `w` -> faible +
Respectons toutes protections en écriture d'un fichier avec une procédure "sans force" (au contraire du comportement par défaut qui est d'essayer d'utiliser les privilèges d'administrateur et d'écraser un fichier protégé en écriture).

** `n` -> ne pas écraser +
Les fichiers existants ne sont pas écrasés. 

** `c` -> continue +
Si un système de fichier est utilisé, alors il peut être remplacé seulement après un redémarrage. Le comportement par défaut de '{opsi-winst}' est donc que les fichiers en cours d'utilisation seront marqués pour écrasement au prochain réamorçage, ET l'indicateur de redémarrage de '{opsi-winst}' est défini. Le réglage du modificateur de copy à "-c" desactive le redémarrage automatique. Au lieu, le traitement normal se poursuit, la copie sera terminée que lorsque le redémarrage est par ailleurs déclenché.

** `r` -> attribut de lecture seule +
Si un fichier copié a un attribut de lecture seule il est mis de nouveau (au contraire du comportement par défaut qui est d'éliminer les attributs de lecture seule). 

* `Delete` [-sfd[n]] <chemin>

ou

* `Delete` [-sfd[n]] <source(masque)>
+
supprime les fichiers et les répertoires. 

Les options possibles sont (avec un ordre arbitraire)

** `s` -> sous-répertoires +
récursivement dans les sous-répertoires. Tout ce qui correspond au nom du chemin ou au masque source est supprimé. 
+
CAUTION: La commande +
`delete -s c:\opsi` +
Ne veut pas dire: supprimer le répertoire 'c:\opsi' recursivement, mais cela signifie: supprimer à partir de 'c:\' toutes les occurrences de 'opsi'. Cela peut conduire à une analyse complète du disque dur. +
Si vous voulez supprimer recursivement le répertoire 'c:\opsi' utilisez la commande: +
`delete -s c:\opsi\` +
en utilisant une barre oblique inverse vous définissez que 'opsi' est un répertoire. +
*Il est plus sûr d'utiliser la commande `del` plutôt.*

** `f` -> force +
force à supprimer les fichiers en lecture seule 

** `d [n]` -> date +
Seuls les fichiers d'âge n jours ou plus sont supprimés. n par défaut à 1.

* `del` [Options] <chemin[/masque]]   //depuis 4.11.2.1 +
Fonctionne comme `delete` mais à +
`del -s -f c:\not-exists` +
Si +c:\not-exists+ n'existe pas, ne sera pas faite une recherche complète dans +c:\+ pour +not-exits+  

Exemple (*vous pouvez oublier la barre oblique inverse*): +
`del -sf c:\delete_this_dir`


* `SourcePath` = < répertoire source > +
Définit <répertoire source> comme répertoire par défaut pour les commandes suivantes `Copy` et (!) `Delete`.

* `CheckTargetPath` = <répertoire cible> +
Définit <répertoire cible> comme répertoire par défaut pour la commande `Copy`. Si le chemin spécifié n'existe pas il sera créé.

[[opsi-winst-patches]]
=== Sections Patches 

Une section Patches modifie un fichier de propriétés au format de fichier ini. À savoir un fichier qui se compose des sections qui sont une séquence des entrées construites en tant que paramètres '<variable> = <valeur>'. Où les sections sont caractérisées par titres qui sont des noms entre parenthèses, comme '[nom_de_section]'. 

[[opsi-winst-patches-examples]]
==== Exemple

[source,winst]
----
Patches_DUMMY.INI $HomeTestFiles$+"\dummy.ini"

[Patches_dummy.ini]
add [secdummy] dummy1=add1
add [secdummy] dummy2=add2
add [secdummy] dummy3=add3
add [secdummy] dummy4=add4
add [secdummy] dummy5=add5
add [secdummy] dummy6=add6
set [secdummy] dummy2=set1
addnew [secdummy] dummy1=addnew1
change [secdummy] dummy3=change1
del [secdummy] dummy4
Replace dummy6=add6 replace1=replace1
----

entraîne le journal système suivant:
[source,winst]
----
Execution of Patches_DUMMY.INI
      FILE C:\tmp\testFiles\dummy.ini
      Info: This file does not exist and will be created 
  addEntry [secdummy] dummy1=add1
    addSection [secdummy]
      done
      done
  addEntry [secdummy] dummy2=add2
      done
  addEntry [secdummy] dummy3=add3
      done
  addEntry [secdummy] dummy4=add4
      done
  addEntry [secdummy] dummy5=add5
      done
  addEntry [secdummy] dummy6=add6
      done
  setEntry [secdummy] dummy2=set1
    Entry      dummy2=add2
    changed to dummy2=set1
  addNewEntry [secdummy] dummy1=addnew1
    appended entry
  changeEntry [secdummy] dummy3=change1
    entry      dummy3=add3
    changed to dummy3=change1
  delEntry [secdummy] dummy4
    in section secdummy deleted  dummy4=add4
  replaceEntrydummy6=add6 replace1=replace1
    replaced in line 7
  C:\tmp\testFiles\dummy.ini saved back
----

Pour plus d'exemples, s'il vous plaît vérifier le produit standard OPSI 'opsi-script-test' et dans ce produit la partie '$Flag_winst_patches$ = "on"'

[[opsi-winst-patches-params]]
==== Paramètre d'appelle

Le nom du fichier à patcher est spécifié comme paramètre de l'appel.

Il y a des modificateurs facultatifs:

* `/AllNTUserProfiles` +
Si une section patch est appelé avec ce modificateur, alors tous les sous-répertoires `%UserProfileDir%` seront patchés, ce qui signifie que ce patch est effectué pour tous les profils d'utilisateurs. +
Quand un 'Patches' est appelée dans une section `[ProfileActions]`, alors le modificateur `/AllNTUserProfiles` est implicite. Dans le mode logscript, `%UserProfileDir%` sera interprété comme `%CurrentProfileDir%`. +
(Depuis la version 4.11.3.2)

[[opsi-winst-patches-commands]]
==== Commandes

Pour une section Patches, nous avons les commandes:

* `add`

* `set`

* `addnew`

* `change`

* `del`

* `delsec`

* `replace`

Chaque commande fait référence à une certaine section du fichier qui doit être patché. Le nom de cette section est précisé entre parenthèses `[ ]` (qui ne veut pas dire ici "syntaxe optionnelle"!!).

En détail: 

* `add [`<nom de la section>`]` <variable1> `=` <valeur1> +
Cette commande ajoute une entrée de type <variable1> = <valeur1> à la section <nom de la section> s'il n'y a pas encore d'entrée pour <variable1> dans cette section. Sinon rien n'est écrit. Si la section n'existe pas elle sera créée.

* `set [`<nom de la section>`]`<variable1> `=` <valeur1> +
S'il n'y a pas d'entrée pour <variable1> dans la section <nom de la section> le paramètre <variable1> = <valeur1> est ajoutée. Sinon, la première entrée  <variable1> = <valeurX> est changé en <variable1> = <valeur1>. 

* `addnew [`<nom de la section>`]`<variable1> `=` <valeur1> +
Peu importe s'il y a une entrée pour <variable1> dans la section <nom de la section> le paramètre <variable1> = <valeur1> est ajoutée. 

* `change [`<nom de la section>`]`<variable1> `=` <valeur1> +
Seulement s'il ya une entrée pour <variable1> dans la 
section <nom de la section> elle est changée en <variable1> = <valeur1>. 

* `del [`<nom de la section>`]` <variable1> `=` <valeur1> +
respectivement +
`del [`<nom de la section>`]` <variable1> +
supprime toutes les entrées <variable1> = <valeur1> respectivement toutes les entrées pour <variable1> dans la section <section name>. 

* `delsec [`<nom de la section>`]` +
supprime la section <section name>.

* `replace` <variable1>`=`<valeur1> <variable2>`=`<valeur2> +
signifie que <variable1> = <valeur1> sera remplacé par <variable2> = <valeur2> dans toutes les sections du fichier ini. Il ne doit pas y avoir aucun espace dans la valeur ou autour du signe égal.  

[[opsi-winst-patchhosts]]
=== Sections PatchHosts

En vertu d'une section PatchHosts nous sommes en mesure de modifier un fichier hosts qui est n'importe quel fichier avec des lignes ayant le format +
'adresseIP	nom Hôte aliases  # commentaires'

'Aliases' et 'commentaires' (et le séparateur de commentaires #) sont optionnels. Une ligne peut également être une ligne de commentaire commençant par # .

Le fichier qui doit être modifié peut être donnée comme paramètre d'un appel 'PatchHosts'. S'il n'y a aucun paramètre un fichier nommé `HOSTS` est recherché dans les répertoires `c:\nfs`, `c:\windows` et `%systemroot%\system32\drivers\etc`. Si aucun fichier n'est trouvée l'appel 'PatchHosts' termine avec une erreur.

Dans une section PatchHosts il y a des commandes définies: 

* `setAddr`

* `setName`

* `setAlias`

* `delAlias`

* `delHost`

* `setComment`


Exemple:
[source,winst]
----
PatchHosts_add $HomeTestFiles$+"\hosts"

[PatchHosts_add]
setAddr ServerNo1 111.111.111.111
setName 222.222.222.222 ServerNo2
setAlias ServerNo1 myServerNo1
setAlias 222.222.222.222 myServerNo2
setComment myServerNo2 Hallo Welt
----

entraîne le journal système suivant:
[source,winst]
----
Execution of PatchHosts_add
   FILE C:\tmp\testFiles\hosts
  Set ipAddress 111.111.111.111 Hostname "ServerNo1"
  Set Hostname "ServerNo2" for ipAddress 222.222.222.222
  Alias "myServerNo1" set for entry "ServerNo1"
  Alias "myServerNo2" set for entry "222.222.222.222"
  SetComment of Host "myServerNo2" to "Hallo Welt"
  C:\tmp\testFiles\hosts saved back
----

Pour plus d'exemples, s'il vous plaît vérifier le produit standard OPSI 'opsi-script-test' et dans ce produit la partie '$Flag_winst_patch_hosts$ = "on"'.

En détail: 

* `setaddr` <nom d'hôte> <Adresse ip> +
définit l'adresse IP pour l'hôte <nom d'hôte> à <Adresse ip>. S'il n'y a pas d'entrée pour le nom d'hôte il sera créé. 

* `setname` <ipaddresse> <nom d'hôte> +
définit le nom d'hôte pour l'adresse IP donnée. S'il n'y a pas d'entrée pour l'Adresse IP il sera créé.

* `setalias` <nom d'hôte> <alias> +
ajoute un alias pour l'hôte nommé <nom d'hôte>.

* `setalias` <Adresse ip> <alias> +
ajoute un nom d'alias pour l'hôte avec Adresse ip <Adresse ip>.

* `delalias` <nom d'hôte> <alias> +
supprime le nom d'alias <alias> pour l'hôte nommé <nom d'hôte> .

* `delalias` <Adresse ip> <alias> +
supprime le nom d'alias <alias> pour l'hôte avec Adresse ip <Adresse ip>.

* `delhost` <nom d'hôte>
supprime l'entrée complète de l'hôte avec le nom <nom d'hôte>.

* `delhost` <Adresse ip> +
supprime l'entrée complète de l'hôte avec l'Adresse ip <Adresse ip>. 

* `setComment` <identité> <commentaire> +
écrit <commentaire> après le signe de commentaire pour l'hôte avec le nom d'hôte, Adresse ip ou nom d'alias <identité>.

[[opsi-winst-idapi]]
=== Sections IdapiConfig

Les sections IdapiConfig ont été conçues pour écrire des paramètres dans les fichiers idapi*.cfg qui sont utilisés par les Borland Database Engine.

Ce type de sections ne sont plus supporté.

[[opsi-winst-patchtextfile]]
=== Sections PatchTextFile

Une section PatchTextFile offre une variété d'options pour patcher les fichiers de configuration quelconque qui sont donnés sous forme de fichiers texte ordinaire (à savoir qu'ils peuvent être traités ligne par ligne).

Un outil indispensable pour travailler sur des fichiers texte est vérifier si une ligne spécifique est contenue dans un fichier donné. A cet effet, nous disposons des fonctions booléennes `Line_ExistsIn` et `LineBeginning_ExistsIn` (voir <<opsi-winst-commands-if-else-bool-functions>>).

[[opsi-winst-patchtextfile-params]]
==== Paramètre

Le fichier texte à traiter est donné en paramètre.

Les modificateurs optionnels sont:

* `/AllNTUserProfiles` +
Si une section 'PatchTextFile' est appelée avec ce modificateur et le chemin du fichier à patcher contient la constante `%UserProfileDir%`, la section patch sera exécutée pour tous les profils. +
Pour une section 'PatchTextFile', qui est appelé à partir d'une section `[ProfileActions]` dans le mode 'Machine', le modificateur `/AllNTUserProfiles` est implicite. Dans le mode 'Loginscript', `%UserProfileDir%` est interprété comme `%CurrentProfileDir%`. +
(depuis la version 4.11.3.5)


[[opsi-winst-patchtextfile-commands]]
==== Commandes

Nous disposons de deux commandes en particulier pour patcher les fichiers des préférences de Mozilla, plus les deux obsolète et plus restreint anciennes versions de ces commandes:

* `Set_Mozilla_Pref` ("<type de préférence>", "<clé de préférence>", "<valeur de préférence>") +
fixer pour <type de préférence> la valeur associée à "<preference variable>" à "<valeur de préférence>". +
Dans les fichiers de préférences actuelles de Mozilla il y a des expressions comme +
'user_pref("<clé>", "<valeur>") +
pref("<clé>", "<valeur>") +
lock_pref("<clé>", "<valeur>")' +
Chacun d'entre eux, en fait, tout appel de fonction (javascript) de la forme +
'functionname (chaîne1, chaîne2)' +
peut être patché avec cette commande en définissant la chaîne appropriée pour <type de préférence> (qui est, respectivement pour functionname),
Si une entrée commençant par "functionname (chaîne1)" existe dans le fichier traité, il sera patché (et laissé à sa place). Sinon une nouvelle ligne sera ajoutée.
Exceptionnellement dans '{opsi-winst}', toutes les chaînes sont sensibles à la casse.

* `Set_Netscape_User_Pref` ("<preference variable>", "<valeur>") +
fixe la ligne du fichier de préférences de l'utilisateur spécifié pour la variable <preference variable> à la valeur <valeur>. L'ordre ASCII du fichier sera reconstruit. +
(Obsolète!)

* `AddStringListElement_To_Mozilla_Pref ("<type de préférence>", "<preference variable>", "<valeur à ajouter>")` +
ajoute un élément à une entrée de liste dans le fichier de préférence donné. Il est vérifié si la valeur qui devrait être ajouté est déjà contenue dans la liste (alors il ne sera pas ajouté). 

* `AddStringListElement_To_Netscape_User_Pref ("<preference variable>", "<valeur à ajouter dans la liste>")` +
 (Obsolète!)
 
Les autres commandes d'une section 'PatchTextFile' ne sont pas de type de fichier spécifique. Toutes les opérations sont basées sur le concept que un pointeur de ligne existe et peut être déplacé du début du fichier par exemple dessus de la ligne du haut vers le bas (ligne).

Il y a trois commandes pour effectuer des recherches:

* `FindLine <chaîne de recherche>`
* `FindLine_StartingWith <chaîne de recherche>`
* `FindLine_Containing <chaîne de recherche>`

Chaque commande commence à chercher à la position courante du pointeur de la ligne. S'ils trouvent une ligne correspondant, le pointeur de la ligne il est déplacé vers. Sinon, le pointeur de la ligne conserve sa position. 

<chaîne de recherche> - comme toutes les autres références de chaîne dans les commandes suivantes - elles sont entourée par des guillemets simples ou doubles.

* `GoToTop` +
déplacer le pointeur à la ligne du sommet.

(quand nous comptons les lignes il faut noter que cette commande déplace le pointeur de la ligne dessus de la ligne supérieure).
Nous intervenons à n'importe quel numéro de ligne - positive ou négative - dans le fichier avec

* `AdvanceLine [nombre de lignes]` +
déplacer le pointeur de ligne à [nombre de lignes] lignes en avant ou en arrière.

* `GoToBottom` +
Avance jusqu'à la dernière ligne

Avec la commande suivante :

* `DeleteTheLine` +
nous supprimons la ligne à laquelle le pointeur de ligne est dirigé, s'il y a une telle ligne (si le pointeur de ligne est au sommet, rien n'est supprimé)

* `DeleteAllLines_StartingWith <chaîne de recherche>` +
supprimer toutes les lignes qui commencent par <chaîne de recherche>

* `AddLine <ligne>` ou `Add_Line <ligne>` +
La ligne est ajouté au fichier.

* `InsertLine <ligne>` ou `Insert_Line <ligne>` +
<ligne> est inséré à la position du pointeur de la ligne.

* `AppendLine <ligne>`ou `Append_Line <ligne>` +
<ligne> est ajoutée après la ligne à laquelle le pointeur est dirigé.

* `Append_File <nom de fichier>` +
lit le fichier et ajoute ses lignes dans le fichier édité.

* `Subtract_File <nom de fichier>` +
supprime les lignes du début du fichier édité, tant qu'elles sont identiques, avec les lignes du fichier <nom de fichier>.

* `SaveToFile <nom de fichier>` +
écrit les lignes éditées dans un fichier <nom de fichier>.

* `Sorted` +
entraîne que les lignes édités sont ordonnée (ASCII).

[[opsi-winst-patchtextfile-examples]]
==== Exemples

Pour plus d'exemples, regardez le paquet standard OPSI 'opsi-script-test' et dans ce produit la partie '$Flag_winst_patch_text_file$ = "on"'

[[opsi-winst-linkfolder]]
=== Sections LinkFolder

Dans une section LinkFolder sont gérés les entrées du menu démarrage ainsi que les liens du bureau. 

Par exemple la section suivante crée un dossier nommé "acrobat“ dans le menu démarrer commune (partagé par tous les utilisateurs):
[source,winst]
----
[LinkFolder_Acrobat]
set_basefolder common_programs

set_subfolder "acrobat"
set_link 
  name: Acrobat Reader 
  target: C:\Programme\adobe\Acrobat\reader\acrord32.exe
  parameters: 
  working_dir: C:\Programme\adobe\Acrobat\reader
  icon_file: 
  icon_index:
end_link
----

Dans une section LinkFolder la première chose à définir est le dossier système virtuel sur lequel sont à opérer les instructions. Cette expression définit le dossier de base: +
`set_basefolder` '<dossier système virtuel>'

Les dossiers système virtuel qui peuvent être utilisés sont: 

'desktop, sendto, startmenu, startup, programs, desktopdirectory, common_startmenu, common_programs, common_startup, common_desktopdirectory'

Les dossiers sont 'virtuels', le nom du répertoire physique qui en résulte est dépendent du système d'exploitation (et de la version). 

Dans le cadre des installations de machines standards, seuls les dossiers système virtuel commençant par `common_` sont pertinentes.

Les dossiers système 'desktop, sendto, startmenu, startup, programs, desktopdirectory' ne peuvent être utilisés que dans le cadre d'un utilisateur connecté respectivement dans un 'userLoginScript' dans le cadre de l'extension opsi 'Gestion des profils utilisateur'.

Les dossiers sont 'virtuels' puisque le système d'exploitation (les entrées de registre) déterminent lors lieux réels dans le système de fichiers. 
Deuxième, nous devons ouvrir un sous-dossier du dossier virtuel sélectionné: +
`set_subfolder` <chemin du dossier> +
Le nom du sous-dossier doit être interprété comme un nom de chemin avec le dossier système virtuel sélectionnée en tant que racine. Certain lien sont directement placés dans le dossier système que nous avons à rédiger +
`set_subfolder ""`

Dans la troisième étape, nous pouvons commencer à mettre des liens. La commande est une expression à plusieurs lignes commençant par +
`set_link` +
et finissant par 
`end_link.`

Entre ces lignes les paramètres du lien sont définis dans le format suivant:


`set_link` +
  `name:` [nom du lien] +
  `target:` <chemin complet du programme> +
  `parameters:` [paramètres de ligne de commande du programme] +
  `working_dir`: [répertoire de travail] +
  `icon_file:` [Chemin du fichier icône] +
  `icon_index:` [position de l'icône dans le fichier de l'icône] +
`end_link` 

Le nom 'target' est la seule entrée essentielle. Les autres entrées ont des valeurs par défaut:

* `name` valeur par défaut est le nom du programme.
* `parameters`valeur par défaut est une chaîne vide.
* `icon_file` par défaut à 'target'.
* `icon_index` par défaut est 0.

CAUTION: Si la cible ne se trouve pas référencé sur un partage monté au moment de la création d'un lien, windows raccourcit son nom au format 8.3. +
Solution: +
Créer un lien correct lorsque le partage est connecté. +
Copiez le fichier de lien prêt à un endroit qui existe à l'exécution du script. +
Que ce dossier soit la cible.

* `delete_element` <Nom du lien> +
supprimer un lien à partir du dossier ouvert. 

* `delete_subfolder` <Folderpath> +
le dossier est supprimé depuis le dossier virtuel de base

[[opsi-winst-linkfolder-examples]]
==== Exemples

[source,winst]
----
set $list2$ = createStringList ('common_startmenu', 'common_programs', 'common_startup', 'common_desktopdirectory')
for $var$ in $list2$ do LinkFolder_Dummy

[LinkFolder_Dummy]
set_basefolder $var$
set_subfolder "Dummy"
set_link
	name: Dummy
	target: C:\Programme\PuTTY\putty.exe
	parameters:
	working_dir: C:\Programme\PuTTY
	icon_file:
	icon_index:
end_link
----

entraîne le journal système suivant:
[source,winst]
----
Set  $list2$ = createStringList ('common_startmenu', 'common_programs', 'common_startup', 'common_desktopdirectory')
    retrieving strings from createStringList [switch to loglevel 7 for debugging]
        (string   0)common_startmenu
        (string   1)common_programs
        (string   2)common_startup
        (string   3)common_desktopdirectory
        
    retrieving strings from $list2$ [switch to loglevel 7 for debugging]
        (string   0)common_startmenu
        (string   1)common_programs
        (string   2)common_startup
        (string   3)common_desktopdirectory
        

~~~~~~ Looping through:  'common_startmenu', 'common_programs', 'common_startup', 'common_desktopdirectory'
  
  Execution of LinkFolder_Dummy
    Base folder is the COMMON STARTMENU folder
    Created "Dummy" in the COMMON STARTMENU folder
      ShellLink "Dummy" created
  
  Execution of LinkFolder_Dummy
    Base folder is the COMMON PROGRAMS folder
    Created "Dummy" in the COMMON PROGRAMS folder
      ShellLink "Dummy" created
  
  Execution of LinkFolder_Dummy
    Base folder is the COMMON STARTUP folder
    Created "Dummy" in the COMMON STARTUP folder
      ShellLink "Dummy" created
  
  Execution of LinkFolder_Dummy
    Base folder is the COMMON DESKTOPDIRECTORY folder
    Created "Dummy" in the COMMON DESKTOPDIRECTORY folder
      ShellLink "Dummy" created

~~~~~~ End Loop
----

Pour plus d'exemples, vérifiez le paquet standard OPSI 'opsi-script-test' et dans ce produit la partie '$Flag_winst_link_folder$ = "on"'.

[[opsi-winst-xmlpatch]]
=== Sections XMLPatch

Aujourd'hui, le moyen le plus populaire pour conserver les données de configuration,ou les données elles memes, est un fichier en format de document XML. Sa syntaxe suit les conventions telles que définies dans les spécifications XML (ou "Extended Markup Language") (http://www.w3.org/TR/xml/).

'{opsi-winst}' offre les sections XMLPatch pour l'édition de documents XML. 

Avec les actions définies pour ce type de section '{opsi-winst}' peut: 

* 'choisir' (et éventuellement créer) des ensembles d'éléments d'un document XML suivant un chemin de description
* 'patcher' tous les éléments d'un ensemble d'éléments sélectionnés
* 'retourner' le nom et/ou les attributs des éléments sélectionnés dans la section d'appel

[[opsi-winst-xmlpatch-params]]
==== Paramètre

Lors de l'appel d'une section XMLPatch le nom de chemin du document est donné comme paramètre, par exemple +
`XMLPatch_mozilla_mimetypes $mozillaprofilepath$ + "\mimetypes.rdf"`

[[opsi-winst-xmlpatch-xmldoc]]
==== Structure d'un Document XML

Un document XML décrit logiquement un "arbre" qui départ d'une "racine" - donc nommé document root– et se développe dans les branches. Chaque branche est étiquetée comme un noeud. Le sous-noeuds de certains noeuds sont appelés les enfants ou noeuds enfants de leur noeud parent.

Dans XML, l'arbre est construit à partir des éléments. Le début de toute description de l'élément est marqué par une balise (comme dans le HTML) à savoir un morceau de texte spécifiques qui est fixé dans une paire de crochets ("<“ ">“). La fin de la description de l'élément est définie par la même balise mais maintenant avec les crochets "</“ et „>“. Si un élément n'a aucun élément subordonné alors il n'y a pas d'espace nécessaire entre la balise de début et la balise de fin. Dans ce cas, les deux balises peuvent être combinées dans une avec le crochet de fin "/>“.

Ce schéma montre un simple arbre à "V", juste un branchement au niveau de la racine, pivoté de sorte que la racine est le sommet:  
~~~~
    |     noeud racine (level 0)
   / \    noeud 1 et noeud 2 les deux au niveau 1  
  .   .   implicitement les noeuds d'extrémité en dessous du niveau 1
~~~~
Cet arbre peut être décrit en XML de la façon suivante:
[source,xml]
----
<?xml version="1.0"?>
<root>
    <node_level_1_no_1>
    </node_level_1_no_1>
    <node_level_1_no_2>
    </node_level_1_no_2>
</root>
----
La première ligne doit déclarer la version XML utilisée. Le reste des lignes décrivent l'arbre.

Tant la structure semble être simple. Mais encore, nous avons seulement des "noeuds principaux" définissant chacun un élément de l'arbre et marqués par une paire de balises. Mais chaque noeud principal peut avoir plusieurs types de sous-noeuds.

Bien sûr, un élément peut avoir des éléments subordonnés, par exemple nous pouvons avoir sous-noeuds de A à C du noeud 1:
[source,xml]
----
<node_level_1_no_1>
    <node_level_2_A>
    </node_level_2_A>
    <node_level_2_B>
    </node_level_2_B>
    <node_level_2_C>
    </node_level_2_c>
</node_level_1_no_1>
----
S'il n'y a pas d'éléments subordonnés un élément peut avoir un texte subordonnés. Alors on dit que l'élément a un noeud de texte subordonnés. Exemple
[source,xml]
----
<node_level_1_no_2>hello world
</node_level_1_no_2>
----
Un saut de ligne placé dans le noeud texte est maintenant interprétée comme une partie du texte là où autrement il est seulement un moyen d'afficher la structure XML. Pour éviter un saut de ligne dans "hello world" nous devons rédiger
[source,xml]
----
<node_level_1_no_2>hello world</node_level_1_no_2>
----
Chaque élément (peu importe s'il a des éléments subordonnés ou texte subordonnés) est constitué comme un noeud principal avec des balises spécifiques. Il peut encore être précisée par des attributs, dits noeuds d'attributs. Par exemple, il peut y avoir des attributs "colour" ou "angle" qui distinguent les différents nœuds du niveau 1.
[source,xml]
----
<node_level_1_no_1 colour="green" angle="65"
</node_level_1_no_1>
----
Pour sélectionner un ensemble d'éléments tout type d'information peut être utilisée:

. le niveau de l'élément,

. les noms des éléments qui sont traversés lors de la descente de l'arbre (le "chemin XML"),

. les noms et les valeurs des attributs utilisés,

. l'ordre des attributs,

. l'ordre des éléments,

. d'autres relations des éléments,

. le contenu textuel des éléments (ou leurs noeuds de texte subordonnés).

Dans '{opsi-winst}', la sélection basée sur des critères (1) à (3) et (7) est mis en oeuvre

[[opsi-winst-xmlpatch-search-options]]
==== Options pour la sélection d'un ensemble d'éléments


Avant toute opération sur le contenu d'un fichier XML l'ensemble précis d'éléments sur lequel il sera opéré doit être déterminée. L'ensemble est construit étape par étape en définissant les chemins autorisés dans l'arborescence XML. Enfin, les points d'extrémité restants, des chemins, définissent l'ensemble sélectionné.

La commande '{opsi-winst}' basique est:

* `OpenNodeSet`

Il y a deux formats pour définir les chemins permis: un court et un long format.

.syntaxe explicite

La syntaxe plus explicite peut être vu dans l'exemple suivant (pour un exemple plus complexe <<opsi-winst-cookbook-patchxml>>):
[source,winst]
----
openNodeSet
  documentroot
  all_childelements_with:
   elementname:"define"
  all_childelements_with:
    elementname:"handler"
    attribute: extension value="doc"
  all_childelements_with:
    elementname:"application"
end
----

.syntaxe courte

Le même ensemble de nœuds est donnée par la ligne:
[source,winst]
----
openNodeSet 'define /handler value="doc"/application /'
----

Dans cette syntaxe, la barre oblique sépare les étapes dans la structure de l'arbre qui sont désignés dans la syntaxe plus explicite chacun par une propre description.

.Sélection par le contenu textuel (seulement pour syntaxe explicite)

Étant donné la syntaxe explicite nous pouvons sélectionner des éléments par le contenu textuel des éléments:
[source,winst]
----
openNodeSet

  documentroot
  all_childelements_with:
  all_childelements_with:
    elementname:"description"
    attribute:“type“ value=“browser“
    attribute:“name“ value=“mozilla“
  all_childelements_with:
    elementname:"linkurl"
    text:"http://www.mozilla.org"
end
----

.Paramétrage de la Stratégie de recherche

Dans les descriptions traversals des exemples de l'arbre XML il reste plusieurs questions.

* Un élément sera accepté si le nom de l'élément et les attributs énumérés correspondent mais d'autres attributs existent?

* Est-ce la recherche vise à donner une valeur de résultat unique, qui devrait être l'ensemble d'éléments résultant n'ont pas plus d'un élément (et autrement, le fichier XML est à considérer comme erroné)?

* Inversement, is it meant that a traversal shall at any rate lead to some result, à savoir avons-nous à créer l'élément si aucun élément correspondant existe?

Pour répondre à ces questions explicitement il y a des paramètres pour la commande OpenNodeSet. Les lignes suivantes montrent les paramètres par défaut qui peuvent être variées en changeant les valeurs booléennes:
[source,winst]
----
  - error_when_no_node_existing false
  - warning_when_no_node_existing true
  - error_when_nodecount_greater_1 false
  - warning_when_nodecount_greater_1 false
  - create_when_node_not_existing false
  - attributes_strict false
----

Avec la syntaxe courte, le paramétrage précède la commande OpenNodeSet et tient pour tous les niveaux de l'arborescence XML. Avec la syntaxe explicite les paramètres peuvent être réglés directement après la commande OpenNodeSet ou être nouvellement créé pour chaque niveau. En particulier l'option „create when node not existing“ peut être établie pour certains niveaux, mais pas pour tous.

[[opsi-winst-xmlpatch-actions]]
==== Actions Patch

Il existe un ensemble de commandes qui opèrent sur ​​un ensemble d'éléments sélectionnés

* pour le réglage et la suppression des attributs

* pour enlever les éléments

* pour les réglages du texte.

En détail:

* `SetAttribute` "nom de l'attribut" value="valeur de l'attribut" +
Définit l'attribut spécifié pour chaque élément dans le jeu ouvert à la valeur spécifiée. Si l'attribut n'existe pas, il sera créé. + 
Exemple: 
`SetAttribute "name" value="OpenOffice Writer"`

Au contraire, la commande +

* `AddAttribute` "nom de l'attribut" value="valeur de l'attribut" +
définit l'attribut spécifié uniquement à la valeur spécifiée si elle n'existe pas à l'avance. Un attribut existant conserve sa valeur. Par exemple la commande +
`AddAttribute "name" value="OpenOffice Writer"` +
n'écrase pas la valeur s'il y avait nommé un autre programme avant.

Avec +
* `DeleteAttribute` "nom de l'attribut" +
nous enlevons l'attribut spécifié de chaque élément de l'ensemble des éléments sélectionnés.

La commande +
* `DeleteElement` "nom de l'élément" +
supprime tous les éléments avec le nom de noeud principal (nom de la balise) nom de l'élément de l'ensemble des éléments ouverts. 

Enfin, il existe deux commandes pour le réglage voir ajouter des noeuds de texte.:

* `SetText` "Texte"

et

* `AddText` "Texte"

Exemple +
`SetText "rtf"` +
transforme l'élément +
'<fileExtensions>doc<fileExtensions>' +
en +
'<fileExtensions>rtf<fileExtensions>'

Avec +
`SetText ""` +
nous enlevons le noeuds texte complètement.

La variante +
`AddText "rtf"` +
définit le texte que s'il n'y a pas de noeud texte donné. 

[[opsi-winst-xmlpatch-return]]
==== Retour des listes, pour l'appelant

Une section XMLPatch peut retourner les informations récupérées à la section primaire appelante. Le résultat est toujours une liste de chaînes, et pour l'obtenir, l'appel doit se faire via la fonction de liste de chaînes `getReturnListFromSection`. Par exemple nous pouvons avoir le réglage de listes de chaînes suivant dans une section Actions quand nous utilisons une section XMLPatch_mime

[source,winst]
----
DefStringList $list1$
set $list1$=getReturnListFromSection ('XMLPatch_mime "c:\mimetypes.rdf"')
----

Dans la section XMLPatch nous avons des commandes `return` qui déterminent le contenu de la liste de chaînes retourné:

* `return elements`+ 
remplit complètement les éléments sélectionnés (nom de l'élément et les attributs) dans la liste de retour.

* `return attributes` + 
produit une liste des attributs.

* `return elementnames` + 
produit une liste de noms d'élément.

* `return attributenames`
donne une liste seulement des noms d'attributs.

* `return text` +
Liste tout le contenu textuel des éléments sélectionnés.

* `return counting` +
donne un rapport avec des informations numériques: la ligne 0 contient le nombre d'éléments sélectionnés, la ligne 1 le nombre d'attributs.

[[opsi-winst-xmlpatch-examples]]
==== Exemples

Pour d'autres exemples voir le produit 'opsi-script-test'
en particulier le secteur avec '$Flag_winst_xml$ = "on"'


[[opsi-winst-progman]]
=== Sections ProgmanGroups

Ce type de section type est obsolete.

[[opsi-winst-winbatch]]
=== Sections WinBatch

Dans une section WinBatch n'importe quel exécutable Windows peut être lancé. +
Par exemple, nous pouvons démarrer certains programmes d'installation existants par les lignes suivantes dans une section WinBatch +
[source,winst]
----
[winbatch_install]
"%scriptpath%\setup.exe"
----

Il est obsolète mais toujours en charge que vous pouvez appeler – à partir de l'explorateur Windows – un fichier de n'importe quel type pour lequel un programme est enregistré.


[[opsi-winst-winbatch-params]]
==== Paramètre d'appel (Modificateur)

Il y a plusieurs paramètres de l'appel WinBatch qui déterminent si (ou combien de temps) '{opsi-winst}' doit attendre le retour pour les programmes lancés.

* `/WaitOnClose` +
Est le défaut +
'{opsi-winst}' attend le retour de tous les processus initié. 

* `/LetThemGo` +
C'est le contraire de `/WaitOnClose`. Il est utilisé si '{opsi-winst}' doit procéder tandis que les processus débutés s'exécutent dans leur propres threads.


* `/WaitSeconds` [nombre-de-secondes] +
Si un appel inclut le paramètre /WaitSeconds [nombre-de-secondes], alors '{opsi-winst}' attend pendant [nombre-de-secondes] avant de procéder. Dans la configuration par défaut, nous devons également attendre que tous les programmes en cours d'exécution se terminent. Si nous combinons le paramètre /WaitSeconds avec l'option `/LetThemGo`, alors '{opsi-winst}' continue le traitement quand le temps d'attente est terminé.

* `/WaitForProcessEnding` <nom-du-programme> +
Attend la fin du processus appelé <nom-du-programme>. +
Devrait être combiné avec `/TimeOutSeconds`.

Explication: +
Lors du démarrage d'un processus externe à partir d'un appel WinBatch, '{opsi-winst}' il attend la fin du processus en cours avant d'exécuter la commande suivante dans le script.

*  `/32Bit` +
Ceci est la valeur par défaut. Les chemins dans la section sont supposées être de chemins 32 bits. +
Exemple: `c:\windows\system32\regedit.exe` il appelle 'regedit.exe' 32 bits (même lorsqu'il est exécuté sur un système 64 bits).

*  `/64Bit` +
Les chemins dans la section sont supposées être de chemins 64 bits. +
Exemple: `c:\windows\system32\regedit.exe` il appelle 'regedit.exe' 64 bits (seulement si s'exécute sur un système 64 bits).

*  `/SysNative` +
Les chemins au sein de la section sont attribués en fonction de l'architecture de l'OS. +
Exemple: `c:\windows\system32\regedit.exe` sur un système 64 bits appelle 'regedit.exe' 64 bit et sur un système 32 bits appelle 'regedit.exe' 32 bit.

Exemple:
[source,winst]
----
Winbatch_add_reg winst /64Bit
[Winbatch_add_reg]
"c:\windows\system32\regedit.exe" /s "%scriptpath%\my64.reg"
----

* `/RunAsLoggedonUser` //depuis 4.11.3.5 +
Cette option est disponible uniquement dans le cadre de 'userLoginScripts'. Le programme est exécuté avec le compte de l'utilisateur qui vient de se connecter.
Ce modificateur a les limites suivantes: +
** essai insuffisante sur NT6.


.Traitement séquentiel d'un script qui attend la fin d'un programme
image::waitforprocess_scheme_std.png["waitforprocess_scheme_std",width=150]

Il y a quelques programmes externes qui commencent un autre processus, puis se terminent sans attendre la fin de leur processus enfant. Du point de vue de '{opsi-winst}', le processus est terminé et la commande suivante peut être démarré.

.Fin du processus, tandis que le processus enfant est toujours en cours
image::waitforprocess_scheme_fork1.png["waitforprocess_scheme_fork1",width=200]

Si vous exécutez un programme de désinstallation et un programme d'installation dans l'ordre et le programme de désinstallation fonctionne avec un tel processus enfant, vous pouvez avoir des processus en cours d'exécution en conflit parce que la désinstallation et d'installation sont en cours d'exécution dans le même temps.

.Chevauchement d'un processus enfant et un processus parent
image::waitforprocess_scheme_fork2.png["waitforprocess_scheme_fork2",width=200]

L'usage du modificateur `/WaitForProcessEnding` permet d'éviter une telle situation.

* `/TimeOutSeconds` <secondes> +
Un paramètre de temporisation. Après le nombre de <secondes>, '{opsi-winst}' terminera le processus. +
Depuis la version 4.11.3, /TimeOutSeconds peut être utilisé sans une condition d'attente (ex. `/WaitForProcessEnding`) mais pas en combinaison avec `/WaitSeconds`. +
Exemple: +
[source,winst]
----
Winbatch_uninstall /WaitForProcessEnding "uninstall.exe" /TimeOutSeconds 20
[Winbatch_uninstall]
"%ScriptPath%\uninstall_starter.exe"
----

* `/RunElevated` +
Commence un processus qui a un jeton de sécurité avec des privilèges élevés. Ce modificateur est soumis aux restrictions suivantes: +
** Pour NT5 cela ne change rien.
** Un processus a commencé avec ce modificateur n'a pas accès au réseau. Donc, vous devriez copier un programme dans un répertoire temporaire local, et non pas le démarrer à partir d'un partage réseau.
** Vous pouvez voir des problèmes lors de l'utilisation de l'interface graphique. Par conséquent, des véritables installations silencieuses sont le meilleur choix dans ce cas.
** Fonctionne uniquement dans le cadre de '{opsi-winst}'.

* `getLastExitCode` +
Retourne une chaîne qui contient la valeur du code de sortie du processus qui a été le dernier appelé par une section WinBatch / ShellScript / ExecWith. +
Lorsque vous utilisez une section ShellScript ou ExecWith, vous obtiendrez normalement le code de sortie de l'interprète qui a été appelé. Pour obtenir le code de sortie de votre script, vous devez le définir explicitement.

* `/RunAsLoggedOnUser` // depuis 4.11.3.5 ; Fonctionne uniquement dans le cadre de 'userLoginScripts'

* `/32Bit` ou `/64Bit` ou `/SysNative`	 //depuis 4.11.3.5 +
Ces modificateurs, il vérifie si le chemin vers un programme appelé est interprété comme un chemin 32 ou 64 Bit. Donc, si vous voulez par exemple appeler `%system%\cmd.exe` vous appelez un programme 32 bits par défaut. Si vous utilisez le modificateur /64Bit, vous obtiendrez avec le même appel la version 64 bits.

* `/WaitForWindowAppearing` [titre de la fenêtre] +
voir +
`/WaitForWindowVanish` [titre de la fenêtre] +
Les deux sont obsolètes. Utilisez `/WaitForProcessEnding` +

La première option signifie que '{opsi-winst}' attend jusqu'à ce que tout processus permet de faire apparaître une fenêtre avec titre de la fenêtre. Avec la deuxième option '{opsi-winst}' est en attente aussi longtemps qu'une certaine fenêtre (1) apparu sur le bureau (2) soit disparu. +
CAUTION: Ces options ne connais que des fenêtres de programms 32-bit 
 

[[opsi-winst-winbatch-examples]]
==== Exemples

Pour d'autres exemples voir le paquet 'opsi-script-test'
en particulier le secteur avec '$Flag_winst_winbatch$ = "on"'

[[opsi-winst-shellscript]]
=== Sections ShellScript

Par le biais de sections ShellScript (autrefois appelé ShellBatch/ShellInAnIcon/DosBatch/DosInAnIcon) un script '{opsi-winst}' utilise les scripts shell de Windows pour des tâches qui ne peuvent pas être remplies par des commandes internes ou pour lesquels déjà une solution de script batch existe.

'{opsi-winst}' attend que DOS-batch se termine, avant qu'il procède à la section de script suivante.  
 
Une section ShellScript est tout simplement traitée en écrivant les lignes des sections dans le fichier _winst.bat dans c:\tmp et puis en appelant ce fichier dans le contexte du shellcmd.exe . Ce qui explique que une section ShellScript peut contenir toutes les commandes shell Windows pouvant être utilisés. 


Comparé à l'appel d'une cmd-file dans une section WinBatch, la section ShellScript 
présente certains avantages: +

* '{opsi-winst}' variables ou constantes dans la section peuvent être facilement utilisés car ils seront remplacés avant l'exécution. 

* La sortie des scripts est écrite dans le fichier de log.

* La sortie de la commande shell peut être capturé en utilisant la fonction de liste de chaînes.

Le type de section 'ShellScript' concernant la syntaxe et la méthode d'exécution mais elle a une apparence différente: +
Pour 'ShellScript', un processus shell est créé avec la vue mis à minimisé. Cela a pour conséquence qu'il est exécuté "dans une icône". Aucune fenêtre de commande apparaît, l'interaction avec l'utilisateur est supprimée.

CAUTION: Ne pas utiliser les commandes qui attendent l'interaction de l'utilisateur.

[[opsi-winst-shellscript-params]]
==== Paramètre

Il y a deux sortes de paramètres qui peuvent être transmis en appelant la section:

* Les paramètres qui sont directement passés au fichier batch appelé.

* Paramètres qui modifient la façon dont '{opsi-winst}' s'occupera de la section.

La syntaxe d'appel est:

+Sektionsname [paramètres batch] [winst [modificateur]]+

Le modificateur de '{opsi-winst}' possibles sont (depuis 4.11.1):

* `/32bit`

* `/64bit`

* `/Sysnative`

Ces modificateurs '{opsi-winst}' doivent être séparés des autres paramètres par le mot-clé `winst`.

D'autres paramètres d'une section ShellScript sont directement transmis en tant que quasi paramètres en ligne de commande au script shell Windows. +
Par exemple on peut appeler ShellScript_1 dans la section Actions pour obtenir un "Hello World" à partir de la commande DOS echo:
[source,winst]
----
[Actions]
ShellScript_1 today we say "Hello World" 

[ShellScript_1]
@echo off
echo %1 %2 %3 %4
pause
----

l'exécution de la commande Dos-Batch echo avec les paramètres 'today we say "Hello World"'.

L'exemple suivant sera sur un système 64 bits exécuté dans un cmd.exe 64 bits et donnant la sortie 'today we say':
[source,winst]
----
[Actions]
ShellScript_1 today we say winst /64bit

[ShellScript_1]
@echo off
echo %1 %2 %3 %4
pause
----

[[opsi-winst-shellscript-catchout]]
==== Capturer la sortie

La sortie des commandes shell peut être capturé en utilisant la fonction liste de chaînes `getOutStreamFromSection()` à partir des scripts '{opsi-winst}' de section principale
voir aussi: +
<<opsi-winst-stringlist-getstring>>). 

Si la liste de retour doit être évaluée avec un programme il est conseillé d'utiliser le préfixe de commandes '@'. Si faisant nous supprimons la répétition de la ligne de commande dans la sortie qui peut être de différents formats dépendant des configurations système. 

[[opsi-winst-shellscript-examples]]
==== Exemples

Pour d'autres exemples voir le produit 'opsi-script-test'
en particulier le secteur avec '$Flag_winst_dos$ = "on"'

[[opsi-winst-registry]]
=== Sections Registry

Par un appel section Registry, nous pouvons créer, patcher et supprimer des entrées dans le Registre Windows. Comme d'habitude, '{opsi-winst}' enregistre toutes les opérations en détail aussi longtemps que l'enregistrement n'est pas désactivé. 

[[opsi-winst-registry-examples]]
==== Exemples

Laissez-nous définir certaines variables de registre par un appel à la section Registry_TestPatch où la section est donnée par
[source,winst]
----
[Registry_TestPatch]
openkey [HKEY_Current_User\Environment\Test]
set "Testvar1" = "c:\rutils;%Systemroot%\hey" 
set "Testvar2" = REG_DWORD:0001
----

Pour d'autres exemples voir le produit 'opsi-script-test'
en particulier le secteur avec '$Flag_subregistry$ = "on"'

[[opsi-winst-registry-params]]
==== Paramètres d'appel

* L'appel standard d'une section registry n'a pas de paramètres. Cela est suffisant tant que les opérations visent à la base de registre standard d'un système Windows et toutes les entrées peuvent être définies en utilisant un chemin de registre globalement défini.

* `/AllNTUserDats` +
'{opsi-winst}' propose également que les commandes de patch d'une section Registry sont automatiquement exécutées "pour tous les utilisateurs" qui sont définis localement. À savoir que les patchs sont faites pour toutes les branches utilisateur du Registre local. Cette interprétation de la section est évoqué par le paramètre `/AllNTUserDats`

En outre les paramètres de contrôle de la section Registry qui varient syntaxiquement sont valable:

* `/regedit` +
Le paramètre `/regedit` déclare que la syntaxe correspond à la syntaxe du fichier d'exportation de l'éditeur de registre Windows regedit. Aussi, les lignes d'un fichier d'exportation regedit peuvent directement être utilisée comme Registry voir le fichier lui-même peut servir comme une section externe (voir <<opsi-winst-registry-regedit>>).

* `/addReg` +
De même, Le paramètre `/addReg` déclare que la syntaxe de la section Registry est celle d'un fichier inf (utilisé par exemple pour les installations de pilotes)
(voir <<opsi-winst-registry-addreg>>).

Ces variantes syntaxiques pas spécifique de '{opsi-winst}' ne sont pas définies dans ce manuel car ils seront généralement généré par programme.

Il y a aussi les options:

* `/32Bit` +
* `/64Bit` +
* `/SysNative` +

qui manipulent les 'redirections en écriture de registre' sur les systèmes 64 bits. (voir <<opsi-winst-64bit>>).

[[opsi-winst-registry-commands]]
==== Commandes

La syntaxe par défaut d'une section Registry est orienté à la syntaxe de commande d'autres opérations de patch dans '{opsi-winst}'.

Ils existent les commandes suivantes:

* `OpenKey`

* `Set`

* `Add`

* `Supp`

* `GetMultiSZFromFile`

* `SaveValueToFile`

* `DeleteVar`

* `DeleteKey`

* `ReconstructFrom`

* `Flushkey`


En détail:

* `OpenKey` <clé de registre> +
ouvre la clé spécifiée en lecture et (si l'utilisateur a les privilèges nécessaires) en écriture. Si la clé n'existe pas elle sera créée.

La clé de registre est désignée par un nom de chemin de registre. Dans des circonstances ordinaires il commence avec l'un des "high keys" qui construisent le plus haut niveau de l'arbre de structure de données du registre (au-dessus du "root" ). Ce sont:
'HKEY_CLASSES_ROOT, HKEY_CURRENT_USER, HKEY_LOCAL_MACHINE, HKEY_USERS, HKEY_CURRENT_CONFIG' qui peuvent éventuellement être écrite comme 'HKCR, HKCU, HKLM, HKU'. 

Dans la syntaxe '{opsi-winst}' du nom du chemin du registre, les éléments d'un chemin sont séparées par seul backslashs.

Toutes les autres commandes fonctionnent sur ​​une clé de registre ouverte.

* `Set` <nom de la variable> = <valeur> +
définit la variable de registre <nom de la variable> à la valeur <valeur>.
<nom de la variable> ainsi que <valeur> sont des chaînes et doivent être contenue entre guillemets. Une variable non existante sera créé. Par défaut, le type de données normalement utilisé est 'REG_SZ'. Mais si <value> contient un caractère pour cent ('%') 'REG_EXPAND_SZ' sera utilisé à la place.


La variable vide "" indique l'entrée standard d'une clé de registre.

Si certaines variables de registre doivent être créé ou definie alors le type de données doit être donné explicitement et nous devons utiliser la variante étendue de la commande `Set`:

* `Set` <nom de la variable> = <type de registre>:<valeur> + 
définit la variable de registre <nom de la variable> à la valeur <valeur> du type <registry type>. Les types de registre suivantes sont disponibles:

'REG_SZ'::: (chaîne)

'REG_EXPAND_SZ'::: (une chaîne contenant une sous-chaîne que le système d'exploitation doit élargir, par exemple)

'REG_DWORD'::: (des valeurs entières)

'REG_BINARY'::: (valeurs binaires habituellement donné en deux chiffres nombres hexadécimaux 00 01 02 .. 0F 10)

'REG_MULTI_SZ'::: (matrices valeur de chaîne, dans '{opsi-winst}' nous devons utiliser "|" comme séparateur) +
Un exemple pour definir un REG_MULTI_SZ: +
[source,winst]
----
set "myVariable" = REG_MULTI_SZ:"A|BC|de"
----

Pour construire une multi-chaîne nous pouvons mettre les chaînes comme des lignes dans un fichier et le lire à l'aide de `GetMultiSZFromFile` (voir plus bas). 

* `Add` <nom de la variable> = <valeur>
+
voir
+
`Add` <nom de la variable> = <type de registre> <valeur> +
sont analogues aux commandes `Set` avec la différence que les entrées sont uniquement ajoutées mais les valeurs des variables existantes ne change pas.

* `Supp` <nom de la variable> <liste de séparateur> <supplément> +
Cette commande interprète la valeur de la chaîne de variable <nom de la variable>, une liste de valeurs séparées par <liste de séparateur> et ajoute la chaîne <supplément> à cette liste (si elle n'est pas déjà contenue). Si <supplément> contient le <liste de séparateur> il est divisé en chaînes simples, et la procédure est appliquée à chaque chaîne. +
Une utilisation typique est l'ajout d'entrées à une variable de chemin (qui est définie dans le Registre). +
`Supp` conserve la variante de la chaîne originale (REG_EXPAND_SZ ou REG_SZ). +

Exemple: +
Le chemin d'environnement est déterminé par la valeur pour la variable Path tel que définie à l'intérieur la clé de registre
+
'KEY_LOCAL_MACHINE\SYSTEM\CurrentControlSet\Control\Session Manager\Environment'
+
Pour ajouter des entrées à la définition du chemin nous devons avoir accès à cette clé par un OpenKey. Ensuite, nous pouvons appliquer par exemple
+
`supp "Path" ; "C:\utils;%JAVABIN%"`
+
afin de compléter le chemin avec '"C:\utils"' et '"%JAVABIN%"'.
+
(Windows élargit %JAVABIN% vers le nom de chemin correct si %JAVABIN% existe en tant que variable et la chaîne est une REG_EXPAND_SZ.)
+
Ayant lu l'ancienne valeur de chemin de la variable d'environnement, écrit cette valeur à la valeur de registre - et sont alors capables de travailler avec la variable de registre:
+
[source,winst]
----
[Actions] 
DefVar $Path$ 
set $Path$ = EnvVar ("Path") 
Registry_PathPatch 

[Registry_PathPatch] 
openkey [HKEY_LOCAL_MACHINE\SYSTEM\CurrentControlSet\control\Session Manager\Environment] 
set "Path"="$Path$" 
supp "Path"; "c:\orawin\bin"
----
+
CAUTION: La variable d'environnement obtient une valeur modifiée après un redémarrage.

* `GetMultiSZFromFile` <nom de la variable> <nom de fichier> +
lit les lignes d'un fichier et les met ensemble pour la construction d'une multi-chaîne.

* `SaveValueToFile` <nom de la variable> <nom de fichier> +
exportation de la valeur visée (chaîne ou multi-chaîne) comme fichier <nom de fichier> lignes (chaque chaîne, formant une ligne).

* `DeleteVar` <nom de la variable> +
supprime l'entrée avec la variable <nom de la variable> de la clé ouverte.

* `DeleteKey` <clé de Registre> +
supprime la clé de registre de façon récursive y compris tous les sous-clés et variables contenues. La clé de registre est défini comme pour OpenKey.
+
Exemple:
+
[source,winst]
----
[Registry_Keydel]
deletekey [HKCU\Environment\subkey1]
----

* `ReconstructFrom` <nom de fichier> +
(obsolète)

* `FlushKey` +
garantit que toutes les entrées d'une clé sont sauvegardés sur le disque dur, non seulement dans la mémoire (se fait automatiquement lors de la fermeture d'une clé, donc en particulier quand une section de registre est quitté).


[[opsi-winst-registry-allntuser]]
==== Sections Registry pour Patcher 'All NTUser.dat'

Une section Registry appelé avec le paramètre `/AllNTUserdats` est exécuté pour chaque utilisateur local.

À cette fin, pour tous les utilisateurs locaux (le stockage permanent pour la branche de registre 'HKEY_Users') les fichiers 'NTUser.dat' sont recherchées, un par un et temporairement chargé dans une sous-clé de certaines branches du registre. Les commandes de la section de registre sont exécutés pour cette sous-clé, puis la sous-clé est déchargé. Comme résultat, la valeur stockée pour 'NTUser.dat' est modifiée. 

Le mécanisme ne fonctionne pas pour un utilisateur connecté. Son 'NTUser.dat' est déjà utilisé, et la requête de le charger produit une erreur. Pour faire les changements pour lui aussi, les commandes du registre en plus sont exécutées sur la branche 'HKEY_Users' pour l'utilisateur connecté.

Il y a un 'NTUser.dat' pour 'Default User' qui sert de modèle pour les utilisateurs à créer dans le futur. Par conséquent, les patchs sont préparés pour eux aussi.

La syntaxe de la section Registry reste inchangé. Mais les chemins des clés sont interprétés relativement. Cela signifie *ne pas toucher les clé principales*

Dans l'exemple suivant l'entrée de registre pour la variable 'FileTransferEnabled' est définie de facto pour tous les 'HKEY_Users\XX\Software...' successifs pour tous les XX (tous les utilisateurs) sur l'ordinateur:

[source,winst]
----
[Registry_AllUsers]
openkey [Software\ORL\WinVNC3]
set "FileTransferEnabled"=reg_dword:0x00000000
----

depuis la version 4.11.2 de '{opsi-winst}' vous pouvez donner la clé racine 'HKEY_CURRENT_USER' à la commande `openkey`. +
Exemple:
[source,winst]
----
[Registry_AllUsers]
openkey [HKEY_CURRENT_USER\Software\ORL\WinVNC3]
set "FileTransferEnabled"=reg_dword:0x00000000
----

Cela a les avantages suivants:

* La syntaxe est plus facile à comprendre.

* La même section du registre peut être utilisé avec '/AllNtuserdats' et dans un 'userLoginScript'

[[opsi-winst-registry-regedit]]
==== Sections Registry dans le format Regedit

Si la section Registry est appelée avec le paramètre `/regedit` la section n'est pas attendu dans le format standard '{opsi-winst}' mais dans le format produit par l'outil Windows regedit.
Les fichiers d'exportation générés par regedit ont - pas sur la ligne d'en tête - un format de fichier ini. Exemple:

[source,ini]
----
REGEDIT4

[HKEY_LOCAL_MACHINE\SOFTWARE\opsi.org]

[HKEY_LOCAL_MACHINE\SOFTWARE\opsi.org\general]
"bootmode"="BKSTD"
"windomain"=""
"opsiconf"=dword:00000001

[HKEY_LOCAL_MACHINE\SOFTWARE\opsi.org\shareinfo]
"user"="pcpatch"
"pcpatchpass"=""
"depoturl"="\\\\bonifax\\opt_pcbin\\install"
"configurl"="\\\\bonifax\\opt_pcbin\\pcpatch"
"utilsurl"="\\\\bonifax\\opt_pcbin\\utils"
"utilsdrive"="p:"
"configdrive"="p:"
"depotdrive"="p:"
----
Les sections dénotent des clés de registre à ouvrir. Chaque ligne décrit certains paramètres de variables comme la commande set dans une section registry de '{opsi-winst}'.

Mais, nous ne pouvons pas vraiment avoir une section interne '{opsi-winst}' qui est construite à partir d'une autre section. Par conséquent la section Registry avec le paramètre `/regedit` ne peut être donnée que comme section extérieure ou par l'appel de fonction loadTextFile, par exemple

[source,winst]
----
registry "%scriptpath%/opsiorgkey.reg" /regedit
----

Avec Windows XP l'éditeur de registre regedit ne produit pas le format Regedit4 mais un nouveau format qui est indiqué par la ligne d'en tête +
'"Windows Registry Editor Version 5.00"' +

Dans ce format, Windows offre certains types de valeur supplémentaires. Mais le plus important, le fichier d'exportation est désormais généré au format Unicode. Le traitement des sections '{opsi-winst}' est basé sur les bibliothèques Delphi qui utilisent des chaînes de 8 de bits. Pour travailler avec un fichier d'exportation regedit 5 le codage est donc convertie. Ceci peut être fait manuellement, par exemple par un éditeur approprié. Mais on peut aussi passer le fichier original à '{opsi-winst}' en utilisant la fonction de liste de chaînes `loadUnicodeTextFile`. Par exemple, si printerconnections.reg est une exportation basée unicode, nous pouvons appeler regedit dans la forme suivante ce qui fait la conversion de code nécessaire à la volée:

[source,winst]
----
registry loadUnicodeTextFile("%scriptpath%/opsiorgkey.reg") /regedit
----
Un patch de registre utilisant le format regedit peut ainsi être exécutées "pour tous les utilisateurs NT" de la même façon que la section ordinaires '{opsi-winst}' registry . Un chemin comme 
'[HKEY_CURRENT_USER\Software\ORL]' est remplacé par le relatif '[Software\ORL].'


[[opsi-winst-registry-addreg]]
==== Sections Registry dans le format AddReg

Une section Registry peut être appelé avec le paramètre `/addReg`. Puis sa syntaxe suit les principes des sections '[AddReg]' dans les fichiers inf utilisé par exemple pour les installations de pilotes.

Par exemple: +
[source,ini]
----
[Registry_ForAcroread]
HKCR,".fdf","",0,"AcroExch.FDFDoc"
HKCR,".pdf","",0,"AcroExch.Document"HKCR,"PDF.PdfCtrl.1","",0,"Acr"
----

[[opsi-winst-opsiservicecall]]
=== Sections OpsiServiceCall


Ce type de section permet de récupérer des informations – ou configurer des données – via le service opsi. Il y a trois options pour déterminer une connexion à un service opsi:

* Par défaut, il est supposé que le script est exécuté dans l'environnement de l'installation standard de OPSI. C'est à dire, nous avons déjà une connexion à un service opsi et nous pouvons l'utiliser.

* Nous établissons l'url du service auquel nous voulons nous connecter comme un paramètre de la section en fournissons aussi le nom d'utilisateur et mot de passe nécessaire comme paramètres de la section.

* Nous demandons une connexion interactive au service (prédéfinissant seulement l'URL du service et, éventuellement, le nom d'utilisateur).

Les données récupérés peuvent être retourné comme une liste de chaînes et ensuite utilisées dans des scripts.

[[opsi-winst-opsiservicecall-params]]
==== Paramètres d'appel

Les paramètres d'appel déterminent quel service d'opsi sera adressé et définissent les paramètres de connexion si nécessaire. 

Les paramètres de connexion peuvent être définis via

* `/serviceurl` <URL du service Web OPSI>

* `/username` <Nom utilisateur du service Web>

* `/password` <mot de passe utilisateur du service Web>

Si ces paramètres, au moins serviceurl, sont donnés '{opsi-winst}' essaie d'ouvrir une connexion à un service opsi vers l'url.


L'option supplémentaire 

* `/interactive` +

ouvre une connexion interactive. L'utilisateur sera invité à confirmer les données de connexion et à fournir le mot de passe. Bien sûr, cette option ne peut pas être utilisé dans les scripts qui doivent être exécutées de manière entièrement automatique. 

En l'absence des paramètres de connexion '{opsi-winst}' suppose que une connexion existante doit être réutilisés.

En l'absence des paramètres de connexion et l'option interactive n'est pas spécifié (ni à cet appel ni à un appel précédent dans le script) il est supposé que nous sommes dans un processus de démarrage standard de opsi et, ayant déjà une connexion à un service de opsi, nous essayons de l'adresser. 


* `/preloginservice` +
Dans le cas que nous avons une connexion à un service secondaire d'opsi nous pouvons (re)définir la connexion au service OPSI standard via l'option 


* `/opsiclientd` //depuis 4.11.2.1 +
appelle opsiclientd sur l'hôte local  

[[opsi-winst-opsiservicecall-syntax]]
==== Section Format

Un `opsiServiceCall`, qui utilise une connexion existante à un service opsi, est définie par son nom de méthode et par une liste de paramètres.

Les deux sont définis dans la section body. Avec le format +
[source,winst]
----
"method":<method name>
"params":[
	<params>
	]
----
'params' est une liste (éventuellement vide) de chaînes (séparés par une virgule). Utilisez les paramètres tel que requis par la méthode spécifiée. 

Par exemple nous pouvons avoir un appel de section où le nom de la méthode requise et la liste (vide) de paramètres est défini:

[source,winst]
----
[opsiservicecall_clientIdsList]
"method":"getClientIds_list"
"params":[]
----

L'appel de section produit la liste des noms (IDs) de tous les clients locaux d'opsi. 
Si la liste doit être exploitée pour des fins autres que de test l'appel de section peut être utilisée dans une expression de liste de chaînes:
Par exemple: +
[source,winst]
----
DefStringList $result$
Set $result$=getReturnListFromSection("opsiservicecall_clientIdsList")
----

L'utilisation de `GetReturnListFromSection` est documenté dans le chapitre fonction de liste de chaînes de ce manuel (voir <<opsi-winst-stringlist-create-by-section>>).

Un hachage – dans ce cas une liste de chaînes, où chaque élément est une paire nom=valeur – est produite par l'appel de service suivants opsi:

[source,winst]
----
[opsiservicecall_hostHash]
"method": "getHost_hash"
"params": [
	"pcbon8.uib.local"
	]
----

CAUTION: Les sections opsiservicecall sont développés pour des méthodes 3.x d'opsi. Pour les méthodes opsi 4.x ils sont souvent pas adaptés. Par exemple les appels '*_getIdents' sont possibles, les appels '*_getObjects' ne sont pas possibles.  

[[opsi-winst-opsiservicecall-examples]]
==== Exemples

Pour d'autres exemples regarder le produit 'opsi-script-test' particulièrement '$Flag_winst_opsiServiceCall$ = "on"'

[[opsi-winst-execpython]]
=== Sections ExecPython

Des sections 'ExecPython' Sont essentiellement des sections de Shell (comme 'ShellScript') qui appelle – sur le système installé – l'interprète de script python. Il prend le contenu de la section en tant que script python, et le paramètre d'appel de la section en tant que paramètres pour le script.

Exemple:

L'exemple suivant démontre un appel execPython avec une liste de paramètres qui sont imprimés par les commandes Python. 

L'appel pourrait ressembler à +
[source,winst]
----
execpython_hello -a "option a" -b "option b" "there we are"

[execpython_hello]
import sys
print "we are working in path: ", a
if len(sys.argv) > 1 :
	for arg in sys.argv[1:] :
		print arg
else: 
  print "no arguments"


print "hello"
----

La sortie de la commande d'impression sera capturé et écrite dans le fichier de log. Ainsi nous obtenons dans le journal système +
[source,winst]
----
output:
 --------------
-a
option a
-b
option b
there we are
       hello
----

Observez que le niveau de journalisation doit être fixé au moins à info (qui est 1) si ces résultats doivent vraiment trouver leur chemin vers le fichier journal.

[[opsi-winst-execpython-combine]]
==== Imbrication d'un script Python avec un script opsi-winst

Une section execPython est intégré avec le script '{opsi-winst}' par quatre types de données partagées:

* Une liste des paramètres est transféré au script python.

* Tout ce qui est imprimé par le script python est écrit dans le journal système '{opsi-winst}'.

* Le mécanisme de substitution du script '{opsi-winst}' pour les constantes et les variables en entrant dans une section fait son travail prévu pour la section execPython.

* La sortie d'une section execPython peut être capturé dans une liste de chaînes et ensuite utilisé dans le script '{opsi-winst}' en cours.

Un exemple pour les deux premiers moyens d'imbrication du script Python avec le script '{opsi-winst}' est déjà donnée ci-dessus. Nous l'étendons pour récupérer les valeurs de certaines constantes ou variables '{opsi-winst}'.

[source,winst]
----
[execpython_hello]
import sys
a = "%scriptpath%"
print "we are working in path: ", a
print "my host ID is ", "%hostID%"
if len(sys.argv) > 1 :
	for arg in sys.argv[1:] :
		print arg
else: 
  print "no arguments"

print "the current loglevel is ", "$loglevel$" 
print "hello"
----

Bien sûr, la variable '$loglevel$' doit être fixée au préalable dans la section Actions:
[source,winst]
----
DefVar $LogLevel$
set $loglevel$ = getLoglevel
----

Enfin, afin d'être capable d'utiliser certains des résultats de la sortie de la section, nous les produisons dans une variable liste de chaîne en appelant la section execPython de la façon suivante: +
[source,winst]
----
DefStringList pythonresult
Set pythonResult = GetOutStreamFromSection('execpython_hello -a "opt a“')
----

[[opsi-winst-execpython-examples]]
==== Exemples

Pour d'autres exemples regarder le produit 'opsi-script-test' et là particulièrement 
'$Flag_compare_to_python$ = "on"'

[[opsi-winst-execwith]]
=== Sections ExecWith

Des sections 'ExecWith' sont plus générales que des sections 'ExecPython' ou 'ShellScript': Quel programme interprète les lignes de section donnée est déterminé par un paramètre d'appel de la section.

Par exemple, si nous avons des appels 

[source,winst]
----
execPython_hello -a "hello" -b "world"
----

où 

`-a "hello" -b "world"`

sont des paramètres qui sont passés au script python, nous obtenons l'appel suivant ExecWith complètement équivalente:

[source,winst]
----
execWith_hello "python" PASS -a "hello" -b "world" WINST /EscapeStrings
----

L'option '/EscapeStrings' est automatiquement utilisée dans une section ExecPython et signifie que l'antislash dans les variables et les constantes de chaîne sont dupliqués avant l'interprétation par le programme appelé. 


[[opsi-winst-execwith-params]]
==== Paramètres d'appel (Modificateur)

En général, nous avons la syntaxe d'appel:
[source,winst]
----
ExecWith_SECTION PROGRAM PROGRAMPARAS pass PASSPARAS winst WINSTOPTS
----

Chacune des expressions 'PROGRAM, PROGRAMPARAS, PASSPARAS, WINSTOPTS' peut être une expression chaîne arbitraire, ou juste une constante de chaîne (sans guillemets). 

Les mots-clés PASS et WINST peuvent être manquants si les parties respectives n'existent pas.

Les suivantes options '{opsi-winst}' sont disponibles:

* `/EscapeStrings`

* `/LetThemGo`

*  `/32Bit` +
Ceci est la valeur par défaut. Le chemin de l'interpréteur est supposé être un chemin 32 bits. +
Exemple: `c:\windows\system32\WindowsPowerShell\v1.0\powershell.exe` appelle (aussi lorsqu'il est exécuté sur un système 64 bit) le 'powershell.exe' 32 bit.

*  `/64Bit` +
Le chemin de l'interpréteur est supposé être un chemin 64 bits. +
Exemple: `c:\windows\system32\WindowsPowerShell\v1.0\powershell.exe` appelle (dans un système 64 bit) le 'powershell.exe' 64 bit.

*  `/SysNative` +
Le chemin de l'interpréteur est attribué en fonction de l'architecture OS. +
Exemple: `c:\windows\system32\WindowsPowerShell\v1.0\powershell.exe` appelle (dans un système 64 bit) le 'powershell.exe' 64 bit et dans un système 32bit le 'powershell.exe' 32 bit.

Comme avec les sections ExecPython, la sortie d'une section ExecWith peut être capturée dans une liste de chaînes via la fonction `getOutStreamFromSection`.

Le premier déclare que les antislash dans les variables et constantes '{opsi-winst}' sont C-like escaped. Le second a pour effet (comme pour les appels 'winBatch') que le programme appelé commence son travail dans un nouveau thread tandis que '{opsi-winst}' continue à interpréter son script.

Depuis la version 4.11.3.5, si le chemin de l'interpréteur contient 'powershell.exe', le fichier temporaire est enregistré avec l'extension `.ps1`.

[[opsi-winst-execwith-examples]]
==== Autres exemples

L'appel suivant fait référence à une section qui est un script AutoIt3 qui attend pour des fenêtres à venir (donc l'option /letThemGo est utilisée) afin de les fermer:

[source,winst]
----
ExecWith_close "%SCRIPTPATH%\autoit3.exe" WINST /letThemGo 
----

Un simple 
[source,winst]
----
ExecWith_edit_me "notepad.exe"  WINST /letThemGo
----

appelle le bloc-notes et ouvre les lignes de la section dedans (mais sans aucune ligne qui commence par un point virgule puisque '{opsi-winst}' considère de telles lignes comme des commentaires et les élimine avant de les manipuler).

L'exemple suivant appelle la version 64 bits de powershell.exe.
[source,winst]
----
ExecWith_do_64bit_stuff "%System%\WindowsPowerShell\v1.0\powershell.exe" winst /64Bit
----

Pour d'autres exemples regarder le produit 'opsi-script-test' et là particulièrement 
'$Flag_autoit3_test$ = "on"'

[[opsi-winst-ldapsearch]]
=== Sections LDAPsearch

Une section LDAPsearch définit une requête de recherche dans un annuaire LDAP, l'exécute et reçoit (et éventuellement met en cache) la réponse. 

Avant de s'attarder sur les commandes '{opsi-winst}' nous donnons quelques explications.

Dans le paragraphe, nous donnons un exemple de l'utilisation la plus probable de LDAPsearch.
Les sections suivantes décrivent la syntaxe 

[[opsi-winst-ldapsearch-general]]
==== LDAP – Protocole, Service, Annuaire

LDAP, "Lightweight Directory Access Protocol", est, comme son nom l'indique, une voie définie de communication avec un annuaire. Cet annuaire est (ou peut être) organisées hiérarchiquement. Autrement dit, l'annuaire est une base de données hiérarchique, ou un arbre de contenu. 

Un *service LDAP* implémente le protocole. Un annuaire qui peut être consulté via un service LDAP est appelé un *annuaire LDAP*.

Par exemple, jetons un regard sur une partie de l'arborescence de l'annuaire LDAP d'un serveur opsi avec le backend LDAP (comme le montre l'outil Open Source JXplorer):

.Vue sur une partie d'un arbre LDAP opsi
image::ldap-in-jxplorer.png["opsi LDAP tree",width=400]

Une *requête LDAP* est une requête à un annuaire LDAP via un service LDAP. La réponse renvoie une partie du contenu de l'annuaire.

Essentiellement, la requête doit décrire le chemin dans l'arborescence de l'annuaire qui mène à l'information souhaité. Le chemin est le *distinguished name* (dn) (nom distinctif), composé des noms des noeuds (les "noms unique relatifs"), qui construisent le chemin, par exemple:

'local/uib/opsi/generalConfigs/bonifax.uib.local'

Comme chaque nœud est conçu comme une instance d'une classe d'objet structurelle, la description de chemin est généralement donnée dans la forme suivante: avec indication des classes (et en commençant par e dernièr élément de chemin) :

'cn=bonifax.uib.local,cn=generalConfigs,cn=opsi,dc=uib,dc=local'

Le chemin dans une requête n'est pas nécessairement "complet", et ne conduit pas à une feuille unique de l'arbre. Au contraire, des chemins partiels sont communs. 

Mais même si le chemin descend vers une feuille unique, la feuille peut contenir plusieurs valeurs. Chaque nœud de l'arbre a une ou plusieurs classes comme types d'attributs. Pour chacun, une ou plusieurs valeurs peuvent être associées. 

Pour un chemin de requête donnée, nous pouvons donc être intéressés 

. Dans le jeu de noeud dont les éléments - les objets LDAP prétendus - correspondent au chemin donné, 

. Le jeu des attributs qui appartiennent aux noeuds,

. et les valeurs qui sont associées à chacun d'eux.

Évidemment, le traitement de la quantité d'informations de réponse, probablement rendues, est le principal défi lorsqu'il s'agit de recherches LDAP.

La section suivante présente la documentation d'un LDAPsearch correspondant approximativement à la capture d'écran ci-dessus comme exécuté par '{opsi-winst}'.

Exemple

Utilisation de la section '{opsi-winst}' `ldapsearch_generalConfigs`:
[source,winst]
----
[ldapsearch_generalConfigs] 
targethost: bonifax        
dn: cn=generalConfigs,cn=opsi,dc=uib,dc=local
----

nous allons obtenir une réponse comme celle-ci:
[source,ini]
----
Result: 0
 Object: cn=generalConfigs,cn=opsi,dc=uib,dc=local
  Attribute: cn
	generalConfigs
  Attribute: objectClass
	organizationalRole
Result: 1
  Object: cn=pcbon4.uib.local,cn=generalConfigs,cn=opsi,dc=uib,dc=local
  Attribute: cn
	pcbon4.uib.local
  Attribute: objectClass
	opsiGeneralConfig
  Attribute: opsiKeyValuePair
	test2=test
	test=a b c d
Result: 2
  Object: cn=bonifax.uib.local,cn=generalConfigs,cn=opsi,dc=uib,dc=local
  Attribute: objectClass
	opsiGeneralConfig
  Attribute: cn
	bonifax.uib.local
  Attribute: opsiKeyValuePair
	opsiclientsideconfigcaching=FALSE
	pcptchlabel1=opsi.org
	pcptchlabel2=uib gmbh
	button_stopnetworking=
	pcptchbitmap1=winst1.bmp
	pcptchbitmap2=winst2.bmp
	debug=on
	secsuntilconnectiontimeout=280
	opsiclientd.global.log_level=
----

Il y a plusieurs options '{opsi-winst}' pour gérer et réduire la complexité de l'évaluation de ces réponses.

[[opsi-winst-ldapsearch-params]]
==== Paramètres d'appel LDAPsearch

Deux types de paramètres LDAPsearch, 

* options de cache
* options de sortie

sont définies pour l'appel de la section LDAPsearch.

Les 'options de cache' sont:

* `/cache`

* `/cached`

* `/free`

* (aucune option de cache)

S'il n'y a pas d'option de cache spécifiée, la réponse de la requête LDAP n'est pas sauvé pour d'autres usages.

Avec l'option `/cache`, la réponse est mise en cache pour les évaluations ultérieures, l'option `/cached` se réfère à la dernière réponse en cache qui est réutilisé au lieu de commencer une nouvelle recherche, l'option `/free` efface le cache explicitement (peut être utile seulement pour les recherches avec des réponses extrêmement large).

Les 'options de sortie' sont: 

* `/objects`

* `/attributes`

* `/values`

* (pas d'option de sortie)

Les options de sortie déterminent la liste de chaîne qui est produite quand une section LDAPsearch est appelé par getReturnlistFromSection:

* Si aucune option de sortie n'est spécifiée la liste retournée est la réponse complète LDAP.

* Les options objets, attributs et valeurs réduisent la sortie aux lignes de l'objet, de l'attribut ou de la valeur de la réponse LDAP, respectivement. 

Observez que dans les listes produits l'objet et l'attribut sont uniquement identifiables si un seul objet est renvoyé dans la liste d'objets, et de même l'objet et l'attribut dans laquelle une valeur est englobée, ne sont identifiables que s'il n'y a qu'un attribut restant dans la liste des attributs.

La procédure est telle, que LDAPsearch est spécifié allant jusqu'à ce degré, qu'au maximum un objet et un attribut est retournée. Ceci peut être vérifié par un appell de comptage sur les objets et la liste des attributs de retour. Alors n'importe quelle valeur trouvée appartient au dn et à l'attribut spécifié. 

L'utilisation répétée de la même réponse LDAP peut être fait sans considérables frais de temps en utilisant les options cache/cached. 

[[opsi-winst-ldapsearch-narrow-search]]
==== Comment affiner la recherche

Un exemple peut montrer comment nous pouvons restreindre la recherche à cerner un résultat spécifique à partir d'un annuaire LDAP.

Nous commençons par l'appel de 'ldapsearch_generalConfigs' comme ci-dessus, seulement en ajoutant le paramètre de cache.

`ldapsearch_generalconfigs /cache`

exécute la requête et met en cache la réponse pour une utilisation ultérieure.

Ensuite, l'appel

`getReturnlistFromSection("ldapsearch_generalconfigs /cached /objects")`

produit la liste
[source,ini]
----
cn=generalconfigs,cn=opsi,dc=uib,dc=local
cn=pcbon4.uib.local,cn=generalconfigs,cn=opsi,dc=uib,dc=local
cn=bonifax.uib.local,cn=generalconfigs,cn=opsi,dc=uib,dc=local
----
Si nous rétrécissons la sélection d'arbre par 

[source,winst]
----
[ldapsearch_generalConfigs]  
targethost: bonifax               
dn: cn=bonifax.ubi.local,cn=generalConfigs,cn=opsi,dc=uib,dc=local
----
et recommençons, puis dans la liste des objets, nous conservons en effet juste 
[source,ini]
----
cn=bonifax.uib.local,cn=generalconfigs,cn=opsi,dc=uib,dc=local
----

La liste correspondante des attributs contient trois éléments:
[source,ini]
----
objectclass
cn
opsikeyvaluepair
----
Afin d'obtenir les valeurs associées à un seul attribut nous devons limiter la requête une fois de plus:

[source,winst]
----
[ldapsearch_generalConfigs]  
targethost: bonifax               
dn: cn=bonifax.ubi.local,cn=generalConfigs,cn=opsi,dc=uib,dc=local
attribute: opsiKeyValuePair
----
Le résultat produit maintenant est une liste d'attributs contenant un seul élément. La liste correspondante des valeurs ressemble à

[source,ini]
----
opsiclientsideconfigcaching=false
pcptchlabel1=opsi.org
pcptchlabel2=uib gmbh
button_stopnetworking=
pcptchbitmap1=winst1.bmp
pcptchbitmap2=winst2.bmp
debug=on
secsuntilconnectiontimeout=280
opsiclientd.global.log_level=6
----
Il n'y a pas moyens de réduire LDAP outre ce résultat!

(Mais la fonction '{opsi-winst}' `getValue (key, list)` (voir <<opsi-winst-stringlist-getstring>>) peut aider dans ce cas: Ex. +
`getValue ("secsuntilconnectiontimeout", list)` +
aurait produit le numéro demandé).

Par la fonction `count (list)` nous pouvons vérifier si nous avons réussi avec le rétrécissement de la demande de recherche. Dans la plupart des circonstances, nous aimerions que son résultat soit "1".

[[opsi-winst-ldapsearch-syntax]]
==== Syntaxe d'une Section LDAPsearch

Une section ldapsearch comprend les spécifications:

* `targethost:` +
Le serveur hébergeant l'annuaire LDAP (services) doit être nommé.

*  `user:` +
nom d'utilisateur à appliquer. Depuis 4.11.3.5

*  `password:` +
mot de passe d'utilisateur à appliquer. Depuis 4.11.3.5

* `targetport:` +
Si le port du service LDAP n'est pas celui par défaut (389), il peut être déclaré à cet endroit. Si la spécification est manquante, le port par défaut est utilisée.

* `dn:` +
Ici, le nom unique, le "chemin de recherche", pour la demande de recherche peut être donnée.

* `typesonly:` +
Par défaut "false", signifie que les valeurs sont récupérées.

* `filter:` +
Un filtre pour la recherche LDAP avec une syntaxe spécifique à LDAP qui n'est pas contrôlé par '{opsi-winst}'. La valeur par défaut est "(objectclass=*)"

* `attributes:` +
Une liste, séparée par des virgules, des noms d'attributs peut être donnée. La valeur par défaut est de prendre n'importe quel attribut.

[[opsi-winst-ldapsearch-examples]]
==== Exemples

Un exemple court et plutôt réaliste termine cette section:

'$founditems$' est une variable liste de chaînes et '$opsiClient$' une variable chaîne. L'appel de 'getReturnlistFromSection' récupère les résultats de la section 'ldapsearch_hosts'. Le fragment de code suivant renvoie le résultat unique pour $opsiDescription$ s'il en existe. Il signale une erreur si la recherche aboutit à un résultat inattendu:
[source,winst]
----
set $opsiClient$ = "test.uib.local"
set $founditems$ = getReturnlistFromSection("ldapsearch_hosts /values")

DefVar $opsiDescription$
set $opsiDescription$ = ""
if count(founditems) = "1"
  set $opsiDescription$ = takeString(0, founditems)
else
  if count(founditems) = "0"
    comment "No result found")
  else
    logError "No unique result for LdAPsearch for client " + $opsiclient$ 
  endif
endif


[ldapsearch_hosts]  
targethost: opsiserver
targetport:               
dn: cn=$opsiclient$,cn=hosts,cn=opsi,dc=uib,dc=local
typesOnly: false
filter: (objectclass=*)
attributes: opsiDescription
----

Exemple avec utilisateur / mot de passe
[source,winst]
----
comment ""
comment "-------------------------------------"
comment "Testing: "
comment "user / password"
Set $LdapHost$ = "vmix7.uib.local"
Set $LdapPort$ = "389"
Set $LdapUser$ = "cn=Administrator,cn=Users,dc=uib,dc=local"
Set $LdapPassword$ = "Linux123"
Set $LdapResultType$ = "objects"
Set $LdapSearchDn$ = "cn=Users,dc=uib,dc=local"
Set $LdapSearchAttributes$ = "name,objectClass"
Set $LdapFilter$ = "(&(objectclass=*))"

markErrorNumber
set $list1$ = getReturnListFromSection("ldapsearch_users /" + $LdapResultType$)
if errorsOccuredSinceMark > 0
	comment "failed while ldapsearch"
	set $TestResult$ = "not o.k."
else
	comment "passed"
endif

[ldapsearch_users]
targethost: $LdapHost$
targetport: $LdapPort$
user: $LdapUser$
password: $LdapPassword$
dn: $LdapSearchDn$
attributes: $LdapSearchAttributes$
filter: $LdapFilter$
----


Pour d'autres exemples regarder le produit 'opsi-script-test' particulièrement 
'$Flag_winst_ldap_search$ = "on"'

[[opsi-winst-64bit]]
== Support 64 Bit

'{opsi-winst}' est un logiciel 32 bit. Afin de rendre facile l'exécution des programmes 32 bit dans des systèmes 64 bit il y a des zones spéciales 32 bit dans le registre comme aussi dans le système de fichier. Certains accès des programmes 32 bit seront redirigés vers ces zones spéciales pour empêcher l'accès à des zones réservées aux logiciels 64 bit.

Un accès à `c:\windows\system32` sera redirigé vers `c:\windows\syswow64`

Mais un accès à `c:\program files` *ne* sera *pas* redirigé vers `c:\program files (x86)`

Un accès au registre à '[HKLM\software\opsi.org]' sera redirigé vers '[HKLM\software\wow6432node\opsi.org]'

Par conséquent '{opsi-winst}' installe comme programme 32 bit les scripts, qui s'exécutent bien sur un système 32 bit, sur un système 64 bit system correctement sans aucune modification.

Pour l'installation de programmes en 64 bit certaines constantes comme `%ProgramFilesDir%` renvoient des valeurs erronées. C'est pourquoi nous avons, depuis '{opsi-winst}' 4.10.8, quelques nouvelles fonctionnalités:

Normalement, vous pouvez (et devriez) dire explicitement à quel endroit vous voulez écrire ou à partir d'ou vous voulez lire. Nous avons trois variantes:

32:: explicitement 32 bit

64:: explicitement 64 bit; s'il n'est pas dans un système 64 bit comme 'sysnative'

SysNative:: conformement à l'architecture sur laquelle le script s'exécute

Suivant cette idée, on as quelques constantes supplémentaires:

.Constantes
[options="header"]
|=======================
|Constant|32 Bit|64 Bit
|`%ProgramFilesDir%`|c:\program files|c:\program files (x86)
|`%ProgramFiles32Dir%`|c:\program files|c:\program files (x86)
|`%ProgramFiles64Dir%`|c:\program files|c:\program files
|`%ProgramFilesSysnativeDir%`|c:\program files|c:\program files
|=======================


`%ProgramFilesDir%`:: vous devriez éviter cela à l'avenir...

`%ProgramFiles32Dir%`:: doit être utilisé dans le contexte de l'installation de logiciel à 32 bits.

`%ProgramFiles64Dir%`:: doit être utilisé dans le contexte de l'installation de logiciel à 64 bits.

`%ProgramFilesSysnativeDir%`:: devrait être utilisée que si vous avez besoin d'informations spécifique de l'architecture

Pour un accès en lecture aux différentes zones du registre et du système de fichiers nous avons maintenant les nouvelles fonctions suivantes:

* `GetRegistrystringvalue32`
* `GetRegistrystringvalue64`
* `GetRegistrystringvalueSysNative`
* `FileExists32`
* `FileExists64`
* `FileExistsSysNative`

Un simple appel à une section Registry produit une écriture vers la zone 32 bit du registre. De la même manière un simple appel vers une section Files produit une écriture dans la zone 32 bit du système de fichiers.

Pour les sections 'Registry', 'Files' et `ShellScript` nous avons des options d'appel supplémentaires:

* `/32Bit` +
Par dèfaut. Tous les accès seront redirigés vers une région 32 bit.

* `/64Bit` +
Tous les accès seront redirigés vers une région 64 bit. S'il n'y a pas de regions 64 bit sera utilisé la région spécifique de l'architecture.

* `/SysNative` +
Tout accès sera redirigé vers les régions spécifique à l'architecture

Pour `ShellScript` vous devez garder à l'esprit que tous les modificateurs doit séparés par le mot-clé `winst`. +
Exemple:
[source,winst]
----
ShellScript_do_64bit_stuff winst /64Bit
----

En plus de ces fonctions '{opsi-winst}', nous copions à l'installation de opsi-client-agent le fichier (64 bit) `c:\windows\system32\cmd.exe` dans `c:\windows\cmd64.exe`. En utilisant `cmd64.exe` avec des sections 'ExecWith'  vous pouvez appeler toutes les opérations 64 bits sur la ligne de commande.

Exemples:

Manipulation des fichiers:
[source,winst]
----
if $INST_SystemType$ = "64 Bit System"
	comment ""
	comment "-------------------------------------"
	comment "Testing: "
	message "64 Bit redirection"
	Files_copy_test_to_system32
	if FileExists("%System%\dummy.txt")
		comment "passed"
	else
		LogWarning "failed"
		set $TestResult$ = "not o.k."
	endif
	ExecWith_remove_test_from_system32 'cmd.exe' /C
	Files_copy_test_to_system32 /64Bit
	if FileExists64("%System%\dummy.txt")
		comment "passed"
	else
		LogWarning "failed"
		set $TestResult$ = "not o.k."
	endif
	ExecWith_remove_test_from_system32 '%SystemRoot%\cmd64.exe' /C
endif
----

Manipulation du registre:
[source,winst]
----
message "Write to 64 Bit Registry"
if ($INST_SystemType$ = "64 Bit System")
	set $ConstTest$ = ""
	set $regWriteValue$ = "64"
	set $CompValue$ = $regWriteValue$
	Registry_opsi_org_test /64Bit
	ExecWith_opsi_org_test "%systemroot%\cmd64.exe" /c
	set $ConstTest$ = GetRegistryStringValue64("[HKEY_LOCAL_MACHINE\SOFTWARE\opsi.org\test] bitByWinst")
	if ($ConstTest$ = $CompValue$)
		comment "passed"
	else
		set $TestResult$ = "not o.k."
		comment "failed"
	endif
	set $ConstTest$ = GetRegistryStringValue64("[HKEY_LOCAL_MACHINE\SOFTWARE\opsi.org\test] bitByReg")
	if ($ConstTest$ = $CompValue$)
		comment "passed"
	else
		set $TestResult$ = "not o.k."
		comment "failed"
	endif
	set $regWriteValue$ = "32"
	set $CompValue$ = $regWriteValue$
	Registry_opsi_org_test
	ExecWith_opsi_org_test "cmd.exe" /c
	set $ConstTest$ = GetRegistryStringValue("[HKEY_LOCAL_MACHINE\SOFTWARE\opsi.org\test] bitByWinst")
	if ($ConstTest$ = $CompValue$)
		comment "passed"
	else
		set $TestResult$ = "not o.k."
		comment "failed"
	endif
	set $ConstTest$ = GetRegistryStringValue("[HKEY_LOCAL_MACHINE\SOFTWARE\opsi.org\test] bitByReg")
	if ($ConstTest$ = $CompValue$)
		comment "passed"
	else
		set $TestResult$ = "not o.k."
		comment "failed"
	endif
else
	set $regWriteValue$ = "32"
	set $CompValue$ = $regWriteValue$
	Registry_opsi_org_test /64Bit
	ExecWith_opsi_org_test "cmd.exe" /c
	set $ConstTest$ = GetRegistryStringValue64("[HKEY_LOCAL_MACHINE\SOFTWARE\opsi.org\test] bitByWinst")
	if ($ConstTest$ = $CompValue$)
		comment "passed"
	else
		set $TestResult$ = "not o.k."
		comment "failed"
	endif
	set $ConstTest$ = GetRegistryStringValue64("[HKEY_LOCAL_MACHINE\SOFTWARE\opsi.org\test] bitByReg")
	if ($ConstTest$ = $CompValue$)
		comment "passed"
	else
		set $TestResult$ = "not o.k."
		comment "failed"
	endif
endif

if ($INST_SystemType$ = "64 Bit System")
	set $regWriteValue$ = "64"
	Registry_hkcu_opsi_org_test /AllNtUserDats /64Bit
	set $regWriteValue$ = "32"
	Registry_hkcu_opsi_org_test /AllNtUserDats 
else
	set $regWriteValue$ = "32"
	Registry_hkcu_opsi_org_test /AllNtUserDats 
	Registry_hkcu_opsi_org_test /AllNtUserDats /64Bit
endif
----

[[opsi-winst-cookbook]]
== Cook Book

Ce chapitre contient une collection croissante d'exemples montrant les problèmes du monde réel qui peuvent être maîtrisés par des morceaux simples ou sophistiqués the scripts '{opsi-winst}'.

[[opsi-winst-cookbook-recursive-delete]]
=== 9.1. Supprimer un fichier dans tous les sous-répertoires

Depuis '{opsi-winst}' 4.2 il y a une solution facile pour cette tâche: Pour supprimer un fichier alt.txt de tous les sous-répertoires du répertoire du profil utilisateur l'appel suivant Files peut être utilisé:
[source,winst]
----
files_delete_Alt /allNtUserProfiles

[files_delete_Alt]
delete "%UserProfileDir%\alt.txt"
----
Toutefois nous documentons une solution de contournement qui pourrait être utilisé dans les anciennes versions de '{opsi-winst}'. Cela démontre quelques techniques qui pourrait être utile à d'autres fins.

Les composants suivants sont nécessaires:

* Une section ShellScript qui produit une liste de tous les noms de répertoire.
* Une section Files qui supprime le fichier alt.txt dans un répertoire.
* Un traitement de la liste de chaîne qui met les pièces ensemble.

Le script complet devrait ressembler à:

[source,winst]
----
[Actions]

; variable for file name
DefVar $deleteFile$
set $deleteFile$ = "alt.txt"

; String list declarations
DefStringList list0
DefStringList list1

; capture the lines produced by the dos dir command
Set list0 = getOutStreamFromSection ('ShellScript_profiledir')

; Loop through the lines. Call a files section for each line.
for $x$ in list0 do files_delete_x

; Here are the two special sections
[ShellScript_profiledir]
@dir "%ProfileDir%" /b

[files_delete_x]
delete "%ProfileDir%\$x$\$deleteFile$"
----

[[opsi-winst-cookbook-service-running]]
=== Vérifier si un service spécifique est en marche

Si nous voulons vérifier si un service spécifique (par exemple "opsiclientd") s'exécute, et, par exemple, s'il ne s'exécute pas, le lancer, nous pouvons utiliser le script suivant.

Pour obtenir la liste des services qui s'exécutent nous lançons la commande 

`net start`

dans une section ShellScript, sauvegardant le résultat dans list0. Nous découpons la liste, et parcourons ses éléments, pour voir si le service spécifié s'y trouve. Si non, nous faisons quelque chose pour lui.
[source,winst]
----
[Actions]
DefStringList $list0$
DefStringList $list1$
DefStringList $result$
Set $list0$=getOutStreamFromSection('ShellScript_netcall')
Set $list1$=getSublist(2:-3, $list0$)

DefVar $myservice$
DefVar $compareS$
DefVar $splitS$
DefVar $found$
Set $found$ ="false"
set $myservice$ = "opsiclientd"


comment "============================"
comment "search the list"
; for developping loglevel = 7
; setloglevel=7
; in normal use we dont want to log the looping
setloglevel = 5
for %s% in $list1$ do sub_find_myservice
setloglevel=7
comment "============================"

if $found$ = "false"
   set $result$ = getOutStreamFromSection ("ShellScript_start_myservice")
endif


[sub_find_myservice]
set $splitS$ = takeString (1, splitStringOnWhiteSpace("%s%"))
Set $compareS$ = $splitS$ + takeString(1, splitString("%s%", $splitS$))
if $compareS$ = $myservice$
   set $found$ = "true"
endif


[ShellScript_start_myservice]
net start "$myservice$"


[ShellScript_netcall]
@echo off
net start 
----

[[opsi-winst-cookbook-local-admin]]
=== Script pour les installations dans le contexte d'un Administrateur local

Parfois, il est nécessaire d'exécuter un script d'installation en tant qu'utilisateur locale et pas dans le cadre du service opsi. Par exemple, il y a des installations qui nécessitent un contexte utilisateur ou qu'ils utilisent d'autres services qui sont démarrés après un login de l'utilisateur. 

Les installations MSI qui semblent avoir besoin d'un utilisateur local peuvent parfois être configurées avec l'option 'ALLUSERS=1' pour procéder sans un tel utilisateur:
[source,winst]
----
[Actions]
DefVar $LOG_LOCATION$
Set $LOG_LOCATION$ = "c:\tmp\myproduct.log"
winbatch_install_myproduct

[winbatch_install_myproduct]
msiexec /qb ALLUSERS=1 /l* $LOG_LOCATION$ /i %SCRIPTPATH%\files\myproduct.msi
----
Dans les autres cas il est nécessaire de créer un utilisateur administratif temporaire dans le contexte duquel l'installation se déroule. Cela peut être fait comme suit:

* Créez un nouveau produit basé sur le produit `opsi-template-with-admin`
* Créez un répertoire 'localsetup' dans le répertoire produit (ex. dans 'install\productId').

* Déplacez tous les fichiers d'installation dans le répertoire 'CLIENT_DATA\localsetup'.

* Assurez-vous que votre script de configuration dans 'CLIENT_DATA\localsetup' commence par un appel au redémarrage:
[source,winst]
----
[Actions]
ExitWindows /Reboot
----

* Modifiez dans 'CLIENT_DATA\setup.ins' les variables qui sont indiquées avec: `Please edit the following values`.

Le modèle de script '{opsi-winst}' génère temporairement un contexte utilisateur, exécute une installation dedans, puis le supprime. Avant d'utiliser le modèle les valeurs suivantes doivent être mis de façon adéquate:

* la valeur de la variable '$Productname$'
* la valeur de la variable '$ProductSize$'
* la valeur de la variable `$LocalSetupScript$` (le nom de votre script de configuration).

Le script se déroule comme suit:

* Il crée un administrateur local opsiSetupAdmin;
* enregistre l'état de session automatique;
* insère opsiSetupAdmin en tant qu'utilisateur d'une session automatique;
* copie les fichiers d'installation sur le client (tel que défini dans $localFilesPath$); parmi eux le script d'installation qui doit être exécutée dans le cadre d'utilisateur local;
* crée une entrée RunOnce dans la base de registre qui appelle '{opsi-winst}' avec le script local comme argument;
* redémarre afin de rendre la modification de la base de registre fonctionnante;
* quand '{opsi-winst}' s'exécute à nouveau, il appelle ExitWindows /ImmediateLogout, et deuxieme niveau de script se lance:
* Avec l'ouverture de session automatique , opsiSetupAdmin est connecté sans interaction de l'utilisateur.
* Windows appelle la commande RunOnce, qui est un appel '{opsi-winst}'.
* Le script '{opsi-winst}' devrait désormais régulièrement procéder. Mais à sa fin, il doit y avoir une commande ExitWindows /ImmediateReboot. Sinon, l'utilisateur administratif opsiSetupAdmin qui est déjà connecté serait accessible.
* après le redémarrage, le script principal s'exécute à nouveau pour tout nettoyer (réécriture de l'état autologon ancien, suppression des fichiers de configuration locaux, suppression du profilopsiSetupAdmin)

Nous appelons les deux scripts '{opsi-winst}' concernés : script maître et script local . Le premier s'exécute dans un contexte de service du système, le deuxième, qui fait l'installation de logiciel spécifique, s'exécute dans le contexte d'un administrateur local.


CAUTION: Si le script local nécessite en interne d'un redémarrage, alors le script maître doit être adapté pour le produire. Aussi longtemps que le script local n'est pas terminé, le script maître prend la main sur le contrôle du script locale avec un `ExitWindows /ImmediateLogout`. Bien sûr, l'entrée RunOnce doit être créé pour chaque exécution. Puisque le nom d'utilisateur et son mot de passe pour l'ouverture de la session automatique sont supprimés au début du script local, ils doivent être remis à zéro à chaque fois ainsi.

Il y a (depuis opsi 4.0.2-2) un accès direct à partir du script local aux propriétés de produits.

Il peut y avoir des installations de produits par les appels externes du programme d'installation qui changent les entrées de registre qui sont enregistrés par le script maître et généralement écrites en retour à la fin de l'installation. Dans ce cas, le script maître doit être adapté pour éviter d'écrire le retour.

Le script local fonctionne avec un administrateur connecté. Vous devez verrouiller le clavier lorsque le test est fait. Autrement n'importe qui assis devant le client pourrait arrêter l'exécution du script et prendre le contrôle de la session. Donc le produit a une propriété du produit `debug` qui commute vers le verrouillage d'entrée et le niveau de journalisation.

Afin d'éviter l'enregistrement des mots de passe le niveau de journalisation est temporairement réglé sur -2.

IMPORTANT: S'il vous plaît n'utilisez pas le script tel qu'il est affiché ci-dessous, mais utilisez le produit opsi: opsi-template-with-admin.

[source,winst]
----
; Copyright (c) uib gmbh (www.uib.de)
; This sourcecode is owned by uib
; and published under the Terms of the General Public License.

; TEMPLATE for
; Skript fuer Installationen im Kontext eines temporaeren lokalen Administrators
; installations as temporary local admin
; see winst_manual.pdf / winst_handbuch.pdf

;
; !!! Das lokale Installations-Skript, das durch den temporaeren lokalen Admin ausgefuehrt wird
; !!! (sein Name steht in $LocalSetupScript$), muss mit dem Befehl  
; !!! exitWindows /Reboot
; !!! enden
; 

; !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
; Vorarbeiten/Voraussetzungen/Doku pruefen wie in Winsthandbuch
;  Skript fuer Installationen im Kontext eines lokalen Administrators
; !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!


[Actions]
requiredWinstVersion >= 4.11.3.3
setLogLevel=7
DefVar $ProductName$
DefVar $ProductSizeMB$
DefVar $LocalSetupScript$
DefVar $LockKeyboard$
DefVar $OpsiAdminPass$
DefVar $RebootFlag$
DefVar $WinstRegKey$
DefVar $AutoName$
DefVar $AutoPass$
DefVar $AutoDom$
DefVar $AutoLogon$
DefVar $AutoBackupKey$
DefVar $LocalFilesPath$
DefVar $LocalWinst$
DefVar $DefaultLoglevel$
DefVar $PasswdLogLevel$
DefVar $AdminGroup$
DefVar $SearchResult$
DefVar $LocalDomain$
DefVar $debug$
DefVar $isFatal$

; ----------------------------------------------------------------
; - Please edit the following values
; ----------------------------------------------------------------
Set $ProductName$ = "opsi-template-with-admin"
Set $ProductSizeMB$ = "1"
Set $LocalSetupScript$ = "setup32.ins"
; ----------------------------------------------------------------

comment "get and set initial values..."
set $debug$ = GetProductProperty("debug","false")
set $isFatal$ = "false"
set $DefaultLoglevel$ = "7"
SetLogLevel=$DefaultLoglevel$
Set $LocalDomain$ = "%PCNAME%"

comment "check if we productive or debugging..."
if $debug$ = "true"
	comment "we are in debug mode"
	Set $LockKeyboard$="false"
	Set $PasswdLogLevel$="7"
else
	comment "we are in productive mode"
	comment "set $LockKeyboard$ to true to prevent user hacks while admin is logged in"
	Set $LockKeyboard$="true"
	comment " set $PasswdLogLevel$ to 0 for production"
	Set $PasswdLogLevel$="0"
endif

comment "handle Rebootflag"
Set $WinstRegKey$ = "HKLM\SOFTWARE\opsi.org\winst"
Set $RebootFlag$ = GetRegistryStringValue32("["+$WinstRegKey$+"] "+"RebootFlag")

comment "some paths required"
Set $AutoBackupKey$ = $WinstRegKey$+"\AutoLogonBackup"
Set $LocalFilesPath$ = "C:\opsi.org\tmp\opsi_local_inst"
Set $LocalWinst$ = "%ProgramFilesDir%\opsi.org\opsi-client-agent\opsi-winst\winst32.exe"
if not( FileExists($LocalWinst$) )
	LogError "No opsi-winst found. Abborting."
	isFatalError
endif

comment "show product picture"
ShowBitmap "%scriptpath%\localsetup\"+$ProductName$+".png" $ProductName$

if not (($RebootFlag$ = "1") or ($RebootFlag$ = "2") or ($RebootFlag$ = "3"))
	comment "Part before first Reboot"
	comment "just reboot - this must be done if this is the first product after OS installation"
	comment "handle Rebootflag"
	Set $RebootFlag$ = "1"
	Registry_SaveRebootFlag /32bit
	;ExitWindows /ImmediateReboot
endif ; Rebootflag = not (1 or 2 or 3)

if $RebootFlag$ = "1"
	comment "Part before second Reboot"
	setActionProgress "Preparing"

	if not(HasMinimumSpace ("%SYSTEMDRIVE%", ""+$ProductSizeMB$+" MB"))
		LogError "Not enough space on drive C: . "+$ProductSizeMB$+" MB on C: required for "+$ProductName$
		isFatalError
	endif
	
	comment "Lets work..."
	Message "Preparing "+$ProductName$+" install step 1..."
	sub_Prepare_AutoLogon

	comment "we need to reboot now to be sure that the autologon work"
	comment "handle Rebootflag"
	Set $RebootFlag$ = "2"
	Registry_SaveRebootFlag /32bit
	ExitWindows /ImmediateReboot
endif ; Rebootflag = not (1 or 2)

if ($RebootFlag$ = "2")
	comment "Part after first Reboot"
	
	comment "handle Rebootflag"
	Set $RebootFlag$ = "3"
	Registry_SaveRebootFlag /32bit
	
	comment "Lets work..."
	Message "Preparing "+$ProductName$+" install step 2..."
	Registry_enable_keyboard /sysnative

	comment "now let the autologon work"
	comment "it will stop with a reboot"
	setActionProgress "Run Installation"
	
	ExitWindows /ImmediateLogout
endif ; Rebootflag = 2

if ($RebootFlag$ = "3")
	comment "Part after second Reboot"
	ExitWindows /Reboot
	setActionProgress "Cleanup"
	comment "handle Rebootflag"
	Set $RebootFlag$ = "0"
	Registry_SaveRebootFlag /32bit
	
	comment "Lets work..."
	Message "Cleanup "+$ProductName$+" install (step 3)..."
	sub_Restore_AutoLogon
	set $SearchResult$ = GetRegistryStringValueSysnative("[HKLM\SOFTWARE\Microsoft\Windows\CurrentVersion\RunOnce] opsi_autologon_setup")
	if $SearchResult$ = $LocalWinst$+" "+$LocalFilesPath$+"\"+$LocalSetupScript$+" /batch /productid %installingProdName%"
		LogError "Localscript did not run. We remove the RunOnce entry and abort"
		Registry_del_runonce /sysnative
		set $isFatal$ = "true"
	endif
	if "true" = getRegistryStringValue32("[HKLM\Software\opsi.org\winst] with-admin-fatal")
		LogError "set to fatal because the local script stored this result"
		set $isFatal$ = "true"
	endif
	comment "cleanup the registry key which stores a fatal result of the local script"
	Registry_clean_fatal_flag /32bit
	if $isFatal$ = "true"
		isFatalError
	endif
	comment "This is the clean end of the installation"
endif ; Rebootflag = 3


[sub_Prepare_AutoLogon]
comment "copy the setup script and files"
Files_copy_Setup_files_local
comment "read actual Autologon values for backup"
set $AutoName$ = GetRegistryStringValueSysnative("[HKLM\SOFTWARE\Microsoft\Windows NT\CurrentVersion\Winlogon] DefaultUserName")
comment "if AutoLogonName is our setup admin user, something bad happend"
comment "then let us cleanup"
if ($AutoName$="opsiSetupAdmin")
	set $AutoName$=""
	set $AutoPass$=""
	set $AutoDom$=""
	set $AutoLogon$="0"
else
	set $AutoPass$ = GetRegistryStringValueSysnative("[HKLM\SOFTWARE\Microsoft\Windows NT\CurrentVersion\Winlogon] DefaultPassword")
	set $AutoDom$ = GetRegistryStringValueSysnative("[HKLM\SOFTWARE\Microsoft\Windows NT\CurrentVersion\Winlogon] DefaultDomainName")
	set $AutoLogon$ = GetRegistryStringValueSysnative("[HKLM\SOFTWARE\Microsoft\Windows NT\CurrentVersion\Winlogon] AutoAdminLogon")
endif

comment "backup AutoLogon values"
Registry_save_autologon /32bit

comment "prepare the admin AutoLogon"
SetLogLevel=$PasswdLogLevel$
set $OpsiAdminPass$= randomstr
Registry_autologon /sysnative

comment "get the name of the admin group"
set $AdminGroup$ = SidToName("S-1-5-32-544")
comment "create our setup admin user"
ShellScript_makeadmin
SetLogLevel=$DefaultLoglevel$

comment "store our setup script as run once"
Registry_runOnce /sysnative

comment "disable keyboard and mouse while the autologin admin works"
if ($LockKeyboard$="true")
	Registry_disable_keyboard /Sysnative
endif

comment "cleanup the registry key which stores a fatal result of the local script"
Registry_clean_fatal_flag /32bit

[sub_Restore_AutoLogon]
comment "read AutoLogon values from backup"
set $AutoName$ = GetRegistryStringValue("["+$AutoBackupKey$+"] DefaultUserName")
set $AutoPass$ = GetRegistryStringValue("["+$AutoBackupKey$+"] DefaultPassword")
set $AutoDom$ = GetRegistryStringValue("["+$AutoBackupKey$+"] DefaultDomainName")
set $AutoLogon$ = GetRegistryStringValue("["+$AutoBackupKey$+"] AutoAdminLogon")

comment "restore the values"
SetLogLevel = $PasswdLogLevel$
Registry_restore_autologon /Sysnative
SetLogLevel = $DefaultLoglevel$
comment "delete our setup admin user"
ShellScript_deleteadmin
comment "cleanup setup script, files and profiledir"
Files_delete_Setup_files_local
comment "delete profiledir"
ShellScript_deleteprofile

[Registry_save_autologon]
openkey [$AutoBackupKey$]
set "DefaultUserName"="$AutoName$"
set "DefaultPassword"="$AutoPass$"
set "DefaultDomainName"="$AutoDom$"
set "AutoAdminLogon"="$AutoLogon$"

[Registry_restore_autologon]
openkey [HKLM\SOFTWARE\Microsoft\Windows NT\CurrentVersion\Winlogon]
set "DefaultUserName"="$AutoName$"
set "DefaultPassword"="$AutoPass$"
set "DefaultDomainName"="$AutoDom$"
set "AutoAdminLogon"="$AutoLogon$"

[ShellScript_deleteadmin]
NET USER opsiSetupAdmin  /DELETE

[Registry_SaveRebootFlag]
openKey [$WinstRegKey$]
set "RebootFlag" = "$RebootFlag$"

[Files_copy_Setup_files_local]
copy -s %ScriptPath%\localsetup\*.* $LocalFilesPath$

[Files_delete_Setup_files_local]
del -sf $LocalFilesPath$\
; folgender Befehl funktioniert nicht vollständig, deshalb ist er zur Zeit auskommentier
; der Befehl wird durch die Sektion "ShellScript_deleteprofile" ersetzt (P.Ohler)
;delete -sf "%ProfileDir%\opsiSetupAdmin"

[ShellScript_deleteprofile]
rmdir /S /Q "%ProfileDir%\opsiSetupAdmin"

[ShellScript_makeadmin]
NET USER opsiSetupAdmin $OpsiAdminPass$ /ADD
NET LOCALGROUP $AdminGroup$ /ADD opsiSetupAdmin

[Registry_autologon]
openkey [HKLM\SOFTWARE\Microsoft\Windows NT\CurrentVersion\Winlogon]
set "DefaultUserName"="opsiSetupAdmin"
set "DefaultPassword"="$OpsiAdminPass$"
set "DefaultDomainName"="$LocalDomain$"
set "AutoAdminLogon"="1"

[Registry_runonce]
openkey [HKLM\SOFTWARE\Microsoft\Windows\CurrentVersion\RunOnce]
set "opsi_autologon_setup"='"$LocalWinst$" "$LocalFilesPath$\$LocalSetupScript$" /batch /productid %installingProdName%'

[Registry_del_runonce]
openkey [HKLM\SOFTWARE\Microsoft\Windows\CurrentVersion\RunOnce]
DeleteVar "opsi_autologon_setup"

[Registry_disable_keyboard]
openkey [HKEY_LOCAL_MACHINE\SYSTEM\CurrentControlSet\Services\Kbdclass]
set "Start"=REG_DWORD:0x4
openkey [HKEY_LOCAL_MACHINE\SYSTEM\CurrentControlSet\Services\Mouclass]
set "Start"=REG_DWORD:0x4

[Registry_enable_keyboard]
openkey [HKEY_LOCAL_MACHINE\SYSTEM\CurrentControlSet\Services\Kbdclass]
set "Start"=REG_DWORD:0x1
openkey [HKEY_LOCAL_MACHINE\SYSTEM\CurrentControlSet\Services\Mouclass]
set "Start"=REG_DWORD:0x1

[Registry_clean_fatal_flag]
openkey [$WinstRegKey$]
DeleteVar "with-admin-fatal"
----

[[opsi-winst-cookbook-patchxml]]
=== Fichier XML Application de correctifs: Réglage du chemin du modèle pour OpenOffice.org 2

La définition du chemin du modèle peut être fait par les extraits de scripts suivants:

[source,winst]
----
[Actions]
; ....

DefVar $oooTemplateDirectory$
;----------------------------------------------------------------------
;set path here:

Set $oooTemplateDirectory$ = "file://server/share/verzeichnis"
;----------------------------------------------------------------------
;...

DefVar $sofficePath$
Set $sofficePath$= GetRegistryStringValue ("[HKEY_LOCAL_MACHINE\SOFTWARE\OpenOffice.org\OpenOffice.org\2.0] Path")
DefVar $oooDirectory$
Set $oooDirectory$= SubstringBefore ($sofficePath$, "\program\soffice.exe")
DefVar $oooShareDirectory$
Set $oooShareDirectory$ = $oooDirectory$ + "\share"

XMLPatch_paths_xcu $oooShareDirectory$+"\registry\data\org\openoffice\Office\Paths.xcu"
; ...


[XMLPatch_paths_xcu]
OpenNodeSet
- error_when_no_node_existing false
- warning_when_no_node_existing true
- error_when_nodecount_greater_1 false
- warning_when_nodecount_greater_1 true
- create_when_node_not_existing true
- attributes_strict false

documentroot
all_childelements_with:
elementname: "node"
attribute:"oor:name" value="Paths"
all_childelements_with:
elementname: "node"
attribute: "oor:name" value="Template"
all_childelements_with:
elementname: "node"
attribute: "oor:name" value="InternalPaths"
all_childelements_with: 
elementname: "node"

end

SetAttribute "oor:name" value="$oooTemplateDirectory$"
----

[[opsi-winst-cookbook-readxml]]
=== Récupération des valeurs à partir d'un fichier XML

Comme traité dans <<opsi-winst-cookbook-patchxml>> , '{opsi-winst}' peut évaluer et modifier des fichiers XML. 

Un exemple vous montre comment une valeur peut être récupérée à partir d'un fichier XML. Nous supposons que le fichier XML suivant est:
[source,winst]
----
<?xml version="1.0" encoding="utf-16" ?>
<Collector xmlns="http://schemas.microsoft.com/appx/2004/04/Collector" xmlns:xs="http://www.w3.org/2001/XMLSchema-instance" xs:schemaLocation="Collector.xsd" UtcDate="04/06/2006 12:28:17" LogId="{693B0A32-76A2-4FA0-979C-611DEE852C2C}"  Version="4.1.3790.1641" >
   <Options>
      <Department></Department>
      <IniPath></IniPath>
      <CustomValues>
      </CustomValues>
   </Options>
   <SystemList>
      <ChassisInfo Vendor="Chassis Manufacture" AssetTag="System Enclosure 0" SerialNumber="EVAL"/>
      <DirectxInfo Major="9" Minor="0"/>
   </SystemList>
   <SoftwareList>
      <Application Name="Windows XP-Hotfix - KB873333" ComponentType="Hotfix" EvidenceId="256" RootDirPath="C:\WINDOWS\$NtUninstallKB873333$\spuninst" OsComponent="true" Vendor="Microsoft Corporation" Crc32="0x4235b909">
         <Evidence>
            <AddRemoveProgram DisplayName="Windows XP-Hotfix - KB873333" CompanyName="Microsoft Corporation" Path="C:\WINDOWS\$NtUninstallKB873333$\spuninst" RegistryPath="HKEY_LOCAL_MACHINE\Software\Microsoft\Windows\CurrentVersion\Uninstall\KB873333" UninstallString="C:\WINDOWS\$NtUninstallKB873333$\spuninst\spuninst.exe" OsComponent="true" UniqueId="256"/>
         </Evidence>
      </Application>
      <Application Name="Windows XP-Hotfix - KB873339" ComponentType="Hotfix" EvidenceId="257" RootDirPath="C:\WINDOWS\$NtUninstallKB873339$\spuninst" OsComponent="true" Vendor="Microsoft Corporation" Crc32="0x9c550c9c">
         <Evidence>
            <AddRemoveProgram DisplayName="Windows XP-Hotfix - KB873339" CompanyName="Microsoft Corporation" Path="C:\WINDOWS\$NtUninstallKB873339$\spuninst" RegistryPath="HKEY_LOCAL_MACHINE\Software\Microsoft\Windows\CurrentVersion\Uninstall\KB873339" UninstallString="C:\WINDOWS\$NtUninstallKB873339$\spuninst\spuninst.exe" OsComponent="true" UniqueId="257"/>
         </Evidence>
      </Application>
   </SoftwareList>
</Collector>
----

Pour lire les éléments et obtenir les valeurs de tous les nœuds „Application“ nous pouvons utiliser ces extraits de code:
[source,winst]
----
[Actions]
DefStringList $list$

...

set $list$ = getReturnListFromSection ('XMLPatch_findProducts '+$TEMP$+'\test.xml')
for $line$ in $list$ do Sub_doSomething

[XMLPatch_findProducts]
openNodeSet
	; Node „Collector“ is  documentroot
	documentroot
	all_childelements_with:
	  elementname:"SoftwareList"
	all_childelements_with:
	  elementname:"Application"
end
return elements

[Sub_doSomething]
set $escLine$ = EscapeString:$line$
; now we can work on the content of $escLine$
----
Nous encapsulons les chaînes récupérées en définissant leurs valeurs dans leur ensemble dans une variable par l'intermédiaire d'un appel EscapeString. Puisque la variable de boucle %line% n'est pas une variable commune mais elle se comporte comme une constante tous les caractères spéciaux dedans (comme < > $ % “ ') peuvent entraîner des difficultés.

[[opsi-winst-cookbook-xmlnamespace]]
=== Insertion d'une définition d'espace de noms dans un fichier XML

La section '{opsi-winst}' XMLPatch nécessite un espace entièrement déclarés de nom XML (comme cela est supposé dans le XML RFC). Mais il y a des fichiers de configuration XML qui ne déclarent pas des éléments „évidents“ (et les programmes d'interprétation insistent que le fichier ressemble de sorte). Surtout les correctifs par lots des fichiers de configuration XML/XCU de OpenOffice.org se sont avéré être une tâche difficile. Pour résoudre cette tâche, A. Pohl (merci beaucoup!) les fonctions XMLaddNamespace et XMLremoveNamespace. Son utilisation est démontrée par l'exemple suivant:
[source,winst]
----
DefVar $XMLFile$
DefVar $XMLElement$
DefVar $XMLNameSpace$
set $XMLFile$ = "D:\Entwicklung\OPSI\winst\Common.xcu3" 
set $XMLElement$ = 'oor:component-data'
set $XMLNameSpace$ = 'xmlns:xml="http://www.w3.org/XML/1998/namespace"'

if XMLAddNamespace($XMLFile$,$XMLElement$, $XMLNameSpace$) 
  set $NSMustRemove$="1" 
endif 
;
; now the XML Patch should work
; (commented out since not integrated in this example)
;
; XMLPatch_Common $XMLFile$ 
;
; when finished we rebuild the original format 
if $NSMustRemove$="1" 
  if not (XMLRemoveNamespace($XMLFile$,$XMLElement$,$XMLNameSpace$)) 
    LogError "XML-Datei konnte nicht korrekt wiederhergestellt werden"    
    isFatalError
  endif 
endif 
----

S'il vous plaît noter que le fichier XML doit être formaté tels que les balises de l'élément ne contiennent pas de sauts de ligne. 

[[opsi-winst-special-errors]]
== Messages d'erreur spéciales

* Pas de connexion avec le Service opsi +
Les journaux de '{opsi-winst}': "... cannot connect to service".

L'information qui est montrée en outre peut donner une indication pour le problème:

Socket-Fehler #10061, Connection refused::
Peut-être le service opsi ne fonctionne pas. 

Socket-Fehler #10065, No route to host::
Pas de connexion réseau vers le serveur

HTTP/1.1. 401 Unauthorized::
Le service répond mais la combinaison utilisateur/mot de passe n'est pas acceptée.



