////
; Copyright (c) uib gmbh (www.uib.de)
; This documentation is owned by uib
; and published under the german creative commons by-sa license
; see:
; https://creativecommons.org/licenses/by-sa/3.0/de/
; https://creativecommons.org/licenses/by-sa/3.0/de/legalcode
; english:
; https://creativecommons.org/licenses/by-sa/3.0/
; https://creativecommons.org/licenses/by-sa/3.0/legalcode
;
////

:Author:    uib gmbh
:Email:     info@uib.de
:Revision:  4.2
:toclevels: 6
:doctype:   book

// Include common opsi terms
include::common:partial$opsi_terms.adoc[]

include::common:partial$firststeps-softwintegration-win.adoc[]

////

[[opsi-getting-started-softwintegration]]
== Integration of New Software Packages into the opsi Server

The primary objective of software distribution is to accomplish automatic software installation without user interaction. Software installation and user activity should be strictly separated. In most cases, the installation process requires administrative privileges which the user usually doesn't have. So the installation process has to be done independently from the user. This way, the user can neither interfere nor be affected by the software installation process.

In order to do this, you have to write a script for the script driven installer, which is called an '{opsi-script}' script. This script in addition to the installfiles and some metadata can be packed as a opsi-product, which in turn can be installed on a {opsi-Server}.

[[opsi-getting-started-softwintegration-tutorial]]
=== A Brief Tutorial: How to write a {opsi-script} Script

[[opsi-getting-started-softwintegration-tutorial-introduction]]
==== Introduction

This tutorial merely helps you getting started with opsi. It can't replace professional training (which you may order through uib), or thoroughly studying the complete opsi manuals (which might be time consuming and partially error prone if you lack background knowledge).
uib now offers training in English, too.

.Training and Support:

Get Training by uib gmbh in Europe or possibly Northern America: +
https://uib.de/en/support-training/support/

.Manuals:

The opsi Manuals can be found at:
https://uib.de/en/opsi-documentation/documentation/
important for scripting: +
opsi-script reference card and opsi-script manual

.Wiki (Scripts, Tips, Links):

https://forum.opsi.org/wiki

.Support Forum (fast and free vendor support):
https://forum.opsi.org

[[opsi-getting-started-softwintegration-tutorial-general]]
==== Methods of Non-Interactive Installation

Regardless of whether or not you are using opsi or another management solution, there are three different ways to install software without user interaction:

. *Unattended or Silent Installation* +
The original setup binary from the software manufacturer can be executed with command line arguments which enable a 'silent' or 'unattended' mode. It depends on whether or not the program supports a silent installation mode. A special case of this method is the unattended installation of MSI packages.
*"silent" Installation of a MSI-Package*:+
A MSI-Package can be installed using the "quiet" Option.

. *Interactive Setup with recorded Answers* +
The actions executed by the administrator while running the manufacturer's setup program during a manual installation are automatically recorded using the free tools 'Autoit' or 'Autohotkey'. This generates an autoIt script which in turn can be used for an unattended installation.

. *Recreate the setup-routine with opsi-script*: +
The actions executed by the setup-routine when installing manually are recorded and the opsi-script is used to reproduce them.

NOTE: opsi supports all of these variants. +
Usually a combination of these methods in one script provides the best result. For example, performing the basic installation using the original setup if available, and then doing some customizing by patching the registry or the file based configuration.

[[opsi-getting-started-softwintegration-tutorial-script-structure]]
==== Structure of a opsi-script Script

An example of a simple opsi-script script:
[source,winst]
----
[Actions]
WinBatch_tightvnc_silent_install

[WinBatch_tightvnc_silent_install]
"%ScriptPath%\tightvnc-1.3.9-setup.exe" /silent
----

An opsi-script script contains a *primary* and *secondary* sections. The section headers are in square brackets, similar to what you may have seen in ini-files. The primary section is noted by the identifier [Actions], and the secondary section is noted by the identifier [WinBatch_...].

The core tasks, like starting programs or copying files, are specified in the secondary sections, not in the primary sections. These secondary sections are topic specific, and have a specific syntax that relates to their specific topic.

The name of a secondary section starts with a reserved word identifying the type of the secondary section followed by a free identifier.

In the above example, the primary section +[Actions]+ calls a secondary section +[WinBatch_7z_silent_install]+. +
This secondary section has the type +WinBatch+. The content of the secondary sections, of type 'WinBatch', are executed by the Windows API. In this case, the binary `7z.exe` will be started with the parameter +/S+.

[[opsi-getting-started-softwintegration-tutorial-primary-sections]]
==== Primary Sections

Actions::
The section +[Actions]+ is the main program. +
Any part of the code that is called more then one time can be placed in sub sections.

Sub-sections::
Primary sections which may be called multiple times or have their code in external files.

The primary sections are the main program which control the program flow. There you will find:

* Variables: strings and string lists
* if else endif statements
* for loops that traverse string lists
* Functions

.double code for deinstallation
image::opsi-winst-without-delsub.png["example of repetitive code (for deinstallation)",width=300]

.avoid double code by using sub sections
image::opsi-winst-with-delsub.png["avoid repetitive code by using sub sections",width=300]

[[opsi-getting-started-softwintegration-tutorial-secondary-sections]]
==== Important Kinds of Secondary Sections

Files::
File operations include

* copying (regarding the internal version information, recursive, ...)
* deleting files or directories
* creating directories

WinBatch::
It's used for calling programs using the Windows API. For example, WinBatch calls the setup programs in the silent mode.

ShellScript::
The content of these sections are interpreted by the `cmd.exe` like normal batch files. 

ExecWith::
A program is given as a parameter, and then that program interprets the content of this section (e.g. AutoIt).

Registry::
The 'Registry' sections are used for registry manipulations.

Linkfolder::
Link folder sections are used for the manipulation of start menus and desktop icons.

[[opsi-getting-started-softwintegration-tutorial-global-constants]]
==== Global Constants

Global constants are placeholders which can be used in primary and secondary sections. These placeholders are replaced by their values at runtime.

Examples:

+%ProgramFiles32Dir%+:: c:\program files
+%Systemroot%+::        c:\windows
+%System%+::            c:\windows\system32
+%Systemdrive%+::       c:\
+%Scriptpath%+::        <path to the running script>

[[opsi-getting-started-softwintegration-tutorial-second-example]]
==== Second Example: tightvnc

The following example shows a simple script that is used for a tightvnc installation. This script should contain only the winbatch call for the silent installation. If you call the sub-section silent installation more the one time, a confirmation window appears (which is a bug in the installer). This confirmation window will be closed by a 'autoit' script if it appears.

tightvnc.ins:
[source,winst]
----
[Actions]
Message "Install tightvnc 1.3.9 ..."
ExecWith_autoit_confirm "%ScriptPath%\autoit3.exe" WINST /letThemGo
WinBatch_tightvnc_silent_install
KillTask "autoit3.exe"

[WinBatch_tightvnc_silent_install]
"%ScriptPath%\tightvnc-1.3.9-setup.exe" /silent

[ExecWith_autoit_confirm]
; Wait for the confirm dialog which only appears if tightvnc was installed before as service
; Waiting for the window to appear
WinWait("Confirm")
; Activate (move focus to) window
WinActivate("Confirm")
; Choose answer no
Send("N")
----

[[opsi-getting-started-softwintegration-tutorial-elementary-commands]]
==== Elementary Commands for Primary Sections

[[opsi-getting-started-softwintegration-tutorial-elementary-commands-string-variable]]
===== String Variable

Declaration of a variable:: DefVar <variable name>

Setting a value:: Set <variable name> = <value>

Example:
[source,winst]
----
DefVar $ProductId$
Set $ProductId$ = "firefox"
----

IMPORTANT: The use of string variables is different in primary versus secondary sections. In the primary section, the string variables are handled as independent objects. String variables can only be declared and set to values in primary sections. Therefore you have to use a operator ('+') to concatenate variables and strings in a string expression. +
Example:`"Installing "+$ProductId$+" ..."` +
In secondary sections string variables are used as a placeholder for their values. +
Example: `"Installing $ProductId$ ..."` +
You should keep this in mind if you cut and paste string expressions between primary and secondary sections. +
The advantage of handling string variables in this format is that is possible to use these variables in secondary sections that are interpreted by other programs (ShellScript / Execwith).

[[opsi-getting-started-softwintegration-tutorial-elementary-commands-message]]
===== Message / showbitmap

Displaying text during runtime: +
`Message <string>`

Example:
[source,winst]
----
Message "Installing "+ $ProductId$ +" ..."
----

Displaying a picture during installation: +
`ShowBitMap [<file name>] [<sub title>]`

Example:
[source,winst]
----
ShowBitmap "%ScriptPath%\python.png" "Python"
----

[[opsi-getting-started-softwintegration-tutorial-elementary-commands-if-else-endif]]
===== if [else] endif

*Syntax:*
[source,winst]
----
if <condition>
	;statement(s)
[
else
	;statement(s)
]
endif
----

[[opsi-getting-started-softwintegration-tutorial-elementary-commands-functions]]
===== Functions

HasMinimumSpace:: Check for free space on the hard disk
FileExists:: Check for the existence of a file or directory

[[opsi-getting-started-softwintegration-tutorial-elementary-commands-error]]
===== Error, Logging and Comments

comment char ';':: Lines starting with the ';' char are simply ignored.
comment:: writes a comment to the log file
LogError:: writes error messages to the log file
isFatalError:: aborts the script, and return the installation state 'failed' to the server.

[[opsi-getting-started-softwintegration-tutorial-elementary-commands-requirements]]
===== Requirements

requiredWinstVersion:: Minimum required version of {opsi-script}


[[opsi-getting-started-softwintegration-tutorial-template]]
==== Third example: The Generic Template 'opsi-template'

This third template should be used as a rough guide whenever you create your own opsi product. Do not cut-and-paste from this manual, but instead look at http://download.uib.de for a new version of the 'opsi-template' product package. Using the opsi-package-manager command you may install 'opsi-template' (-i) or extract (-x) at your server and then grab the scripts.

.setup32.opsiscript: installation script
[source,winst]
----
; Copyright (c) uib gmbh (www.uib.de)
; This sourcecode is owned by uib
; and published under the Terms of the General Public License.
; credits: http://www.opsi.org/en/credits/

[Actions]
requiredWinstVersion >= "4.11.4.6"
ScriptErrorMessages=off

DefVar $MsiId$
DefVar $UninstallProgram$
DefVar $LogDir$
DefVar $ProductId$
DefVar $MinimumSpace$
DefVar $InstallDir$
DefVar $ExitCode$
DefVar $LicenseRequired$
DefVar $LicenseKey$
DefVar $LicensePool$
DefVar $displayName32$
DefVar $displayName64$

DefStringlist $msilist$

Set $LogDir$ = "%opsiLogDir%"

; ----------------------------------------------------------------
; - Please edit the following values                             -
; ----------------------------------------------------------------
;$ProductId$ should be the name of the product in opsi
; therefore please: only lower letters, no umlauts,
; no white space use '-' as a separator
Set $ProductId$       = "opsi-template"
Set $MinimumSpace$    = "1 MB"
; the path where the product will be found after the installation
Set $InstallDir$      = "%ProgramFiles32Dir%\<path to the product>"
Set $LicenseRequired$ = "false"
Set $LicensePool$     = "p_" + $ProductId$
; ----------------------------------------------------------------

if not(HasMinimumSpace ("%SystemDrive%", $MinimumSpace$))
	LogError "Not enough space on %SystemDrive%, " + $MinimumSpace$ + " on drive %SystemDrive% needed for " + $ProductId$
	isFatalError "No Space"
	; Stop process and set installation status to failed
else
	comment "Show product picture"
	ShowBitmap "%ScriptPath%\" + $ProductId$ + ".png" $ProductId$

	if FileExists("%ScriptPath%\delsub32.opsiscript")
		comment "Start uninstall sub section"
		Sub "%ScriptPath%\delsub32.opsiscript"
	endif

	Message "Installing " + $ProductId$ + " ..."

	if $LicenseRequired$ = "true"
		comment "Licensing required, reserve license and get license key"
		Sub_get_licensekey
	endif

	comment "Start setup program"
	ChangeDirectory "%SCRIPTPATH%"
	Winbatch_install
	Sub_check_exitcode

	comment "Copy files"
	Files_install /32Bit

	comment "Patch Registry"
	Registry_install /32Bit

	comment "Create shortcuts"
	LinkFolder_install

endif

[Winbatch_install]
; Choose one of the following examples as basis for your installation
; You can use $LicenseKey$ var to pass a license key to the installer
;
; === Nullsoft Scriptable Install System ================================================================
; "%ScriptPath%\Setup.exe" /S
;
; === MSI package =======================================================================================
; You may use the parameter PIDKEY=$Licensekey$
; msiexec /i "%ScriptPath%\some.msi" /l* "$LogDir$\$ProductId$.install_log.txt" /qb-! ALLUSERS=1 REBOOT=ReallySuppress
;
; === InstallShield + MSI=====================================================================================
; Attention: The path to the log file should not contain any whitespaces
; "%ScriptPath%\setup.exe" /s /v" /l* $LogDir$\$ProductId$.install_log.txt /qb-! ALLUSERS=1 REBOOT=ReallySuppress"
; "%ScriptPath%\setup.exe" /s /v" /qb-! ALLUSERS=1 REBOOT=ReallySuppress"
;
; === InstallShield =====================================================================================
; Create setup.iss answer file by running: setup.exe /r /f1"c:\setup.iss"
; You may use an answer file by the parameter /f1"c:\setup.iss"
; "%ScriptPath%\setup.exe" /s /sms /f2"$LogDir$\$ProductId$.install_log.txt"
;
; === Inno Setup ========================================================================================
; http://unattended.sourceforge.net/InnoSetup_Switches_ExitCodes.html
; You may create setup answer file by: setup.exe /SAVEINF="filename"
; You may use an answer file by the parameter /LOADINF="filename"
; "%ScriptPath%\setup.exe" /sp- /silent /norestart /nocancel /SUPPRESSMSGBOXES

[Files_install]
; Example of recursively copying some files into the installation directory:
;
; copy -s "%ScriptPath%\files\*.*" "$InstallDir$"

[Registry_install]
; Example of setting some values of a registry key:
;
; openkey [HKEY_LOCAL_MACHINE\Software\$ProductId$]
; set "name1" = "some string value"
; set "name2" = REG_DWORD:0001
; set "name3" = REG_BINARY:00 af 99 cd

[LinkFolder_install]
; Example of deleting a folder from AllUsers startmenu:
;
; set_basefolder common_programs
; delete_subfolder $ProductId$
;
; Example of creating an shortcut to the installed exe in AllUsers startmenu:
;
; set_basefolder common_programs
; set_subfolder $ProductId$
;
; set_link
; 	name: $ProductId$
; 	target: <path to the program>
; 	parameters:
; 	working_dir: $InstallDir$
; 	icon_file:
; 	icon_index:
; end_link
;
; Example of creating an shortcut to the installed exe on AllUsers desktop:
;
; set_basefolder common_desktopdirectory
; set_subfolder ""
;
; set_link
; 	name: $ProductId$
; 	target: <path to the program>
; 	parameters: <some_param>
; 	working_dir: $InstallDir$
; 	icon_file: <path to icon file>
; 	icon_index: 2
; end_link

[Sub_get_licensekey]
if opsiLicenseManagementEnabled
	comment "License management is enabled and will be used"

	comment "Trying to get a license key"
	Set $LicenseKey$ = demandLicenseKey ($LicensePool$)
	; If there is an assignment of exactly one licensepool to the product the following call is possible:
	; Set $LicenseKey$ = demandLicenseKey ("", $ProductId$)
	;
	; If there is an assignment of a license pool to a windows software id, it is possible to use:
	; DefVar $WindowsSoftwareId$
	; $WindowsSoftwareId$ = "..."
	; Set $LicenseKey$ = demandLicenseKey ("", "", $WindowsSoftwareId$)

	DefVar $ServiceErrorClass$
	set $ServiceErrorClass$ = getLastServiceErrorClass
	comment "Error class: " + $ServiceErrorClass$

	if $ServiceErrorClass$ = "None"
		comment "Everything fine, we got the license key '" + $LicenseKey$ + "'"
	else
		if $ServiceErrorClass$ = "LicenseConfigurationError"
			LogError "Fatal: license configuration must be corrected"
			LogError getLastServiceErrorMessage
			isFatalError
		else
			if $ServiceErrorClass$ = "LicenseMissingError"
				LogError "Fatal: required license is not supplied"
				isFatalError
			endif
		endif
	endif
else
	LogError "Fatal: license required, but license management not enabled"
	isFatalError
endif


[Sub_check_exitcode]
comment "Test for installation success via exit code"
set $ExitCode$ = getLastExitCode
; informations to exit codes see
; http://msdn.microsoft.com/en-us/library/aa372835(VS.85).aspx
; http://msdn.microsoft.com/en-us/library/aa368542.aspx
if ($ExitCode$ = "0")
	comment "Looks good: setup program gives exitcode zero"
else
	comment "Setup program gives a exitcode unequal zero: " + $ExitCode$
	if ($ExitCode$ = "1605")
		comment "ERROR_UNKNOWN_PRODUCT	1605	This action is only valid for products that are currently installed."
		comment "Uninstall of a not installed product failed - no problem"
	else
		if ($ExitCode$ = "1641")
			comment "looks good: setup program gives exitcode 1641"
			comment "ERROR_SUCCESS_REBOOT_INITIATED	1641	The installer has initiated a restart. This message is indicative of a success."
		else
			if ($ExitCode$ = "3010")
				comment "looks good: setup program gives exitcode 3010"
				comment "ERROR_SUCCESS_REBOOT_REQUIRED	3010	A restart is required to complete the install. This message is indicative of a success."
			else
				logError "Fatal: Setup program gives an unknown exitcode unequal zero: " + $ExitCode$
				isFatalError
			endif
		endif
	endif
endif
----

.delsub32.opsiscript: external deinstallation sub section
[source,winst]
----
; Copyright (c) uib gmbh (www.uib.de)
; This sourcecode is owned by uib gmbh
; and published under the Terms of the General Public License.
; credits: http://www.opsi.org/en/credits/

Set $MsiId$ = '{XXXXXXXX-XXXX-XXXX-XXXX-XXXXXXXXXXXX}'
Set $UninstallProgram$ = $InstallDir$ + "\uninstall.exe"

Message "Uninstalling " + $ProductId$ + " ..."

if FileExists($UninstallProgram$)
	comment "Uninstall program found, starting uninstall"
	Winbatch_uninstall
	sub_check_exitcode
endif
if not (GetRegistryStringValue32("[HKEY_LOCAL_MACHINE\SOFTWARE\Microsoft\Windows\CurrentVersion\Uninstall\" + $MsiId$ + "] DisplayName") = "")
	comment "MSI id " + $MsiId$ + " found in registry, starting msiexec to uninstall"
	Winbatch_uninstall_msi
	sub_check_exitcode
endif

comment "Delete files"
Files_uninstall /32Bit

comment "Cleanup registry"
Registry_uninstall /32Bit

comment "Delete program shortcuts"
LinkFolder_uninstall

[Winbatch_uninstall]
; Choose one of the following examples as basis for program uninstall
;
; === Nullsoft Scriptable Install System ================================================================
; maybe better called as
; Winbatch_uninstall /WaitforProcessending "Au_.exe" /Timeoutseconds 10
; "$UninstallProgram$" /S
;
; === Inno Setup ========================================================================================
; "$UninstallProgram$" /silent /norestart /SUPPRESSMSGBOXES /nocancel

[Winbatch_uninstall_msi]
msiexec /x $MsiId$ /qb-! REBOOT=ReallySuppress

[Files_uninstall]
; Example for recursively deleting the installation directory:
;
; del -sf "$InstallDir$\"

[Registry_uninstall]
; Example of deleting a registry key:
;
; deletekey [HKEY_LOCAL_MACHINE\Software\$ProductId$]

[LinkFolder_uninstall]
; Example of deleting a folder from AllUsers startmenu:
;
; set_basefolder common_programs
; delete_subfolder $ProductId$
;
; Example of deleting a shortcut from AllUsers desktop:
;
; set_basefolder common_desktopdirectory
; set_subfolder ""
; delete_element $ProductId$

[Sub_check_exitcode]
;(.... see above .....)
----

.uninstall32.opsiscript: deinstallation script
[source,winst]
----
; Copyright (c) uib gmbh (www.uib.de)
; This sourcecode is owned by uib
; and published under the Terms of the General Public License.
; credits: http://www.opsi.org/en/credits/

[Actions]
requiredWinstVersion >= "4.11.4.6"
ScriptErrorMessages=off

DefVar $MsiId$
DefVar $UninstallProgram$
DefVar $LogDir$
DefVar $ExitCode$
DefVar $ProductId$
DefVar $InstallDir$
DefVar $LicenseRequired$
DefVar $LicensePool$

Set $LogDir$ = "%opsiLogDir%"

; ----------------------------------------------------------------
; - Please edit the following values                             -
; ----------------------------------------------------------------
Set $ProductId$       = "opsi-template"
Set $InstallDir$      = "%ProgramFiles32Dir%\<path to the product>"
Set $LicenseRequired$ = "false"
Set $LicensePool$     = "p_" + $ProductId$
; ----------------------------------------------------------------


comment "Show product picture"
ShowBitmap "%ScriptPath%\" + $ProductId$ + ".png" $ProductId$

Message "Uninstalling " + $ProductId$ + " ..."

if FileExists("%ScriptPath%\delsub32.opsiscript")
	comment "Start uninstall sub section"
	Sub "%ScriptPath%\delsub32.opsiscript"
endif

if $LicenseRequired$ = "true"
	comment "Licensing required, free license used"
	Sub_free_license
endif

[Sub_free_license]
comment "License management is enabled and will be used"

comment "Trying to free license used for the product"
DefVar $result$
Set $result$ = FreeLicense($LicensePool$)
; If there is an assignment of a license pool to the product, it is possible to use
; Set $result$ = FreeLicense("", $ProductId$)
;
; If there is an assignment of a license pool to a windows software id, it is possible to use
; DefVar $WindowsSoftwareId$
; $WindowsSoftwareId$ = "..."
; set $result$ = FreeLicense("", "", $WindowsSoftwareId$)
----

[[opsi-getting-started-softwintegration-tutorial-create-and-test-script]]
==== Interactive Creation and Testing of a {opsi-script} Script

It is possible to interactively adapt and test your own opsi-script script using winst32.exe.

Start by creating a directory where you will build and test your script (e.g. `c:\test`), and then copy the template scripts from the opsi-template (`setup.ins`, `delsub.ins` und `uninstall.ins`) to this directory.

Start the {opsi-script} (`opsi-script.exe`) program via a double mouse click. (On Windows 7 Clients, you must right-click on the mouse button and select "run as Administrator"). If the opsi-client-agent is installed on your computer you will find the {opsi-script} at the directory `C:\program files\opsi.org\opsi-client-agent\opsi-script. If the {opsi-client} agent is not installed you will find the {opsi-script} at the share
'\\<opsiserver\opsi_depot_rw' in the directory `install\opsi-winst\files`.

After starting {opsi-script}, you will see the following window:

.opsi-script Started in Interactive Mode
image::opsi-script-interactiv.png["Screenshot: {opsi-script} started in interactive mode", pdfwidth=90%]

* 'Select Script' is used to choose the script that you want to execute.
* 'Start' will start the execution of the selected script.
* 'View Log' is used to read the log file from the script that was run most recently.

Select the 'setup.ins' script and run it.

.{opsi-script} log view window
image::winst-log-view.png["{opsi-script} log view window", pdfwidth=90%]

* Look at the log file to see how {opsi-script} interpreted the script.

* After figuring out which setup.exe that you will use to install software, copy setup.exe to the directory where the scripts are located (e.g. `c:\test`).

* Open the `setup.ins` script with a editor. You may use any text editor you like. We suggest the 'jEdit' with syntax highlighting for {opsi-script} which is part of the essential {opsi-product}s.

.jEdit with a opsi script
image::jedit-with-winst-script.png["jEdit with a opsi script", pdfwidth=90%]

* You may now change the script using the editor. Save the changes (keep the editor open).

* Now switch to the {opsi-script} and start the script again. (You don't have to reselect the script. Just press the 'start' button).

* Just have a look at the log again and see how the program flow changed according to your script changes.

* You can interactively develop a script until it fits your needs by performing these steps in this order: +
 - Change the script and save +
 - run the script +
 - review the log +


The next chapter contains some hints about handle any problems that may arise while building a opsi-script script. <<opsi-getting-started-softwintegration-create-opsi-package-newprod>> describes how to create an {opsi-product} from your scripts, and how to install the products on the {opsi-server}.


[[opsi-getting-started-softwintegration-tutorial-template-details]]
==== Suggestions on How to Solve Problems with {opsi-script} Scripts

[[opsi-getting-started-softwintegration-tutorial-find-switches]]
===== Search for Unattend or Silent Switches

For an unattended or silent setup, the original setup will be switched to an unattended non-interactive mode using the proper command line arguments.

The problem is to find the correct arguments

.Look on the internet:
Before you start integrating a new package, you'd better first have a look online to see if somebody has already done that job for you:

Ready to run {opsi-script} scripts, built by the community, can be found at the link:https://forum.opsi.org/wiki/[opsi wiki].

A collection of links to web sites with switch collections can be found at link:https://forum.opsi.org/wiki/doku.php?id=userspace:software_integration_web_links[opsi wiki: Software integration web-links].

.Search the software producer's site:
Many software manufacturers are aware of the needs of unattended software distribution, so there are often some hints and instructions in the product documentation or on the software producer's website.

.Identify the manufacturer of the setup program:
Most setup programs are built using frameworks like 'Inno', 'NSIS', 'Installshield' or 'Wise'. Each one of these setup frameworks has their own switch.  The following method can be used to determine the framework and other necessary information:  The input strings can be determined using the command line program 'strings' given the setup program 'setup.exe', and the output framework names can be found using 'grep' or 'findstr'.

The Linux commands looks like this (change <mysetup.exe> to the name of your setup.exe):

[source,prompt]
----
strings <mysetup.exe> | grep -i -E "(inno|nsis|installshield|wise)"
----

Windows does not have a native `strings` command, so you will have to install it. You can download a `strings.exe` program from here: http://technet.microsoft.com/en-us/sysinternals/bb897439

To use this program, enter these commands at the command line interface (change <mysetup.exe> to the name of your setup.exe):
[source,prompt]
----
strings.exe <mysetup.exe> | findstr /i /r "inno installshield nsis wise"
----

The same method is used in the `opsi-setup-detector`.  See the example below:

.opsi setup detector
image::opsi-setup-detector.png[pdfwidth=70%]

This GUI program can be called from the Windows context menu Explore.

.opsi setup detector in Windows Explore context menu
image::opsi-setup-detector-context-small-en.png[pdfwidth=50%]

The 'opsi setup detector' is part of the Windows package repositories and can be obtained through them.

At the link:https://forum.opsi.org/wiki/doku.php?id=userspace:software_integration_web_links[opsi wiki: Software integration web-links
] you will find links to websites that give hints on how to detect the manufacturer of the setup program.


[[opsi-getting-started-softwintegration-tutorial-winst-commands]]
===== Some Important {opsi-script} Commands

A short overview of the {opsi-script} commands can be found in the link:https://download.uib.de/opsi_stable/docopsi-script-reference-card-en.pdf[opsi-script reference card].

All syntax details are described in the link:https://download.uib.de/opsi_stable/docopsi-script-manual-en.pdf[opsi-script manual].

Here are some hints regarding important methods:

.Stringlisten
String lists can be powerful tools to review the output from other programs. Read the {opsi-script} manual for details.

.ExitWindows
* `ExitWindows /Reboot` +
Reboot after the script is finished

* `ExitWindows /ImmediateReboot` +
Reboot now

* `ExitWindows /ImmediateLogout`
Exit the {opsi-script} now

.Product Properties
For some products it is important to know which product properties can modify the installation in order to make a client-specific installation. Creating these properties is described below in <<opsi-getting-started-softwintegration-create-opsi-package,"Creating an opsi package">>.

To evaluate these properties, {opsi-script} provides the function `GetProductProperty`

[source,winst]
----
if GetProductProperty("example-property", "no") = "yes"
	Files_copy_extra_files
endif
----

[[opsi-getting-started-softwintegration-tutorial-opsiadmin]]
===== Installation When the User is Logged on

Before we begin, we assume that you have tried an unattended installation using an {opsi-script} script, and the installation worked OK when the user had administrative privileges.
However with some software products, you will see that the installation fails when started from within the opsi deployment software (opsi-client-agent). A possible reason for that difference might be that the installation process requires knowledge about the user environment or profile.

In the case of a MSI package, the option 'ALLUSERS=1' might help.
Example:

[source,winst]
----
[Actions]
DefVar $MsiLogFile$
Set $MsiLogFile$ = %opsiLogDir% + "\myproduct.log"
winbatch_install_myproduct

[winbatch_install_myproduct]
msiexec /qb-! /l* $MsiLogFile$ /i "%ScriptPath%\files\myproduct.msi" ALLUSERS=1
----

Another possibility is that the installation starts a second process and stops before the second process is finished. So from the point of view of the {opsi-script} script, the task is finished while in fact the second process is still working (installing / uninstalling). +
In this case, you may use the modifier +/WaitSeconds <seconds>+ , or
+/WaitForProcessEnding "program.exe" /TimeOutSeconds "<seconds>"+, in the WinBatch section so that the script waits for the end of the second process.

Another more complex way to solve the problem is to create a temporary administrative user account and use this account for the program installation. For a detailed description on how to do this, please refer to the {opsi-script} manual chapter 8.3 'Script for installation in the context of a local administrator' and use the template 'opsi-template-with-admin'.

[[opsi-getting-started-softwintegration-tutorial-msi]]
===== Working with MSI-packages

With Windows 2000, Microsoft launched its own installation concept based on the Microsoft Installer Service "MSI". Since then, many setup programs have become MSI compliant.

To be MSI compliant means to provide a package with installation instructions for the MSI. Usually this is a file named 'product.msi'.

In practice, the setup.exe of a product contains a 'product.msi' file and an additional control program for the installation. The control program unpacks the 'product.msi' and pops up a window that asks if it is allowed to start the installation. If installation has been approved, then the control program checks whether or not MSI is installed, and if so passes 'product.msi' to MSI. If no MSI is found, then the control program tries to install MSI.

If you were to interrupt the installation at that point, you will often find the unpacked MSI-package in a temporary directory.

For example, this package can be used for an unattended installation with the statement:
[source,winst]
----
msiexec /i "%ScriptPath%\Product.msi" /qb-! ALLUSERS=1 REBOOT=ReallySuppress
----

[[opsi-getting-started-softwintegration-tutorial-customizing]]
===== Customization after a silent/unattended Installation

After a successful silent installation, some customizing might be useful. The {opsi-script} is a powerful tool to do that job. First, find out what patches have to be applied. For example, that could mean analyzing which registry settings are affected by the GUI customizing tools.

You can use the tools shown in <<opsi-getting-started-softwintegration-tutorial-analyse-and-repackage>>. Some other tools can be found here:

Some other often used tools are:

* link:http://www.sysinternals.com/[sysinternals]
* link:https://sourceforge.net/projects/regshot/[regshort]


[[opsi-getting-started-softwintegration-tutorial-autoit]]
===== Integration with Automated Answers for the setup Program

Another fast way of integration is to provide an automated answer file for the setup process. The answer file contains pre-defined answers.  To be more precise, the answer file is used by a control tool, which waits for the setup to come up with the interactive windows.  The control tool then passes input to these windows as defined in the answer file. As a control tool we recommend 'AutoIt'. The AutoIt program and the documentation can be found at: http://www.hiddensoft.com/autoit3.

AutoIt provides a lot of commands to control the setup process. Also, several error states can be handled (if known in advance) with the '[ADLIB]' section in the script.

There is, however, a fundamental challenge in using AutoIt: +
The AutoIt script must provide input for every window that might pop up during installation. So if any unexpected window pops up, which isn't handled in the [ADLIB] section, AutoIt provides no input for this window and the installation stops at that point while waiting for input. This input could be done interactively by a user, and then the script can take over again and handle the next windows.

Another situation that may cause failure of an AutoIt installation: +
The user can interfere with the installation if the mouse and keyboard are not disabled. Therefore we regard 'unattended' or 'silent' setup as a more stable solution.

A combination of both might do a good job: +
The 'silent'-setup does the main installation and the AutoIt script handles special conditions that might occur.

If you use the opsi option of running the installation on another desktop than the current desktop, or if the current desktop is locked, then you will find that some autoit functions do not work properly under these conditions.

Therefore you should avoid using the following autoit commands in '{opsi-script}' scripts:

* winwait()

* winactivate()

* Send()

Because these commands are so widely used, we provide substitutes:
*winwait()* +
should be replaced by the function +
`opsiwinwait($title, $text, $maxseconds, $logname)` +
which is defined as:
[source,configfile]
----
Func opsiwinwait($title, $text, $maxseconds, $logname)
	Local $exists = 0
	Local $seconds = 0
	Local $mylog
	$mylog = FileOpen($logname, 1)
	While ($seconds <= $maxseconds) and ($exists = 0)
		$exists = WinExists($title , $text)
		FileWriteLine($mylog,"win: "  & $title & " ; " & $text & " exists result (1=exists): " & $exists )
		$seconds = $seconds + 1
		sleep(1000)
	WEnd
	FileClose($mylog)
EndFunc

----
The parameters are:

* `$title` the title of the window

* `$text` a part of the readable text in the window

* `$maxseconds` the timeout in seconds

* `$logname` the name of the log file


*Send()* +
should be replaced by the function +
`opsiControlClick($title, $text, $id, $maxseconds, $logname)` +
respectively by +
`opsiControlSetText($title, $text, $id,$sendtext, $maxseconds, $logname)` +
which are defined as:
[source,configfile]
----
Func opsiControlClick($title, $text, $id, $maxseconds, $logname)
	Local $result = 0
	Local $seconds = 0
	Local $mylog
	$mylog = FileOpen($logname, 1)
	While ($seconds <= $maxseconds) and ($result = 0)
		$result = ControlClick($title , $text,$id)
		FileWriteLine($mylog,"answer for " & $title & " ; " & $text & " id: " & $id & " sended: result (1=success) : " & $result)
		$seconds = $seconds + 1
		sleep(500)
	WEnd
	FileClose($mylog)
EndFunc

Func opsiControlSetText($title, $text, $id,$sendtext, $maxseconds, $logname)
	Local $result = 0
	Local $seconds = 0
	Local $mylog
	$mylog = FileOpen($logname, 1)
	While ($seconds <= $maxseconds) and ($result = 0)
		$result = ControlSetText ($title , $text,$id, $sendtext)
		FileWriteLine($mylog,"answer for " & $title & " ; " & $text & " id: " & $id & " set: " & $sendtext & " sended: result (1=success) : " & $result)
		$seconds = $seconds + 1
		sleep(500)
	WEnd
	FileClose($mylog)
EndFunc

----
The parameters are:

* `$title` the title of the window

* `$text` a part of the readable text in the window

* `$id` the numerical ControlId of the button or edit field

* `$sendtext` the text to insert to a edit field

* `$maxseconds` the timeout in seconds

* `$logname` the name of the log file

Therefore, you should use the program `Au3info.exe` to get the 'ControlId' needed by these commands. Please use the numerical 'ControlId', because the other variants do not seem to work properly:

Below is an example from a script. +
In this script we produce a log file from the autoit activities, which may be integrated in the '{opsi-script}' log file with the following commands:
[source,winst]
----
includelog %opsiLogDir% + "\au3.log" "500"
----

Example:
[source,configfile]
----
[ExecWith_autoit_confirm]
Func opsiwinwait($title, $text, $maxseconds, $logname)
	Local $exists = 0
	Local $seconds = 0
	Local $mylog
	$mylog = FileOpen($logname, 1)
	While ($seconds <= $maxseconds) and ($exists = 0)
		$exists = WinExists($title , $text)
		FileWriteLine($mylog,"win: "  & $title & " ; " & $text & " exists result (1=exists): " & $exists )
		$seconds = $seconds + 1
		sleep(1000)
	WEnd
	FileClose($mylog)
EndFunc

Func opsiControlClick($title, $text, $id, $maxseconds, $logname)
	Local $result = 0
	Local $seconds = 0
	Local $mylog
	$mylog = FileOpen($logname, 1)
	While ($seconds <= $maxseconds) and ($result = 0)
		$result = ControlClick($title packet
	FileClose($mylog)
EndFunc

Func opsiControlSetText($title, $text, $id,$sendtext, $maxseconds, $logname)
	Local $result = 0
	Local $seconds = 0
	Local $mylog
	$mylog = FileOpen($logname, 1)
	While ($seconds <= $maxseconds) and ($result = 0)
		$result = ControlSetText ($title , $text,$id, $sendtext)
		FileWriteLine($mylog,"answer for " & $title & " ; " & $text & " id: " & $id & " set: " & $sendtext & " sended: result (1=success) : " & $result)
		$seconds = $seconds + 1
		sleep(500)
	WEnd
	FileClose($mylog)
EndFunc

; exact title match
Opt("WinTitleMatchMode", 3)
$mylog = FileOpen("%opsiLogDir%\au3.log", 2)
FileWriteLine($mylog,"auto-it started - waiting for the window")
FileClose($mylog)

opsiwinwait("InstallShield Wizard" , "Wollen Sie wirklich", 200, "%opsiLogDir%\au3.log")
	opsiControlClick("InstallShield Wizard" , "Wollen Sie wirklich", 6, 5, "%opsiLogDir%\au3.log")
opsiwinwait("InstallShield Wizard" , "Deinstallation ist abgeschlossen", 400, "%opsiLogDir%\au3.log")
	opsiControlClick("InstallShield Wizard" , "Deinstallation ist abgeschlossen", 1, 5, "%opsiLogDir%\au3.log")

Sleep(500)
;and good bye
Exit
----

see also: +
http://www.autoitscript.com/wiki/FAQ#Why_doesn.27t_my_script_work_on_a_locked_workstation.3F +
http://www.autoitscript.com/autoit3/docs/ +
http://www.autoitscript.com/autoit3/docs/intro/controls.htm +
http://www.autoitscript.com/autoit3/docs/functions.htm


[[opsi-getting-started-softwintegration-tutorial-analyse-and-repackage]]
===== Analyze and Repackage

When a software developer builds a setup for deployment, the developer usually knows about the required components of the software that have to be installed. But if somebody has a black box as a setup, then they need first to analyze what the setup does. This can be done by monitoring the setup activities with the appropriate tools (e.g. monitoring files and registry access) or by comparing the system states before and after installation.

To analyze the before or after states, there are several tools. For Example:

* link:http://download.fyxm.net/download-now-InstallWatch-Pro-OS-OS-Info-83813.html[InstallWatch Pro]

* link:http://www.itninja.com/media/downloads/appdeploy-repackager.msi[appdeploy-repackager]


[[opsi-getting-started-softwintegration-tutorial-deinstall]]
===== How to uninstall Products

To uninstall a software product from a computer, you need an 'uninstall' script to perform the deletion. The fundamental difficulty in software deletion is deciding what exactly has to be removed. Not all of the files that came with a software package can be deleted afterwards. Sometimes a package comes with standard modules that are also referred to by other programs. Often only the software manufacturer himself knows what parts have to be removed. The manufacturer's setup might offer an unattended uninstall option which can be embedded in the opsi uninstall script. Otherwise {opsi-script} provides several commands for software deletion:

.Using an uninstall routine
If the product manufacturer provides an option for software deletion, you must checked whether or not it can be run unattended (or in silent mode). If it requires some user interaction, an AutoIt script combined with the uninstall routine might do the job. The uninstall statement can be embedded in a [WinBatch] section of the {opsi-script} script:
[source,winst]
----
[WinBatch_start_ThunderbirdUninstall]
"%SystemRoot%\UninstallThunderbird.exe" /ma
----

When using an uninstall program, always run a test to see if all of the files have been deleted and the computer is still in a stable state.

Products that are installed by MSI normally come with an uninstall option, which is usually the program `msiexec.exe` combined with the parameter `/x`. The parameter `/qb-!` is for the unattended mode (or without user interaction). So here is an example of an unattended uninstall command:

[source,winst]
----
msiexec.exe /x some.msi /qb-! REBOOT=ReallySuppress
----

Instead of the package name, you could also use the GUID (Global Unique ID) with `msiexec.exe`. This GUID identifies the product in the system, which can be found in the registry directory
'HKLM\Software\Microsoft\Windows\CurrentVersion\Uninstall'

A request using the GUID looks like this:
[source,winst]
----
msiexec.exe /x {003C5074-EB37-4A75-AC4B-F5394E08B4DD} /qb-!
----

If none of these methods are available or sufficient, the uninstall can be done using a {opsi-script} script as described below:

.Useful {opsi-script} commands for uninstall

If a product has been installed by {opsi-script} functions, or if there is no uninstall routine for the product, the complete uninstall has to be done by a {opsi-script} script. {opsi-script} comes with some powerful uninstall functions. This chapter provides a brief overview of the uninstall functions, and more detailed information can be found in the {opsi-script} handbook.

Basic uninstall means deleting one or more files from the file system. This command can be executed from a {opsi-script} files section:
[source,winst]
----
delete -f <file name>
----

or to delete a directory including sub directories:

[source,winst]
----
delete -sf <dir name>\
----

The parameter 'f' means 'force' or to delete the files even if they are marked as 'read only' and the parameter 's' means including the 'subdirectories'. A file or directory can be deleted from all user profiles using the option '/AllNTUserProfiles' (see {opsi-script} manual for details).

Directories containing files with the attribute 'hidden' or 'system' can be deleted by using a 'ShellScript'-section:

[source,winst]
----
[ShellScript_deleteDir]
rmdir /S /Q "<List>"
----

To stop a running process before deletion use the `killtask` command with the process' name (look at the task manager for process name):

[source,winst]
----
KillTask "thunderbird.exe"
----

If the product or part of it, runs as a service, you will have to stop the service before deleting the files. One way to do so, is to set the service state to inactive in the registry and restart the computer. Or to stop the service by using the command 'net stop', which doesn't need a reboot:
[source,winst]
----
net stop <servicename>
----

Deleting DLL files also requires special attention, since DLLs could also be used by other products. There is no general way of handling this.

To delete registry entries with {opsi-script} you can use the command DeleteVar. This command deletes entries from the currently open key:

[source,winst]
----
DeleteVar <VarName>
----

To delete a registry key with all sub keys and registry variables, you can use the {opsi-script} command DeleteKey:
[source,winst]
----
DeleteKey [HKLM\Software\Macromedia]
----


[[opsi-getting-started-softwintegration-tutorial-64bit]]
===== Known Issues with the 64 Bit Support

The opsi installer {opsi-script} is a 32 bit program. There are no known problems when installing 32 bit software on a 64 bit system using {opsi-script}. For the installation of 64 bit software, some constants (like '%ProgramFilesDir%') give wrong values.

New versions of {opsi-script} have special commands to handle these problems. So read the link:https://download.uib.de/opsi_stable/docopsi-script-manual-en.pdf[opsi-script manual] for these issues.


[[opsi-getting-started-softwintegration-create-opsi-package]]
=== Creating an opsi Package

In opsi, the new software is integrated into the system as a package. This package contains the installation files, the {opsi-script} installation script, and any meta data.

The advantages of this format are essentially:

* Simplified menu driven handling using the program `opsi-newprod`.
* Holding all meta data in one file, which is easy to edit.
* Optional menu driven installation of the package, with optional default overriding.
* Information about the package will be saved; including product version, package version, and customer extensions. The package information is stored in the installation directory, and all the information can be seen in the package name and the opsi-configeditor. This means that different package versions can be easily handled (product life cycle management).
* For creating and unpacking products, no root privileges are required. Privileges of the group 'pcpatch' are sufficient.

The package itself is merely a Gzip compressed cpio archive. This archive includes three directories:

* `CLIENT_DATA` +
holds the files which are to be copied into the product directory (`/var/lib/opsi/depot/<productid>`).

* `OPSI` +
The file named `control` holds the product meta data (like the product dependencies). The files `preinst` and `postinst` will be executed before and after the installation. Any customer extensions might be added here.


[[opsi-getting-started-softwintegration-create-opsi-package-handling]]
==== Create, Pack, and Unpack a New Product

In order to create a new opsi package, you must login to the server and do some things at the command line. To be able to do this from windows you may use putty.exe:
(http://www.chiark.greenend.org.uk/~sgtatham/putty/download.html).

The essential commands to create and install packages are:

* `opsi-newprod`
* `opsi-makepackage`
* `opsi-package-manager -i <opsi-product-file>`

The privileges of the group 'pcpatch' are required to create a new product.

Opsi makes use of parallel compression provided by `pigz` if installed. This requires a minimum version 2.2.3 or any higher version. If a sufficient version is installed, opsi will automatically use it for (de-)compression of products.
Please keep in mind that archives created by `gzip` or `pigz` can profit from the bandwidth preserving synchronization via `rsync` but they are not bit-compatible. This will become relevant if you have been using `gzip` before to create your packages and synchronized these packages to other depots. If you now use `pigz` for compression an sync, it will transmit more than the expected differences. This is the case for the first synchronization after a switch of the used compression program. Any further synchronization will then again only transmit the differences.
It is possible to explicitly disable the usage of `pigz` on your server by setting the value for `use_pigz` under the section `packages` in the file `/etc/opsi/opsi.conf` to `False` as shown below:

[source,configfile]
----
[packages]
use_pigz = False
----

You should create products in the directory `/var/lib/opsi/workbench`. This directory is also available as share 'opsi_workbench'. The group 'pcpatch' has to be owner of the directory and the directory permissions are 2770 ('set group ID' bit is set for group pcpatch).


[[opsi-getting-started-softwintegration-create-opsi-package-newprod]]
===== Create with opsi-newprod

WARNING: Do not use any country-specific symbols (umlaut), since the actual country code might vary for different code tables.


To start creating a new product, change directories to the product directory, and start the creation of the new product by entering the command `opsi-newprod`. The next question will ask you about the type of product you want to create. Choose the type 'localboot' for products which should be installable by '{opsi-client-agent}'/'{opsi-script}'. The product type 'netboot' is used for products which are activated as a bootimage (like OS installation)

.Choose the product type: localboot
image::newprod-localboot.png["Screenshot: Choose the product type: localboot", pdfwidth=90%]

Confirm your choice with tab (or F12). Next, fill in the basic product parameters. At the top of the window there is an explanation for the current input field.

.Input of the product information
image::newprod-product-info.png["Screenshot: Input of the product information", pdfwidth=90%]

Product Id:: is a distinct short name for the product, independent from the product version (we recommend to use only plain ASCII letters and '-', no white space, no special characters)

Product name:: is the full name of the product

Description:: is an additional description of the product.

Advice:: is some additional information on how to handle the product (a note).

Product version:: is the version of the packed software (max 32 chars).

Package Version:: is the version of the package for the product version. For example, this helps to distinguish between packages with the same product version but with modified '{opsi-script}' scripts.

License required:: is only relevant to netboot products.

Priority:: controls the installation sequence. Possible Values are between 100 (at the very beginning) and -100 (at the end). Note: product dependencies also have influence on the installation sequence. See the opsi manual for more information.

After the product information is completed, fill in which action scripts should be provided:

.Input of the {opsi-script} script names for different actions
image::newprod-script-names.png["Screenshot: Input of the {opsi-script} script names for different actions", pdfwidth=90%]

After editing the product information you should mention the script you want to use for different activities.

Usually the *+Setup script+* is named `setup.ins`

Usually the *+Uninstall script+* is named `uninstall.ins`

An *+Update-Script+* will be used for minor changes on existing big installations. If this product is switched to the required action 'setup', then the update script will be automatically executed after the setup script.

An *+Always-Script+* will be executed at the beginning of every activity of '{opsi-client-agent}' (e.g. on every boot).

A *+Once-Script+* has the resulting state `not_installed`. It is a very special kind of script, and you should only use it if you really know what you are doing.

A *+Custom-Script+* doesn't change the resulting state.  It is a very special kind of script, and you should only use it if you really know what you are doing.

A *+userLoginScript+* is used to modify the user's profile after the user logs into the system. It only works with the opsi extension 'User Profile Management', which is described at the 'User Profile Management' chapter in the opsi-manual.


|=======================
| Type | resulting state | resulting action
| setup | installed | none
| uninstall | not_installed | none
| update | installed | none
| always | installed | always
| once | not_installed | none
| custom | _unchanged_ | _unchangend_
| User login | _unchanged_ | _unchanged_
|=======================

The next step is to define one or more product dependencies. If there are no product dependencies, select 'No'.

.Create product dependency: No/Yes
image::newprod-product-new-dependency.png["Screenshot: Create product dependency: No/Yes", pdfwidth=90%]

To create a product dependency, enter the following data (help is available at the top of the window):

Dependency for Action:: Which product action shall the dependency create, or when should the dependency be checked (only setup).

Required product id:: Product id of the required product.

Required action:: Select the required action ('setup') for the required product. If no 'required action' is set, a 'required installation status' must be set

Required installation status:: Select the required status of the required product ('installed'). So the required product will be installed if it isn't installed on the client yet. If no 'required installation status' is set, a 'required action' must be set

Requirement type:: This is regarding the installation order. If the required product has to be installed before the installation of the actual product, this is set to 'before'. If it has to be installed after the actual product, set 'requirement type' to 'after'. Leave it blank if the installation order doesn't matter.

NOTE: The possibility to define uninstall actions or dependencies is broken.
After defining a product dependency, you will be asked if you want to create another product dependency. If you choose 'Yes', then the procedure for defining a product dependency is repeated.  If you choose 'No', then you will be asked to define some product properties, which means defining additional  switches for product customization.

NOTE: The installation sequence results from a combination of product dependencies and product priorities. For details on how this is done, and what you can configure, see the opsi-manual.

.A(nother) product property to create?
image::newprod-new-property.png["Screenshot:  A(nother) product property to create?", pdfwidth=90%]

If you answer 'Yes', you will have to describe the product properties.

The product properties are client specific, and have names (keys) which can hold different values. These values can be evaluated by the '{opsi-script}' script, and result in installing different options at installation time.

First we have to decide if our property is a text value ('unicode') or a logical value e.g. true/false ('boolean'). If you are not sure choose 'unicode'.


.Choose the data type of the property
image::newprod-property-type.png["Screenshot: Choose the data type of the property", pdfwidth=90%]

Next, a description for the switch needs to be specified.  This description will be shown in the {opsi-configed} as a help text. Next, you can define the set of values for the switch (separated by comma). If this is left blank, then any value is allowed for the switch.

NOTE: If a values contains a backslash `\` it has to be doubled. +
An example showing how a path would be defined: `C:\\temp`

.Description of the product properties
image::newprod-property-desc.png["Screenshot: Description of the product properties", pdfwidth=90%]

Next, you can decide if the product property has a default value (switch).

.Default value of the product property
image::newprod-property-default.png["Screenshot: Default value of the product property", pdfwidth=90%]

If you choose 'boolean' as the data type, then the description will contain only the 'Property name' and 'Property description'.

.Description of a boolean property
image::newprod-property-boolean.png["Screenshot: Description of a boolean property", pdfwidth=90%]

After defining a product property, you will be asked if you want to create another product property. If you choose 'Yes', then the procedure of defining a property will be repeated.  If you choose 'No', then you will be asked for name and email of the product maintainer. This data will be written on the changelog.

.Input of the maintainer data
image::newprod-maintainer.png["Screenshot: Input of the maintainer data", pdfwidth=90%]

Finally, the basic definitions for the new product are done.

Using the list command (`ls`), you can see the directory structure as described above. Change to the `OPSI` folder and list the content. The `control` file now contains the data you just defined, and you can load the file into an editor to view or change the entries.

.Example of a `control` file:

[source,configfile]
----
[Package]
version: 1
depends:
incremental: False

[Product]
type: localboot
id: mytest
name: My Test
description: A test product
advice:
version: 3.14
priority: 10
licenseRequired: False
productClasses:
setupScript: setup.ins
uninstallScript:
updateScript:
alwaysScript:
onceScript:
customScript:
userLoginScript:

[ProductDependency]
action: setup
requiredProduct: javavm
requiredStatus: installed

[ProductProperty]
type: unicode
name: mytextprop
multivalue: False
editable: True
description: hint
values: ["off", "on"]
default: ["off"]

[ProductProperty]
type: bool
name: myboolprop
description: yes or no
default: False

[Changelog]
mytest (3.14-1) testing; urgency=low

  * Initial package

 -- jane doe <j.doe@opsi.org>  Mi, 14 Jul 2010 12:47:53 +0000
----

For the next step, you will have to copy the product '{opsi-script}' script, and any necessary data files (i.e. program-installation-executable.exe), into the `CLIENT_DATA` folder.

So if the script you have written is currently at `c:\test`, just mount the share '\\<opsiserver\opsi_workbench' e.g. to 'w:', and then copy the complete content of `c:\test` to the directory 'CLIENT_DATA'.

[[opsi-getting-started-softwintegration-create-opsi-package-makeproductfile]]
===== Build the Package with opsi-makepackage

Now you may build the package. Change to the root directory of the product (maybe `/var/lib/opsi/workbench/myproduct/`, and enter 'opsi-makepackage'. The product package will be built.  The package (`<package name>`) will be a file that has a format similar to `/var/lib/opsi/workbench/<myproduct>/<myproduct_ProductVersion-PackageVersion>.opsi`.

Finally, install the package. The resulting package can be installed on the {opsi-server} with the command +
`opsi-package-manager -i <package name>`.

`opsi-makepackage` can be started with different options:

[source,prompt]
----
$ opsi-makepackage --help
usage: opsi-makepackage [--help] [--version] [--quiet] [--verbose]
                        [--log-level {0,1,2,3,4,5,6,7,8,9}] [--no-compression]
                        [--archive-format {cpio,tar}] [--follow-symlinks]
                        [--custom-name custom name | --custom-only custom name]
                        [--temp-directory directory] [--md5 | --no-md5]
                        [--zsync | --no-zsync] [--no-pigz] [--keep-versions]
                        [--package-version packageversion]
                        [--product-version productversion]
                        [source directory]

Provides an opsi package from a package source directory. If no source
directory is supplied, the current directory will be used.

positional arguments:
  source directory

optional arguments:
  --help                Show help.
  --version, -V         show program's version number and exit
  --quiet, -q           do not show progress
  --verbose, -v         verbose
  --log-level {0,1,2,3,4,5,6,7,8,9}, -l {0,1,2,3,4,5,6,7,8,9}
                        Set log-level (0..9)
  --no-compression, -n  Do not compress
  --archive-format {cpio,tar}, -F {cpio,tar}
                        Archive format to use. Default: cpio
  --follow-symlinks, -h
                        follow symlinks
  --custom-name custom name, -i custom name
                        custom name (add custom files)
  --custom-only custom name, -c custom name
                        custom name (custom only)
  --temp-directory directory, -t directory
                        temp dir
  --md5, -m             Create file with md5 checksum.
  --no-md5              Do not create file with md5 checksum.
  --zsync, -z           Create zsync file.
  --no-zsync            Do not create zsync file.
  --no-pigz             Disable the usage of pigz

Versions:
  Set versions for package. Combinations are possible.

  --keep-versions, -k   Keep versions and overwrite package
  --package-version packageversion
                        Set new package version
  --product-version productversion
                        Set new product version for package
----

It is recommended to create the packages with a corresponding md5 checksum file.
This file is used amongst others by `opsi-package-updater` to check after a file transfer to ensure package integrity.
This file is created by default but its creation can be suppressed for special purposes.

When transferring packages to {opsi-depotserver} zsync can be used to only transfer differences between different packages.
To be able to use this method a special `.zsync` file is required.
This file is created by default but its creation can be suppressed for special purposes.

If you are running into the problem that the creation of a package fails because of insufficient free space in `/tmp` you can use the option `--temp-directory` to specify a different temporary folder.

If there is already a package file with the same version information, opsi-makepackage will ask for overwrite confirmation:

[source,prompt]
----
Package file '/var/lib/opsi/workbench/mytest/mytest_3.14-1.opsi' already exists.
Press <O> to overwrite, <C> to abort or <N> to specify a new version:
----
Choosing `o` will overwrite, `c` abort, and 'n' will ask for new version information.

The created opsi-package can be installed at the {opsi-server} with the command: +
`opsi-package-manager --install <packagefile>`

More information about the opsi-package-manager can be found in the opsi-manual.

////