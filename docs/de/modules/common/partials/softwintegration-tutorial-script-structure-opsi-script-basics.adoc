////
; Copyright (c) uib GmbH (www.uib.de)
; This documentation is owned by uib
; and published under the german creative commons by-sa license
; see:
; https://creativecommons.org/licenses/by-sa/3.0/de/
; https://creativecommons.org/licenses/by-sa/3.0/de/legalcode
; english:
; https://creativecommons.org/licenses/by-sa/3.0/
; https://creativecommons.org/licenses/by-sa/3.0/legalcode
;
; credits: http://www.opsi.org/credits/
////

:Author:    uib GmbH
:Email:     info@uib.de
:Date:      24.09.2023
:Revision:  4.3
:toclevels: 6
:doctype:   book
:icons:     font
:xrefstyle: full

include::common:partial$opsi_terms.adoc[]

[[opsi-softwintegration-tutorial-script-structure]]
=== Struktur eines *opsi-script*-Skriptes

Die nächsten Abschnitte erläutern die wesentlichen Elemente eines `opsi-script`-Skriptes für Windows-Rechner. So sieht beispielsweise ein einfaches Skript aus:

[source,ini]
----
[Actions]
WinBatch_<programm>_silent_install

[WinBatch_tightvnc_silent_install]
"%ScriptPath%\<programm-setup.exe>" /silent
----

Ein `opsi-script`-Skript besteht aus <<opsi-softwintegration-tutorial-primary-sections,primären>> und <<opsi-softwintegration-tutorial-secondary-sections,sekundären>> Sektionen.
Sektionen werden, wie von ini-Dateien bekannt, mit einem Sektions-Namen in eckigen Klammern eingeleitet. +
Die eigentlichen Arbeiten zur Software-Installation finden in den sekundären Sektionen statt,
die von den primären Sektionen aufgerufen werden.

Die sekundären Sektionen sind „Themen-spezifisch“ und verfügen jeweils über eine spezielle Syntax. +
Der Sektionsname einer sekundären Sektion beginnt mit deren Typ, gefolgt von einem frei definierbaren Namen.

Im Beispiel ruft die primären Sektion `[Actions]`  eine sekundäre Sektion `[WinBatch_tightvnc_silent_install]` auf. +
Die sekundäre Sektion ist vom Typ `WinBatch`. Der Inhalt einer `WinBatch`-Sektion wird über die Windows-API ausgeführt. +
In diesem Fall wird also das Setup-Programm `tightvnc-1.3.9-setup.exe` mit dem Parameter `/silent` gestartet.


[[opsi-softwintegration-tutorial-primary-sections]]
==== Primäre Sektionen

Actions/Aktionen::
Die `[Actions]` Sektion ist das eigentliche Hauptprogramm. Hier beginnt die Skript-Verarbeitung.

Sub-Sektionen::
Programmabschnitte, die wiederholt benötigt werden, können in Sub-Sektionen (Unterprogramme) ausgelagert werden.
Es besteht die Möglichkeit Sub-Sektionen in externe Dateien auszulagern.

Die primären Sektionen sind das Hauptprogramm in dem der Ablauf des Skriptes gesteuert wird. Hierzu gibt es:

* Variablen: Strings und Stringlisten
* `if` `elseif` `else` `endif` Anweisungen
* `for` Schleifen über Stringlisten
* Funktionen

.Vermeidung doppelten Codes über ausgegliederte Sub
image::opsi-winst-delsub-schema-de.png["Abbildung: Vermeidung doppelten Codes über ausgegliederte Sub",width=400]

[[opsi-softwintegration-tutorial-secondary-sections]]
==== Sekundäre Sektionen

Files::
Datei-Operationen, wie:

* kopieren (mit Versionskontrolle, rekursiv ...)
* löschen
* Verzeichnisse anlegen
* ...

WinBatch::
Dient zum Aufrufen von Programmen über die Windows-API.
Beispielsweise werden Aufrufe von Setup-Programmen im silent mode in diesen Sektionen durchgeführt.

ShellInAnIcon::
Der Inhalt dieser Sektion wird der Betriebssystemtypischen _shell_ zur Ausführung übergeben. Diese _shell_ ist bei Windows die `cmd.exe`, bei Linux und bei macOS die `bash`. Hier können also normale Batch-Skripte abgelegt werden. +
Namensvarianten von `ShellInAnIcon` mit identischem Verhalten sind `Shellbatch`, `DOSBatch` und `DOSInAnIcon`.

ExecWith::
Der Inhalt dieser Sektionen wird einem externen Programm (Interpreter) zur Ausführung übergeben.
Beispielsweise können über `ExecWith` AutoIt-Skripte http://www.autoitscript.com direkt in das opsi-script-Skript integriert werden.

Registry::
Die _Registry-Sektionen_ dienen dem Bearbeiten der Registry.

LinkFolder::
_LinkFolder-Sektionen_ dienen dem Erstellen und Entfernen von Verknüpfungen.
Es können beispielsweise Verknüpfungen auf dem Desktop oder im Startmenü erstellt werden.


[[opsi-softwintegration-tutorial-global-constants]]
==== Globale Konstanten

Globale Konstanten sind Text-Platzhalter, die in primären und sekundären Sektionen eingesetzt werden können
und zur Laufzeit textuell durch ihre Werte ersetzt werden. +
Über die Verwendung von Platzhaltern kann sichergestellt werden,
dass Pfade in unterschiedlichen Umgebungen (z.B. auf System mit unterschiedlichen Sprachen oder Betriebssystem-Versionen) richtig gesetzt sind.

Beispiele:

+%ProgramFiles32Dir%+:: c:\programme
+%Systemroot%+::        c:\windows
+%System%+::            c:\windows\system32
+%opsiTmpDir%+::       c:\opsi.org\tmp
+%Scriptpath%+::        <Pfad zu laufenden Script>

[[opsi-softwintegration-tutorial-second-example]]
==== Beispiel: TightVNC installieren

Zur Erläuterung nun ein einfaches Script zur Installation von _tightvnc_.
Eigentlich würde dieses Script mit dem Aufruf der Silent-Installation in der _Winbatch-Sektion_ auskommen.
Bei einer wiederholten Installation erscheint hier (wegen des Neustarts eines laufenden Services) jedoch ein interaktiver Dialog.
Dieses Dialog-Fenster wird (so es auftaucht) mithilfe von _AutoIt_ geschlossen.

[source,winst]
----
[Actions]
Message "Installiere tightvnc 1.3.9 ..."
ExecWith_autoit_confirm "%ScriptPath%\autoit3.exe" WINST /letThemGo
WinBatch_tightvnc_silent_install
KillTask "autoit3.exe"

[WinBatch_tightvnc_silent_install]
"%ScriptPath%\tightvnc-1.3.9-setup.exe" /silent

[ExecWith_autoit_confirm]
; Wait for the confirm dialog which only appears if tightvnc was installed before as service
; Waiting for the window to appear
WinWait("Confirm")
; Activate (move focus to) window
WinActivate("Confirm")
; Choose answer no
Send("N")
----

[[opsi-softwintegration-tutorial-elementary-commands]]
==== Elementare Befehle für primäre Sektionen

[[opsi-softwintegration-tutorial-elementary-commands-string-variable]]
===== String-Variable

//In Ihrem Beispiel wird eine Variable namens $ProductId$ deklariert und ihr der Wert "firefox" zugewiesen.
Variablen-Deklaration:: `DefVar <variable name> [= <initial value>]`

Variablen-Zuweisung:: `Set <variable name> = <value>`

[source]
----
DefVar $ProductId$
Set $ProductId$ = "firefox"
----

oder

[source]
----
DefVar $ProductId$ = "firefox"
----


IMPORTANT: Stringvariablen werden in primären und sekundären Sektionen unterschiedlich behandelt.
In primären Sektionen sind Stringvariablen eigenständige Objekte.
Nur hier können sie deklariert und ihnen Werte zugewiesen werden.
Entsprechend ist die Verbindung von Variablen und Strings zu einem Stringausdruck mit einem Operator `"+"` durchzuführen. +
Beispiel: `"Installing "+ $ProductId$ +" ..."` +
In sekundären Sektionen werden Stringvariablen vor der Ausführung der Sektion durch den Inhalt der Variable ersetzt. +
Beispiel: `"Installing $ProductId$ ..."` +
Dies ist zu beachten, wenn entsprechende Stringausdrücke per Cut&Paste im Skript kopiert werden. +
Der Vorteil dieser Konstruktion ist, dass in Sektionen die außerhalb des _opsi-script_ ausgeführt werden (DosBatch / Execwith)
problemlos mit opsi-script-Variablen gearbeitet werden kann.

[[opsi-softwintegration-tutorial-elementary-commands-message]]
===== Anweisungen: *Message* und *ShowBitmap*

//"Message <string>" ist wahrscheinlich eine Anweisung oder ein Format, um eine Nachricht oder einen Text in Form einer Zeichenfolge (<string>) während der Installation anzuzeigen. <string> sollte durch den tatsächlichen Text ersetzt werden, den Sie anzeigen möchten.

Zur Textausgabe während der Installation: +
`Message <string>`

[source]
----
Message "Installing "+ $ProductId$ +" ..."
----

Zur Ausgabe einer Grafik während der Installation: +
`ShowBitmap <filename> <subtitle>`

[source]
----
ShowBitmap "%ScriptPath%\python.png" "Python"
----

[[opsi-softwintegration-tutorial-elementary-commands-if-else-endif]]
===== Bedingte Anweisungen: *if*, *elseif* und *else*

if [elseif] [else] endif
//Der Ausdruck, den Sie gezeigt haben, ist eine vereinfachte Darstellung eines bedingten Konstruktionsblocks in vielen Programmiersprachen. Dieses Konstrukt ermöglicht es, Code abhängig von einer bestimmten Bedingung auszuführen. Lassen Sie uns die einzelnen Teile erklären:

if (<Bedingung>): Dies ist die erste Bedingung. Sie überprüfen hier eine bestimmte Bedingung. Wenn diese Bedingung wahr (true) ist, werden die im folgenden Block eingeschlossenen Anweisungen ausgeführt. Wenn die Bedingung falsch (false) ist, wird dieser Block übersprungen.

;statement(s): Dies ist der Codeblock, der ausgeführt wird, wenn die Bedingung im "if"-Teil wahr ist. Hier können eine oder mehrere Anweisungen stehen, die ausgeführt werden, wenn die Bedingung erfüllt ist.

elseif (<Bedingung>): Dieser Teil ist optional. Wenn die Bedingung im "if"-Teil nicht erfüllt ist, wird die Bedingung hier überprüft. Wenn diese Bedingung wahr ist, werden die im folgenden Block eingeschlossenen Anweisungen ausgeführt. Dies ermöglicht das Hinzufügen zusätzlicher Bedingungen, die überprüft werden, wenn die vorherigen Bedingungen nicht erfüllt sind.

else: Dieser Teil ist ebenfalls optional. Wenn keine der vorherigen Bedingungen wahr ist, werden die Anweisungen im "else"-Block ausgeführt. Dies ist eine Art von Fallback-Block, der dann ausgeführt wird, wenn keine der vorherigen Bedingungen zutrifft.

endif: Dies markiert das Ende des bedingten Konstrukts. Es zeigt an, dass die bedingte Überprüfung hier endet.


[source]
----
if <condition>
	;statement(s)
[elseif <condition>
;statement(s)]
[
else
	;statement(s)
]
endif
----

[[opsi-softwintegration-tutorial-elementary-commands-functions]]
===== Funktionen

HasMinimumSpace:: Prüft auf freien Platz auf der Festplatte.
FileExists:: Prüft auf Existenz einer Datei oder eines Verzeichnisses.

[[opsi-softwintegration-tutorial-elementary-commands-error]]
===== Fehler, Logging und Kommentare

Kommentarzeichen ';':: Zeilen, die mit einem Semikolon (';') beginnen, werden nicht interpretiert.

Comment:: Schreibt eine Kommentar-Meldung in die Log-Datei.

LogError:: Schreibt eine Fehlermeldung in die Log-Datei.

IsFatalError:: Bricht die Ausführung des laufenden Skriptes ab und meldet die Installation als gescheitert zurück.

[[opsi-softwintegration-tutorial-elementary-commands-requirements]]
===== Bedingung zur Ausführung

requiredOpsiscriptVersion:: gibt die (mindestens) benötigte opsi-script Version an.

[[opsi-softwintegration-tutorial-winst-commands]]
===== Weitere wichtige *opsi-script*-Funktionen

Hier noch einige Hinweise auf besonders wichtige Elemente:

//String-Listen (auch als Zeichenketten-Listen oder Textlisten bezeichnet) sind in der Regel Sammlungen von Zeichenketten (Strings), die in einer bestimmten Reihenfolge oder als Gruppe gespeichert sind. Sie sind ein grundlegendes Datenstrukturelement in der Programmierung und werden verwendet, um eine Menge von Zeichenketten in einer einzigen Variablen oder Datenstruktur zu speichern und zu verwalten.
*String-Listen*:
Stringlisten sind sehr mächtig, insbesondere zur Auswertung von Ausgaben externer Programme. Lesen Sie dazu die opsi-script-Dokus.

//Funktion?
*Funktion* `ExitWindows`:
Neustart/Herunterfahren des Systems und Beendung des opsi-script.

*  `ExitWindows /Reboot` +
Rechner-Neustart nach Abschluss des laufenden Skriptes.

*  `ExitWindows /ImmediateReboot` +
Sofortiger Neustart.

*  `ExitWindows /ImmediateLogout` +
Sofortige Beendigung der Skript-Bearbeitung und Beendung des opsi-script.

*Produkteigenschaften*:
Für manche Produkte ist es erforderlich, Optionen zur Verfügung zu stellen.
Diese werden zur Laufzeit Client-spezifisch ausgewertet.
Wie solche Properties erstellt werden, ist im Kapitel
<<opsi-client-softwintegration-create-opsi-package,Erstellen eines opsi-Produkt-Pakets>> beschrieben.

Der Zugriff auf die Werte der Properties geschieht über die Funktion `GetProductProperty`:

[source]
----
if GetProductProperty("example-property", "no") = "yes"
	Files_copy_extra_files
endif
----

*Encoding*:
Schreiben Sie Ihre Scripte in UTF-8 Encoding und setzen sie die Zeile +
`encoding=utf8`
an den Anfang der Datei-
