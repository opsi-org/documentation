////
; Copyright (c) uib gmbh (www.uib.de)
; This documentation is owned by uib
; and published under the german creative commons by-sa license
; see:
; https://creativecommons.org/licenses/by-sa/3.0/de/
; https://creativecommons.org/licenses/by-sa/3.0/de/legalcode
; english:
; https://creativecommons.org/licenses/by-sa/3.0/
; https://creativecommons.org/licenses/by-sa/3.0/legalcode
;
////

:Author:    uib gmbh
:Email:     info@uib.de
:Revision:  4.2
:toclevels: 6
:doctype:   book

// Include common opsi terms
ifeval::["{mode}" == "antora"]
include::common:partial$opsi_terms.adoc[]
endif::[]

include::common:partial$firststeps-softwintegration-win.adoc[]

////

[[opsi-getting-started-softwintegration]]
== Einbindung eigener Software in die Softwareverteilung von opsi

Die Installation von Software erfolgt bei opsi durch den opsi-client-agent und insbesondere durch das Script gesteuerte Setup Programm opsi-script. Daher muss zu jedem opsi-Produkt ein opsi-script-Script erstellt werden. Danach werden dieses Script, die Installationsdateien und die Metadaten zu einem opsi-Produkt gepackt, welches sich schließlich auf dem opsi-Server installieren lässt.

[[opsi-getting-started-softwintegration-tutorial]]
=== Ein kleines Tutorial zur Erstellung eines opsi-script Scriptes

[[opsi-getting-started-softwintegration-tutorial-introduction]]
==== Einführung

Dieses Tutorial kann keine Schulung oder das Studium der Handbücher ersetzen. Es dient nur dazu eine Einführung zu bekommen. Daher als erstes der Verweis auf weiterführende Quellen:

.Schulungen:

Die uib GmbH bietet opsi-Schulungen in Mainz und Inhouse Schulungen an: +
https://uib.de/de/support-schulung/schulung/

.Handbücher:

https://uib.de/de/opsi-dokumentation/dokumentationen/ +
Besonders wichtig: +
opsi-script-Reference-Card und opsi-script-Handbuch

.Wiki (Scripte, Tipps, Links):

https://forum.opsi.org/wiki

.Support Forum:
siehe https://forum.opsi.org

[[opsi-getting-started-softwintegration-tutorial-general]]
==== Methoden der nicht interaktiven Softwareinstallation

Prinzipiell gibt es drei Verfahren der Einbindung eines Softwarepakets in die automatische Softwareverteilung für Windows-Betriebssysteme, zuzüglich einer Variante, die sich auf die Pakete für den Microsoft Installer Service bezieht.

. *Unattended / Silent Setup*: +
Das Original-Setupprogramm wird verwendet und über Kommandozeilenargumente in einen nicht-interaktiven Modus versetzt.
Der wichtigste Spezialfall davon ist der +
*„stille“ Aufruf eines MSI-Pakets*: +
Ein Paket für den Microsoft Installer Service ist vorhanden und wird mit einer „quiet“-Option aufgerufen.

. *Interaktives Setup mit automatisierten Antworten*: +
Zur Vorbereitung wird bei einem Lauf des Original-Setupprogramms festgestellt, welche Fenstertitel das Programm zeigt
und welche Fragen und Antworten beim Setup anfallen. Dies wird in einem Skript niedergeschrieben.
Im Prozess der Softwareverteilung läuft das Setupprogramm dann unter Kontrolle eines Automatisierungs-Programms
wie z.B. AutoIt oder Autohotkey, welches das Setupprogramm gemäß dem Skript steuert.

. *Nachbilden der Setup-Routine mit dem opsi-script*: +
Bei einem Lauf des originalen Setupprogramms werden etwaige System-Änderungen mitprotokolliert, z.B. mit procmon und mithilfe des opsi-script nachgefahren.

NOTE: Opsi unterstützt alle drei Varianten. In der Praxis werden sie häufig ergänzend verwendet.

[[opsi-getting-started-softwintegration-tutorial-script-structure]]
==== Struktur eines opsi-script-Skripts

Zunächst ein Beispiel für ein einfaches opsi-script-Skript:
[source,winst]
----
[Actions]
WinBatch_tightvnc_silent_install

[WinBatch_tightvnc_silent_install]
"%ScriptPath%\tightvnc-1.3.9-setup.exe" /silent
----

Ein opsi-script-Skript besteht aus *primären* und *sekundären* Sektionen.
Sektionen werden, wie von ini-Dateien bekannt, mit einem Sektions-Namen in eckigen Klammern eingeleitet. +
Die eigentlichen Arbeiten zur Software-Installation finden in den sekundären Sektionen statt,
die von den primären Sektionen aufgerufen werden.

Die sekundären Sektionen sind „Themen-spezifisch“ und verfügen jeweils über eine spezielle Syntax. +
Der Sektionsname einer sekundären Sektion beginnt mit deren Typ, gefolgt von einem frei definierbaren Namen.

Im Beispiel ruft die primären Sektion +[Actions]+  eine sekundäre Sektion +[WinBatch_7z_silent_install]+ auf. +
Die sekundäre Sektion ist vom Typ +WinBatch+. Der Inhalt einer +WinBatch+-Sektion wird über die Windows-API ausgeführt. +
In diesem Fall wird also das Setup-Programm `7z.exe` mit dem Parameter +/S+ gestartet.


[[opsi-getting-started-softwintegration-tutorial-primary-sections]]
==== Primäre Sektionen

Actions/Aktionen::
Die +[Actions]+ Sektion ist das eigentliche Hauptprogramm. Hier beginnt die Skript-Verarbeitung.

Sub-Sektionen::
Programmabschnitte, die wiederholt benötigt werden, können in Sub-Sektionen (Unterprogramme) ausgelagert werden.
Es besteht die Möglichkeit Sub-Sektionen in externe Dateien auszulagern.

Die primären Sektionen sind das Hauptprogramm in dem der Ablauf des Skripts gesteuert wird. Hierzu gibt es:

* Variablen: Strings und Stringlisten
* +if+ +else+ +endif+ Anweisungen
* +for+ Schleifen über Stringlisten
* Funktionen

.Vermeidung doppelten Codes über ausgegliederte Sub
image::opsi-winst-delsub-schema.png["Abbildung: Vermeidung doppelten Codes über ausgegliederte Sub", pdfwidth=90%]


[[opsi-getting-started-softwintegration-tutorial-secondary-sections]]
==== Wichtige sekundäre Sektionen

Files::
Datei-Operationen, wie:

* kopieren (mit Versionskontrolle, rekursiv ...)
* löschen
* Verzeichnisse anlegen
* ...

WinBatch::
Dient zum Aufrufen von Programmen über die Windows-API.
Beispielsweise werden Aufrufe von Setup-Programmen im silent mode in diesen Sektionen durchgeführt.

DosBatch/DosInAnIcon::
Der Inhalt dieser Sektionen wird der 'cmd.exe' zur Ausführung übergeben. Hier können also normale Batch-Skripte abgelegt werden. +
Eine Variante von 'DosBatch' ist 'DosInAnIcon', wobei die 'cmd.exe' mit minimiertem Fenster aufgerufen wird.

ExecWith::
Der Inhalt dieser Sektionen wird einem externen Programm (Interpreter) zur Ausführung übergeben.
Beispielsweise können über 'ExecWith' AutoIt-Skripte http://www.autoitscript.com direkt in das opsi-script-Skript integriert werden.

Registry::
Die 'Registry-Sektionen' dienen dem Bearbeiten der Registry.

LinkFolder::
'LinkFolder-Sektionen' dienen dem Erstellen und Entfernen von Verknüpfungen.
Es können beispielsweise Verknüpfungen auf dem Desktop oder im Startmenü erstellt werden.


[[opsi-getting-started-softwintegration-tutorial-global-constants]]
==== Globale Konstanten

Globale Konstanten sind Text-Platzhalter, die in primären und sekundären Sektionen eingesetzt werden können
und zur Laufzeit textuell durch ihre Werte ersetzt werden. +
Über die Verwendung von Platzhaltern kann sichergestellt werden,
dass Pfade in unterschiedlichen Umgebungen (z.B. auf System mit unterschiedlichen Sprachen oder Betriebssystem-Versionen) richtig gesetzt sind.

Beispiele:

+%ProgramFiles32Dir%+:: c:\programme
+%Systemroot%+::        c:\windows
+%System%+::            c:\windows\system32
+%Systemdrive%+::       c:\
+%Scriptpath%+::        <Pfad zu laufenden Script>

[[opsi-getting-started-softwintegration-tutorial-second-example]]
==== Zweites Beispiel: tightvnc

Zur Erläuterung nun ein einfaches Script zur Installation von 'tightvnc'.
Eigentlich würde dieses Script mit dem Aufruf der Silent-Installation in der Winbatch-Sektion auskommen.
Bei einer wiederholten Installation erscheint hier (wegen des Neustarts eines laufenden Services) jedoch ein interaktiver Dialog.
Dieses Dialog-Fenster wird (so es auftaucht) mithilfe von 'AutoIt' geschlossen.

[source,winst]
----
[Actions]
Message "Installiere tightvnc 1.3.9 ..."
ExecWith_autoit_confirm "%ScriptPath%\autoit3.exe" WINST /letThemGo
WinBatch_tightvnc_silent_install
KillTask "autoit3.exe"

[WinBatch_tightvnc_silent_install]
"%ScriptPath%\tightvnc-1.3.9-setup.exe" /silent

[ExecWith_autoit_confirm]
; Wait for the confirm dialog which only appears if tightvnc was installed before as service
; Waiting for the window to appear
WinWait("Confirm")
; Activate (move focus to) window
WinActivate("Confirm")
; Choose answer no
Send("N")
----

[[opsi-getting-started-softwintegration-tutorial-elementary-commands]]
==== Elementare Befehle für primäre Sektionen

[[opsi-getting-started-softwintegration-tutorial-elementary-commands-string-variable]]
===== String-Variable

Variablen-Deklaration:: 'DefVar <variable name>'

Variablen-Zuweisung:: 'Set <variable name> = <value>'

*Beispiel:*
[source,winst]
----
DefVar $ProductId$
Set $ProductId$ = "firefox"
----

IMPORTANT: Stringvariablen werden in primären und sekundären Sektionen unterschiedlich behandelt.
In primären Sektionen sind Stringvariablen eigenständige Objekte.
Nur hier können sie deklariert und ihnen Werte zugewiesen werden.
Entsprechend ist die Verbindung von Variablen und Strings zu einem Stringausdruck mit einem Operator `"+"` durchzuführen. +
Beispiel: `"Installing "+ $ProductId$ +" ..."` +
In sekundären Sektionen werden Stringvariablen vor der Ausführung der Sektion durch den Inhalt der Variable ersetzt. +
Beispiel: `"Installing $ProductId$ ..."` +
Dies ist zu beachten, wenn entsprechende Stringausdrücke per Cut&Paste im Skript kopiert werden. +
Der Vorteil dieser Konstruktion ist, dass in Sektionen die außerhalb des '{opsi-script}' ausgeführt werden (DosBatch / Execwith)
problemlos mit opsi-script-Variablen gearbeitet werden kann.

[[opsi-getting-started-softwintegration-tutorial-elementary-commands-message]]
===== Message / ShowBitmap

Zur Textausgabe während der Installation: +
`Message <string>`

*Beispiel:*
[source,winst]
----
Message "Installing "+ $ProductId$ +" ..."
----

Zur Ausgabe einer Grafik während der Installation: +
`ShowBitmap <filename> <subtitle>`

*Beispiel:*
[source,winst]
----
ShowBitmap "%ScriptPath%\python.png" "Python"
----

[[opsi-getting-started-softwintegration-tutorial-elementary-commands-if-else-endif]]
===== if [else] endif

*Syntax:*
[source,winst]
----
if <condition>
	;statement(s)
[
else
	;statement(s)
]
endif
----

[[opsi-getting-started-softwintegration-tutorial-elementary-commands-functions]]
===== Funktionen

HasMinimumSpace:: Prüft auf freien Platz auf der Festplatte.
FileExists:: Prüft auf Existenz einer Datei oder eines Verzeichnisses.

[[opsi-getting-started-softwintegration-tutorial-elementary-commands-error]]
===== Fehler, Logging und Kommentare

Kommentarzeichen ';':: Zeilen, die mit einem Semikolon (';') beginnen, werden nicht interpretiert.

Comment:: Schreibt eine Kommentar-Meldung in die Log-Datei.

LogError:: Schreibt eine Fehlermeldung in die Log-Datei.

IsFatalError:: Bricht die Ausführung des laufenden Skriptes ab und meldet die Installation als gescheitert zurück.

[[opsi-getting-started-softwintegration-tutorial-elementary-commands-requirements]]
===== Bedingung zur Ausführung

requiredWinstVersion:: gibt die (mindestens) benötigte opsi-script Version an.

[[opsi-getting-started-softwintegration-tutorial-template]]
==== Drittes Beispiel: Standard-Template 'opsi-template'

Verwenden Sie dieses Template (bzw. eine aktualisierte Versionen von http://download.uib.de) als Basis für Ihre eigenen Skripte.
Das Template-Paket können Sie auf Ihrem Server mittels `opsi-package-manager` installieren (+-i+)
oder entpacken (+-x+), um an die enthaltenen Skripte zu gelangen.


.setup32.opsiscript: Installationsscript
[source,winst]
----
; Copyright (c) uib gmbh (www.uib.de)
; This sourcecode is owned by uib
; and published under the Terms of the General Public License.
; credits: http://www.opsi.org/en/credits/

[Actions]
requiredWinstVersion >= "4.11.4.6"
ScriptErrorMessages=off

DefVar $MsiId$
DefVar $UninstallProgram$
DefVar $LogDir$
DefVar $ProductId$
DefVar $MinimumSpace$
DefVar $InstallDir$
DefVar $ExitCode$
DefVar $LicenseRequired$
DefVar $LicenseKey$
DefVar $LicensePool$
DefVar $displayName32$
DefVar $displayName64$

DefStringlist $msilist$

Set $LogDir$ = "%opsiLogDir%"

; ----------------------------------------------------------------
; - Please edit the following values                             -
; ----------------------------------------------------------------
;$ProductId$ should be the name of the product in opsi
; therefore please: only lower letters, no umlauts,
; no white space use '-' as a seperator
Set $ProductId$       = "opsi-template"
Set $MinimumSpace$    = "1 MB"
; the path were we find the product after the installation
Set $InstallDir$      = "%ProgramFiles32Dir%\<path to the product>"
Set $LicenseRequired$ = "false"
Set $LicensePool$     = "p_" + $ProductId$
; ----------------------------------------------------------------

if not(HasMinimumSpace ("%SystemDrive%", $MinimumSpace$))
	LogError "Not enough space on %SystemDrive%, " + $MinimumSpace$ + " on drive %SystemDrive% needed for " + $ProductId$
	isFatalError "No Space"
	; Stop process and set installation status to failed
else
	comment "Show product picture"
	ShowBitmap "%ScriptPath%\" + $ProductId$ + ".png" $ProductId$

	if FileExists("%ScriptPath%\delsub32.opsiscript")
		comment "Start uninstall sub section"
		Sub "%ScriptPath%\delsub32.opsiscript"
	endif

	Message "Installing " + $ProductId$ + " ..."

	if $LicenseRequired$ = "true"
		comment "Licensing required, reserve license and get license key"
		Sub_get_licensekey
	endif

	comment "Start setup program"
	ChangeDirectory "%SCRIPTPATH%"
	Winbatch_install
	Sub_check_exitcode

	comment "Copy files"
	Files_install /32Bit

	comment "Patch Registry"
	Registry_install /32Bit

	comment "Create shortcuts"
	LinkFolder_install

endif

[Winbatch_install]
; Choose one of the following examples as basis for your installation
; You can use $LicenseKey$ var to pass a license key to the installer
;
; === Nullsoft Scriptable Install System ================================================================
; "%ScriptPath%\Setup.exe" /S
;
; === MSI package =======================================================================================
; You may use the parameter PIDKEY=$Licensekey$
; msiexec /i "%ScriptPath%\some.msi" /l* "$LogDir$\$ProductId$.install_log.txt" /qb-! ALLUSERS=1 REBOOT=ReallySuppress
;
; === InstallShield + MSI=====================================================================================
; Attention: The path to the log file should not contain any whitespaces
; "%ScriptPath%\setup.exe" /s /v" /l* $LogDir$\$ProductId$.install_log.txt /qb-! ALLUSERS=1 REBOOT=ReallySuppress"
; "%ScriptPath%\setup.exe" /s /v" /qb-! ALLUSERS=1 REBOOT=ReallySuppress"
;
; === InstallShield =====================================================================================
; Create setup.iss answer file by running: setup.exe /r /f1"c:\setup.iss"
; You may use an answer file by the parameter /f1"c:\setup.iss"
; "%ScriptPath%\setup.exe" /s /sms /f2"$LogDir$\$ProductId$.install_log.txt"
;
; === Inno Setup ========================================================================================
; http://unattended.sourceforge.net/InnoSetup_Switches_ExitCodes.html
; You may create setup answer file by: setup.exe /SAVEINF="filename"
; You may use an answer file by the parameter /LOADINF="filename"
; "%ScriptPath%\setup.exe" /sp- /silent /norestart /nocancel /SUPPRESSMSGBOXES

[Files_install]
; Example of recursively copying some files into the installation directory:
;
; copy -s "%ScriptPath%\files\*.*" "$InstallDir$"

[Registry_install]
; Example of setting some values of a registry key:
;
; openkey [HKEY_LOCAL_MACHINE\Software\$ProductId$]
; set "name1" = "some string value"
; set "name2" = REG_DWORD:0001
; set "name3" = REG_BINARY:00 af 99 cd

[LinkFolder_install]
; Example of deleting a folder from AllUsers startmenu:
;
; set_basefolder common_programs
; delete_subfolder $ProductId$
;
; Example of creating an shortcut to the installed exe in AllUsers startmenu:
;
; set_basefolder common_programs
; set_subfolder $ProductId$
;
; set_link
; 	name: $ProductId$
; 	target: <path to the program>
; 	parameters:
; 	working_dir: $InstallDir$
; 	icon_file:
; 	icon_index:
; end_link
;
; Example of creating an shortcut to the installed exe on AllUsers desktop:
;
; set_basefolder common_desktopdirectory
; set_subfolder ""
;
; set_link
; 	name: $ProductId$
; 	target: <path to the program>
; 	parameters: <some_param>
; 	working_dir: $InstallDir$
; 	icon_file: <path to icon file>
; 	icon_index: 2
; end_link

[Sub_get_licensekey]
if opsiLicenseManagementEnabled
	comment "License management is enabled and will be used"

	comment "Trying to get a license key"
	Set $LicenseKey$ = demandLicenseKey ($LicensePool$)
	; If there is an assignment of exactly one licensepool to the product the following call is possible:
	; Set $LicenseKey$ = demandLicenseKey ("", $ProductId$)
	;
	; If there is an assignment of a license pool to a windows software id, it is possible to use:
	; DefVar $WindowsSoftwareId$
	; $WindowsSoftwareId$ = "..."
	; Set $LicenseKey$ = demandLicenseKey ("", "", $WindowsSoftwareId$)

	DefVar $ServiceErrorClass$
	set $ServiceErrorClass$ = getLastServiceErrorClass
	comment "Error class: " + $ServiceErrorClass$

	if $ServiceErrorClass$ = "None"
		comment "Everything fine, we got the license key '" + $LicenseKey$ + "'"
	else
		if $ServiceErrorClass$ = "LicenseConfigurationError"
			LogError "Fatal: license configuration must be corrected"
			LogError getLastServiceErrorMessage
			isFatalError
		else
			if $ServiceErrorClass$ = "LicenseMissingError"
				LogError "Fatal: required license is not supplied"
				isFatalError
			endif
		endif
	endif
else
	LogError "Fatal: license required, but license management not enabled"
	isFatalError
endif


[Sub_check_exitcode]
comment "Test for installation success via exit code"
set $ExitCode$ = getLastExitCode
; informations to exit codes see
; http://msdn.microsoft.com/en-us/library/aa372835(VS.85).aspx
; http://msdn.microsoft.com/en-us/library/aa368542.aspx
if ($ExitCode$ = "0")
	comment "Looks good: setup program gives exitcode zero"
else
	comment "Setup program gives a exitcode unequal zero: " + $ExitCode$
	if ($ExitCode$ = "1605")
		comment "ERROR_UNKNOWN_PRODUCT	1605	This action is only valid for products that are currently installed."
		comment "Uninstall of a not installed product failed - no problem"
	else
		if ($ExitCode$ = "1641")
			comment "looks good: setup program gives exitcode 1641"
			comment "ERROR_SUCCESS_REBOOT_INITIATED	1641	The installer has initiated a restart. This message is indicative of a success."
		else
			if ($ExitCode$ = "3010")
				comment "looks good: setup program gives exitcode 3010"
				comment "ERROR_SUCCESS_REBOOT_REQUIRED	3010	A restart is required to complete the install. This message is indicative of a success."
			else
				logError "Fatal: Setup program gives an unknown exitcode unequal zero: " + $ExitCode$
				isFatalError
			endif
		endif
	endif
endif
----

.delsub32.opsiscript: Ausgelagerte Deinstallations-Sub-Sektion
[source,winst]
----
; Copyright (c) uib gmbh (www.uib.de)
; This sourcecode is owned by uib gmbh
; and published under the Terms of the General Public License.
; credits: http://www.opsi.org/en/credits/

Set $MsiId$ = '{XXXXXXXX-XXXX-XXXX-XXXX-XXXXXXXXXXXX}'
Set $UninstallProgram$ = $InstallDir$ + "\uninstall.exe"

Message "Uninstalling " + $ProductId$ + " ..."

if FileExists($UninstallProgram$)
	comment "Uninstall program found, starting uninstall"
	Winbatch_uninstall
	sub_check_exitcode
endif
if not (GetRegistryStringValue32("[HKEY_LOCAL_MACHINE\SOFTWARE\Microsoft\Windows\CurrentVersion\Uninstall\" + $MsiId$ + "] DisplayName") = "")
	comment "MSI id " + $MsiId$ + " found in registry, starting msiexec to uninstall"
	Winbatch_uninstall_msi
	sub_check_exitcode
endif

comment "Delete files"
Files_uninstall /32Bit

comment "Cleanup registry"
Registry_uninstall /32Bit

comment "Delete program shortcuts"
LinkFolder_uninstall

[Winbatch_uninstall]
; Choose one of the following examples as basis for program uninstall
;
; === Nullsoft Scriptable Install System ================================================================
; maybe better called as
; Winbatch_uninstall /WaitforProcessending "Au_.exe" /Timeoutseconds 10
; "$UninstallProgram$" /S
;
; === Inno Setup ========================================================================================
; "$UninstallProgram$" /silent /norestart /SUPPRESSMSGBOXES /nocancel

[Winbatch_uninstall_msi]
msiexec /x $MsiId$ /qb-! REBOOT=ReallySuppress

[Files_uninstall]
; Example for recursively deleting the installation directory:
;
; del -sf "$InstallDir$\"

[Registry_uninstall]
; Example of deleting a registry key:
;
; deletekey [HKEY_LOCAL_MACHINE\Software\$ProductId$]

[LinkFolder_uninstall]
; Example of deleting a folder from AllUsers startmenu:
;
; set_basefolder common_programs
; delete_subfolder $ProductId$
;
; Example of deleting a shortcut from AllUsers desktop:
;
; set_basefolder common_desktopdirectory
; set_subfolder ""
; delete_element $ProductId$


[Sub_check_exitcode]
;(.... siehe oben .....)
----

.uninstall32.opsiscript: Deinstallations-Skript
[source,winst]
----
; Copyright (c) uib gmbh (www.uib.de)
; This sourcecode is owned by uib
; and published under the Terms of the General Public License.
; credits: http://www.opsi.org/en/credits/

[Actions]
requiredWinstVersion >= "4.11.4.6"
ScriptErrorMessages=off

DefVar $MsiId$
DefVar $UninstallProgram$
DefVar $LogDir$
DefVar $ExitCode$
DefVar $ProductId$
DefVar $InstallDir$
DefVar $LicenseRequired$
DefVar $LicensePool$

Set $LogDir$ = "%opsiLogDir%"

; ----------------------------------------------------------------
; - Please edit the following values                             -
; ----------------------------------------------------------------
Set $ProductId$       = "opsi-template"
Set $InstallDir$      = "%ProgramFiles32Dir%\<path to the product>"
Set $LicenseRequired$ = "false"
Set $LicensePool$     = "p_" + $ProductId$
; ----------------------------------------------------------------


comment "Show product picture"
ShowBitmap "%ScriptPath%\" + $ProductId$ + ".png" $ProductId$

Message "Uninstalling " + $ProductId$ + " ..."

if FileExists("%ScriptPath%\delsub32.opsiscript")
	comment "Start uninstall sub section"
	Sub "%ScriptPath%\delsub32.opsiscript"
endif

if $LicenseRequired$ = "true"
	comment "Licensing required, free license used"
	Sub_free_license
endif

[Sub_free_license]
comment "License management is enabled and will be used"

comment "Trying to free license used for the product"
DefVar $result$
Set $result$ = FreeLicense($LicensePool$)
; If there is an assignment of a license pool to the product, it is possible to use
; Set $result$ = FreeLicense("", $ProductId$)
;
; If there is an assignment of a license pool to a windows software id, it is possible to use
; DefVar $WindowsSoftwareId$
; $WindowsSoftwareId$ = "..."
; set $result$ = FreeLicense("", "", $WindowsSoftwareId$)
----

[[opsi-getting-started-softwintegration-tutorial-create-and-test-script]]
==== Interaktives Erstellen und Testen eines opsi-script Skriptes

Sie können ein Skript interaktiv anpassen und testen.

Erstellen Sie sich dazu ein Verzeichnis (z.B. `c:\test`) und kopieren Sie die Scripte des opsi-template (`setup.ins`, `delsub.ins` und `uninstall.ins`) in dieses Verzeichnis.

Starten Sie opsi-script (`winst32.exe`) per Doppelklick. (Beim Starten des opsi-script auf einem Windows 7 Client muss "ausführen als Administrator" über die rechte Maustaste verwendet werden.) Wenn der `opsi-client-agent` bereits auf Ihrem Rechner installiert ist, finden Sie opsi-script
unter `C:\Programme\opsi.org\opsi-client-agent\opsi-script`.
Wenn nicht, kopieren Sie sich das Verzeichnis `opsi-script` vom share `\\<opsiserver\opsi_depot_rw`, aus dem Verzeichnis `install\opsi-winst\files.`
Sie sehen dann folgendes Fenster:

.opsi-script im interaktiven Modus
image::opsi-script-interaktiv.png["Screenshot: opsi-script im interaktiven Modus", pdfwidth=90%]

Über 'Select Script' können Sie das Skript auswählen, dass Sie ausführen möchten.
Mit 'Start' können Sie das Script starten. Dabei wird das Script auf diesem Rechner ausgeführt.
Über 'View Log' können Sie sich die Log-Datei des Skript-Laufes anschauen.

.opsi-script Log View Fenster
image::winst-log-view.png[Screenshot: opsi-script Log View Fenster, pdfwidth=90%]

* Schauen Sie sich anhand der Log-Datei an, wie der opsi-script das Skript interpretiert.

* Kopieren Sie die `Setup.exe`, welche Sie installieren wollen, in das Verzeichnis, in dem die Skripte liegen (z.B. `c:\test`).

* Öffenen Sie das Script `setup.ins` in einem Editor.
Im Prinzip können Sie jeden beliebigen Editor verwenden.
Wir empfehlen den Editor 'jEdit' mit opsi-script Syntax-Highlighting, wie Sie ihn in der Grundausstattung der opsi-Produkte finden.

.jEdit mit einem opsi script
image::jedit-with-winst-script.png["jEdit with a opsi script", pdfwidth=80%]


* Sie können nun das Skript im Editor anpassen und speichern (Sie können den Editor geöffnet lassen).
Wechseln Sie zum opsi-script-Fenster und starten Sie das Skript erneut über den Knopf 'Start' (das Skript muss nicht neu ausgewählt werden).
Schauen Sie sich das auf Basis Ihrer Änderungen im Skript veränderte Log über `View Log` an.

* Auf diese Art und Weise, also über die Wiederholung der Punkte: +
 - Anpassung des Skriptes und speichern +
 - Skript ausführen +
 - Log überprüfen +
können Sie nach und nach Ihre Skripte so anpassen, dass sie das tun, was Sie wünschen.

Hinweise zur Lösung von Detail-Problemen finden Sie im nächsten Kapitel.
Im übernächsten Kapitel wird erklärt, wie Sie aus den so erstellten Skripten ein opsi-Produkt erstellen, das Sie auf dem opsi-Server installieren können.

[[opsi-getting-started-softwintegration-tutorial-template-details]]
==== Hinweise zu den Teilaufgaben im opsi-template

[[opsi-getting-started-softwintegration-tutorial-find-switches]]
===== Silent oder Unattended Schalter finden

Beim „unattended“ oder „silent setup“  wird das Original-Setup-Programm über Kommandozeilen-Argumente in einen nicht interaktiven Modus gestellt.

Das Problem dieser Installationsmethode ist es die geeigneten Kommandozeilenargumente zu finden.

.Suche in Schaltersammlungen im Internet:
Bevor man sich in Forschungen stürzt, ist dringend zu empfehlen bei opsi.org zu schauen, ob jemand das Problem bereits gelöst hat:

Fertige opsi-script-Skripte aus der Community gibt es im link:https://forum.opsi.org/wiki/[opsi community Wiki].

Eine Sammlung von Weblinks zu Schaltersammlungen im Internet findet sich im link:https://forum.opsi.org/wiki/doku.php?id=userspace:software_integration_web_links[opsi Wiki: Software integration web-links].

.Ermitteln des Herstellers des Setup-Programms:
Die meisten Setupprogramme sind auf Basis von Frameworks wie 'Inno', 'NSIS', 'Installshield' oder 'Wise' gebaut. Jedes dieser Frameworks hat eigene typische Setupschalter. Um das Framework zu ermitteln kann unter anderem folgende Methode verwendet werden: Mit dem Kommandozeilen Programm `strings` werden die Strings aus der `setup.exe` extrahiert und danach mit `grep` bzw. `findstr` nach den Namen der Frameworks gesucht.

Unter Linux sieht der dazu nötige Befehl wie folgt aus (setzen Sie für <mysetup.exe> den Namen Ihrer setup.exe ein):

[source,shell]
----
strings <mysetup.exe> | grep -i -E "(inno|nsis|installshield|wise)"
----

Unter Windows muss der Befehl `strings.exe` erst installiert werden. Einen entsprechenden Download findet man hier: http://technet.microsoft.com/en-us/sysinternals/bb897439

Unter Verwendung dieses Programms, sieht der Befehl unter Windows dann wie folgt aus (setzen Sie für <mysetup.exe> den Namen Ihrer setup.exe ein):
[source,shell]
----
strings.exe <mysetup.exe> | findstr /i /r "inno installshield nsis wise"
----

Die selbe Methode verwendet der `opsi-setup-detector`.

.opsi setup detector
image::opsi-setup-detector.png[pdfwidth=90%]

Dieses grafisch-interaktive Programm lässt sich zudem in das Kontextmenü des Explorers Einbinden.

.opsi setup detector im Kontextmenü des Explorers
image::opsi-setup-detector-context-small-de.png[pdfwidth=50%]

Der 'opsi setup detector' ist Bestandteil der opsi-Repositories für Windows und kann über diese bezogen werden.

.Suche beim Hersteller des Setup-Programms:
Setup-Programme werden in der Regel von den Herstellern der diversen Softwareprodukte nicht selbst geschrieben.
In den meisten Fällen bedienen sich vielmehr die Produkthersteller selbst spezieller Softwareprodukte,
mit denen Setup-Programme relativ einfach erstellt werden können.
Die verwendbaren Kommandozeilenargumente sind daher zumeist typisch für das verwendete Produkt zur Erstellung von Setup-Programmen.

Im link:https://forum.opsi.org/wiki/doku.php?id=userspace:software_integration_web_links[opsi Wiki: Software integration web-links] finden weitere Weblinks zu Seiten, die erläutern, wie man Setupprogramme erkennt und wie Ihre typischen Schalter sind.

Auf der Homepage des Herstellers des Setupprogramms wird man zumeist mit der Suche nach Stichworten wie "silent", "silent Install" oder "unattended" fündig.

.Suche beim Hersteller des Programms:
Da die Anforderung einer automatischen Installation inzwischen vielen Herstellern bewusst ist,
finden sich häufig in der Produkt-Dokumentation oder auf der Homepage des Herstellers Anleitungen oder Hinweise hierzu.

[[opsi-getting-started-softwintegration-tutorial-winst-commands]]
===== Weitere wichtige opsi-script Funktionen

Einen Überblick über die opsi-script Funktionen gibt die Referencecard: +
http://download.uib.de/opsi_stable/docopsi-script-reference-card-en.pdf

Eine detaillierte Dokumentation ist im opsi-script Handbuch zu finden: +
http://download.uib.de/opsi_stable/docopsi-script-manual-de.pdf

Hier noch einige Hinweise auf besonders wichtige Elemente:

.Stringlisten:
Stringlisten sind sehr mächtig, insbesondere zur Auswertung von Ausgaben externer Programme. Lesen Sie dazu die opsi-script-Dokus.

.ExitWindows:
Neustart/Herunterfahren des Systems und Beendung des {opsi-script}.

*  `ExitWindows /Reboot` +
Rechner-Neustart nach Abschluss des laufenden Skriptes.

*  `ExitWindows /ImmediateReboot` +
Sofortiger Neustart.

*  `ExitWindows /ImmediateLogout` +
Sofortige Beendigung der Skript-Bearbeitung und Beendung des {opsi-script}.

.{product-properties}:
Für manche Produkte ist es erforderlich, Optionen zur Verfügung zu stellen.
Diese werden zur Laufzeit Client-spezifisch ausgewertet.
Wie solche Properties erstellt werden, ist im Kapitel
<<opsi-getting-started-softwintegration-create-opsi-package,Erstellen eines opsi-Produkt-Pakets>> beschrieben.

Der Zugriff auf die Werte der Properties geschieht über die Funktion +GetProductProperty+:

[source,winst]
----
if GetProductProperty("example-property", "no") = "yes"
	Files_copy_extra_files
endif
----

[[opsi-getting-started-softwintegration-tutorial-opsiadmin]]
===== Installation mit angemeldetem Benutzer

Vereinzelt taucht das Problem auf, dass sich Installationen nur bei angemeldetem Benutzer durchführen lassen.
Ein Hinweis auf diese Problematik ist es, wenn ein opsi-script-Skript das eine unattended Installation enthält,
beim manuellen Aufruf durch einen administrativen Benutzer funktioniert, im Rahmen der automatischen Installation über opsi jedoch scheitert.

Eine mögliche Ursache ist dann, dass dieses Setupprogramm einen angemeldetem Benutzer bzw. den Zugriff auf ein Benutzer-Profil benötigt.
Handelt es sich um eine MSI-Installation, hilft eventuell die Option +ALLUSERS=1+.

.Beispiel:
[source,winst]
----
[Actions]
DefVar $MsiLogFile$
Set $MsiLogFile$ = %opsiLogDir% + "\myproduct.log"
winbatch_install_myproduct

[winbatch_install_myproduct]
msiexec /qb-! /l* $MsiLogFile$ /i "%ScriptPath%\files\myproduct.msi" ALLUSERS=1
----

Eine weitere Möglichkeit ist, dass sich das Installationsprogramm zu früh beendet, z.B. weil ein ein Sub-Prozess gestartet wird.
In diesem Fall können die Parameter +/WaitSeconds <Anzahl Sekunden>+ oder
+/WaitForProcessEnding "program.exe" /TimeOutSeconds "<Anzahl Sekunden>"+ für den WinBatch-Aufruf helfen.

Eine andere, wenn auch aufwendigere, Möglichkeit dieses Problem zu lösen ist, einen administrativen Benutzer temporär anzulegen
und diesen zur Installation der Software zu verwenden. Dies können Sie auf Basis des Templates 'opsi-template-with-admin' durchführen.

[[opsi-getting-started-softwintegration-tutorial-msi]]
===== Arbeiten mit MSI-Paketen

Microsoft hat mit Windows 2000 ein eigenes Installationskonzept vorgestellt, das auf dem Microsoft Installer Service, kurz „MSI“ beruht. Inzwischen sind viele Setup-Programme MSI-konform.

MSI-Konformität bedeutet, dass die eigentliche Installation darin besteht, dass an den MSI ein Paket von Installations-Anweisungen übergeben wird (im Prinzip eine Datei mit einen Namen der Form „produkt.msi“) und der MSI dieses Paket dann ausführt.

In der Praxis sieht dies meist so aus, dass die zu einem Produkt gehörige „setup.exe“ eine Datei „produkt.msi“ und ein zusätzliches Steuerprogramm für die Installation enthält. Das Steuerprogramm packt „produkt.msi“ aus und fragt, ob eine Installation starten soll. Wird dies bestätigt, prüft das Steuerprogramm, ob der MSI schon eingerichtet ist und übergibt bei positivem Ergebnis der Prüfung diesem die „produkt.msi“. Ist der MSI nicht eingerichtet und wird insbesondere das Programm „msiexec.exe“ nicht gefunden, so startet das Steuerprogramm zuerst eine Installationsprogramm für den MSI.

Klickt man bei der Frage, ob die Installation starten soll, nicht auf „weiter“, sondern ruft den Explorer auf, so findet sich das ausgepackte MSI-Paket meist in einem temporären Verzeichnis.

Dieses Paket kann nun dazu verwendet werden, eine Installation „unattended“ - also „unbewacht“,  d.h. ohne dass ein Benutzereingriff erforderlich ist - auszuführen. Dazu ist bei vorhandener `msiexec.exe` aufzurufen:
[source,winst]
----
msiexec /i "%ScriptPath%\Product.msi" /qb-! ALLUSERS=1 REBOOT=ReallySuppress
----

[[opsi-getting-started-softwintegration-tutorial-customizing]]
===== Customizing nach einer silent/unattended Installation

Häufig will man nach einer erfolgreichen Silent-Installation Anpassungen an der Installation vornehmen.
Hierzu bietet der opsi-script ein mächtiges Werkzeug.
Doch bevor dies eingesetzt werden kann muss oft ermittelt werden, welche in der graphischen Oberfläche getätigten Änderungen zu
welchen Veränderungen in Dateien und der Registry führen.

Hierzu können die unter <<opsi-getting-started-softwintegration-tutorial-analyse-and-repackage>> vorgestellten Werkzeuge eingesetzt werden.
Häufig führen aber auch kleinere Werkzeuge schneller zum Erfolg.

Einige beliebte Werkzeuge sind:

* link:http://www.sysinternals.com/[sysinternals]
* link:https://sourceforge.net/projects/regshot/[regshort]

[[opsi-getting-started-softwintegration-tutorial-autoit]]
===== Einbindung mittels interaktiven Setup-Programms und automatisierten Antworten

Eine weitere schnelle Möglichkeit zur Einbindung in die automatische Softwareverteilung ist das 'Setup mit automatisierten Antworten'.
Hierzu wird eine Steuerungs-Software verwendet, die über ein Skript die Interaktion eines Anwenders mit den erscheinenden Dialog-Fenstern automatisiert. +
Wir empfehlen hierfür den Einsatz der Software link:https://autohotkey.com[AutoHotkey] oder link:http://www.autoitscript.com[AutoIt].

'AutoIt' bietet eine ganze Reihe zusätzlicher Möglichkeiten, den Setup-Prozess zu steuern.
Auch eventuelle Fehlerzustände können (so vorher bekannt) mit dem Einsatz von +[ADLIB]+-Sektionen im Skript abgefangen werden.

Ein prinzipielles Problem bleibt bestehen: Nicht vorhergesehene (und im Skript berücksichtigte) Fenster können das Skript zum Stoppen bringen.

Außerdem kann der Anwender mittels Maus und Tastatur (wenn diese nicht gesperrt sind) in den automatisierten Prozess eingreifen und den Ablauf damit verändern.
Ein Unattended- oder Silent-Setup ist daher immer die bessere Lösung.

Sehr gut kann auch eine Kombination aus beiden Ansätzen funktionieren:
Das Silent-Setup übernimmt die eigentliche Installation und ein AutoIt-Skript fängt bekannte Sonderbedingungen ab.

Wenn das Ausführen von Installationen in der opsi-client-agent Konfiguration auf einen anderen Desktop verlegt wird oder der Desktop gesperrt wird, haben verschiedene autoit Funktionen Probleme.

Daher sollten in '{opsi-script}' Skripten die folgenden Funktionen gemieden werden:

* winwait()

* winactivate()

* Send()

Das sind leider genau die 3 am meisten verwendeten.

*winwait()* +
kann ersetzt werden durch die Funktion +
`opsiwinwait($title, $text, $maxseconds, $logname)` +
welche in der folgenden Weise definiert wird:
[source,configfile]
----
Func opsiwinwait($title, $text, $maxseconds, $logname)
	Local $exists = 0
	Local $seconds = 0
	Local $mylog
	$mylog = FileOpen($logname, 1)
	While ($seconds <= $maxseconds) and ($exists = 0)
		$exists = WinExists($title , $text)
		FileWriteLine($mylog,"win: "  & $title & " ; " & $text & " exists result (1=exists): " & $exists )
		$seconds = $seconds + 1
		sleep(1000)
	WEnd
	FileClose($mylog)
EndFunc

----
Dabei ist:

* `$title` der Titel des Fensters

* `$text` ein Teil des sichtbaren Textes im Fenster

* `$maxseconds` der timeout in Sekunden

* `$logname` der Name der Logdatei


*Send()* +
kann ersetzt werden durch die Funktion +
`opsiControlClick($title, $text, $id, $maxseconds, $logname)` +
bzw. durch +
`opsiControlSetText($title, $text, $id,$sendtext, $maxseconds, $logname)` +
welche in der folgenden Weise definiert werden:
[source,configfile]
----
Func opsiControlClick($title, $text, $id, $maxseconds, $logname)
	Local $result = 0
	Local $seconds = 0
	Local $mylog
	$mylog = FileOpen($logname, 1)
	While ($seconds <= $maxseconds) and ($result = 0)
		$result = ControlClick($title , $text,$id)
		FileWriteLine($mylog,"answer for " & $title & " ; " & $text & " id: " & $id & " sended: result (1=success) : " & $result)
		$seconds = $seconds + 1
		sleep(500)
	WEnd
	FileClose($mylog)
EndFunc

Func opsiControlSetText($title, $text, $id,$sendtext, $maxseconds, $logname)
	Local $result = 0
	Local $seconds = 0
	Local $mylog
	$mylog = FileOpen($logname, 1)
	While ($seconds <= $maxseconds) and ($result = 0)
		$result = ControlSetText ($title , $text,$id, $sendtext)
		FileWriteLine($mylog,"answer for " & $title & " ; " & $text & " id: " & $id & " set: " & $sendtext & " sended: result (1=success) : " & $result)
		$seconds = $seconds + 1
		sleep(500)
	WEnd
	FileClose($mylog)
EndFunc

----
Dabei ist:

* `$title` der Titel des Fensters

* `$text` ein Teil des sichtbaren Textes im Fenster

* `$id` die numerische ControlId des Buttons oder Editierfeldes

* `$sendtext` der Text welcher eingfügt werden soll

* `$maxseconds` der timeout in Sekunden

* `$logname` der Name der Logdatei

Dabei muss mit der `Au3info.exe` die 'ControlId' ermittelt werden. Bitte die numerische 'ControlId' verwenden, andere Varianten scheinen Probleme zu machen:

Hier ein Auszug aus einem script. +
In diesem wird dann noch eine Logdatei angelegt, die mit folgenden Befehlen in die Logdatei des '{opsi-script}' integriert wird:
[source,winst]
----
includelog "c:\tmp\au3.log" "500"
----

Das Beispiel:
[source,configfile]
----
[ExecWith_autoit_confirm]
Func opsiwinwait($title, $text, $maxseconds, $logname)
	Local $exists = 0
	Local $seconds = 0
	Local $mylog
	$mylog = FileOpen($logname, 1)
	While ($seconds <= $maxseconds) and ($exists = 0)
		$exists = WinExists($title , $text)
		FileWriteLine($mylog,"win: "  & $title & " ; " & $text & " exists result (1=exists): " & $exists )
		$seconds = $seconds + 1
		sleep(1000)
	WEnd
	FileClose($mylog)
EndFunc

Func opsiControlClick($title, $text, $id, $maxseconds, $logname)
	Local $result = 0
	Local $seconds = 0
	Local $mylog
	$mylog = FileOpen($logname, 1)
	While ($seconds <= $maxseconds) and ($result = 0)
		$result = ControlClick($title , $text,$id)
		FileWriteLine($mylog,"answer for " & $title & " ; " & $text & " id: " & $id & " sended: result (1=success) : " & $result)
		$seconds = $seconds + 1
		sleep(500)
	WEnd
	FileClose($mylog)
EndFunc

Func opsiControlSetText($title, $text, $id,$sendtext, $maxseconds, $logname)
	Local $result = 0
	Local $seconds = 0
	Local $mylog
	$mylog = FileOpen($logname, 1)
	While ($seconds <= $maxseconds) and ($result = 0)
		$result = ControlSetText ($title , $text,$id, $sendtext)
		FileWriteLine($mylog,"answer for " & $title & " ; " & $text & " id: " & $id & " set: " & $sendtext & " sended: result (1=success) : " & $result)
		$seconds = $seconds + 1
		sleep(500)
	WEnd
	FileClose($mylog)
EndFunc

; exact title match
Opt("WinTitleMatchMode", 3)
$mylog = FileOpen("%opsiLogDir%\au3.log", 2)
FileWriteLine($mylog,"auto-it started - waiting for the window")
FileClose($mylog)

opsiwinwait("InstallShield Wizard" , "Wollen Sie wirklich", 200, "%opsiLogDir%\au3.log")
	opsiControlClick("InstallShield Wizard" , "Wollen Sie wirklich", 6, 5, "%opsiLogDir%\au3.log")
opsiwinwait("InstallShield Wizard" , "Deinstallation ist abgeschlossen", 400, "%opsiLogDir%\au3.log")
	opsiControlClick("InstallShield Wizard" , "Deinstallation ist abgeschlossen", 1, 5, "%opsiLogDir%\au3.log")

Sleep(500)
;and good bye
Exit
----

siehe auch: +
http://www.autoitscript.com/wiki/FAQ#Why_doesn.27t_my_script_work_on_a_locked_workstation.3F +
http://www.autoitscript.com/autoit3/docs/ +
http://www.autoitscript.com/autoit3/docs/intro/controls.htm +
http://www.autoitscript.com/autoit3/docs/functions.htm




[[opsi-getting-started-softwintegration-tutorial-analyse-and-repackage]]
===== Analyse und Neu-Paketieren

Wenn der Entwickler einer Anwendung ein Paket zur Auslieferung der Anwendung schnürt, kennt er die benötigten Komponenten.
Im Nachhinein, wenn schon ein Paket existiert, das mittels eines Setup-Programm zu installieren ist,
kann die Kenntnis, welche Komponenten installiert werden müssen, damit eine Anwendung wie gewünscht auf einem Arbeitsplatzrechner lauffähig ist,
aus der Studie der Effekte bei der Ausführung des vorhandenen Setup-Programms gewonnen werden.

Eine Reihe von Werkzeuge zum Analysieren von Setup-Programmen kommen hierbei in Frage. So z.B.:

* link:http://download.fyxm.net/download-now-InstallWatch-Pro-OS-OS-Info-83813.html[InstallWatch Pro]

* link:http://www.itninja.com/media/downloads/appdeploy-repackager.msi[appdeploy-repackager]

[[opsi-getting-started-softwintegration-tutorial-deinstall]]
===== Verfahren zur Deinstallation von Produkten

Um eine installierte Software von einem Rechner zu entfernen, kann ein Deinstallations-Skript erstellt werden.
Grundsätzlich besteht bei einer Deinstallation die Schwierigkeit, dass nicht immer klar ist,
wie das Produkt auf dem Rechner vorliegt und was alles entfernt werden muss.
Auch nach der Installation können neue Dateien oder Registry-Einträge, die die Software betreffen, hinzugekommen sein.
Weiterhin muss darauf geachtet werden nicht zu viel zu entfernen, um die Systemstabilität nicht zu gefährden.
Meist weiß nur der Hersteller genau, wie mit seinem Produkt bei der Deinstallation umzugehen ist.
Ähnlich wie bei der Installation, existieren zu diesem Zweck Deinstallations-Routinen, die dem Produkt beiliegen.
Wenn es die Möglichkeit gibt, diese ohne Benutzer-Interaktion auszuführen, kann dies schon ein entscheidender Schritt sein.
Ist eine solche Routine nicht vorhanden oder muss diese erweitert werden, so existieren viele opsi-script-Befehle, die zur Deinstallation nützlich sein können.
Im Folgenden soll nun ein Überblick über Möglichkeiten zur Deinstallation gegeben werden, die durch Beispiele verdeutlicht werden.

.Verwenden einer Deinstallations-Routine

Liefert der Hersteller des Produkts ein Programm (oder ein MSI-Paket) zur Deinstallation, so muss zunächst geprüft werden,
ob dies auch ohne Benutzer-Interaktion ausgeführt werden kann (silent-mode).
Sollte dies nicht von Hause aus möglich sein, kann der Einsatz eines AutoIt-Skriptes in Verbindung mit der Deinstallations-Routine hilfreich sein.
Der Aufruf der ausführbaren Datei kann im opsi-script-Skript in einer Winbatch-Sektion geschehen, z.B.:

[source,winst]
----
[WinBatch_start_ThunderbirdUninstall]
"%SystemRoot%\UninstallThunderbird.exe" /ma
----

Trotz dieser Unterstützung des Herstellers sollte man sich jedoch nicht auf die korrekte Beseitigung des Produkts verlassen
und auf einem Testsystem zusätzlich prüfen, ob das System nach der Deinstallation weiter stabil läuft und ob Dateien oder
Registry-Einträge zurückgeblieben sind.

Falls das Produkt als MSI-Paket bereitgestellt und mittels 'msiexec' installiert wurde,
ist es in der Regel auch eine Deinstallation mittels 'msiexec' möglich.
Dazu ruft man den `msiexec.exe` mit dem Parameter +/x+ auf und übergibt zusätzlich den MSI-Paket oder dessen 'GUID' an.
Um die Benutzer-Interaktion zu deaktivieren, kann zusätzlich der Parameter +/qb-!+ übergeben werden. +
Dies ergibt nun den folgenden Aufruf:

[source,winst]
----
msiexec.exe /x some.msi /qb-! REBOOT=ReallySuppress
----

Statt das MSI-Paket zu übergeben, gibt es auch die Möglichkeit die 'GUID' an `msiexec.exe` zu übergeben.
Diese ID ist eindeutig, Produkt-spezifisch und auf allen Systemen, auf denen das MSI-Paket installiert ist, gleich.
Sie findet sich zum Beispiel im Zweig
+HKLM\Software\Microsoft\Windows\CurrentVersion\Uninstall+ der Registry. +
Ein Beispiel einer Deinstallation mittels dieser GUID sieht folgendermaßen aus:

[source,winst]
----
msiexec.exe /x {003C5074-EB37-4A75-AC4B-F5394E08B4DD} /qb-!
----

Sollten diese Methoden nicht oder nicht vollständig funktionieren, so muss mit einem opsi-script-Skript nachgeholfen werden,
wie es im nächsten Abschnitt beschrieben ist.

.Nützliche opsi-script-Befehle zur Deinstallation

Wurde ein Produkt mit den opsi-script-Funktionen installiert oder gibt es keine Deinstallation vom Hersteller,
so muss ein eigenes opsi-script-Skript zu Deinstallation geschrieben werden.
Um den Programmierer bei dieser Arbeit zu unterstützen stellt der '{opsi-script}' einige Funktionen bereit,
die speziell bei der Deinstallation notwendig oder hilfreich sind.
Es soll an dieser Stelle nur ein kurzer Überblick gegeben werden,
eine genaue Beschreibung der Befehle und deren Parameter findet sich im {opsi-script}-Handbuch.

Der einfachste Fall ist das Löschen einer oder mehrerer Dateien vom System. Dies geschieht in einer Files-Sektion mittels des Befehls

[source,winst]
----
delete -f Dateiname
----

oder für ein Verzeichnis mit Unterverzeichnissen

[source,winst]
----
delete -sf Verzeichnisname\
----

Der Parameter +f+ steht dabei für force, um die Datei wirklich zu löschen, auch wenn diese schreibgeschützt ist,
der Parameter +s+ für subdirectories (mit Unterverzeichnissen/rekursiv).
Soll eine Datei oder ein Verzeichnis aus allen Benutzer-Profilen gelöscht werden,
so kann diese Files-Sektion mit dem Parameter +/AllNTUserProfiles+ aufgerufen werden. (siehe {opsi-script}-Handbuch)

Möchte man einen Verzeichnisbaum löschen, in dem sich auch Dateien mit dem Attribut „versteckt“ oder „systemdatei“ befinden,
muss momentan ein Umweg über den Befehl `rmdir` gegangen werden, der über eine 'DosInAnIcon'-Sektion aufgerufen werden kann.

[source,winst]
----
[DosInAnIcon_deleteDir]
rmdir /S /Q "<Verzeichnis>"
----

Muss vor dem Löschen evtl. ein laufender Prozess beendet werden, so kann dies mit dem Namen des Prozesses (zu sehen im Task-Manager)
und dem opsi-script-Befehl +KillTask+ geschehen:

[source,winst]
----
KillTask "thunderbird.exe"
----

Sollte das Produkt – oder Teile davon – als Service laufen, so muss dieser vor der Deinstallation beendet werden.
Man kann dazu den Service in der Registry auf “inaktiv“ schalten und den Rechner neu starten oder aber man benutzt den System-Befehl
`net` mit dem Parameter +stop+, um den Service sofort zu stoppen und anschließend – ohne Neustart – die zugehörigen Dateien zu löschen.

[source,winst]
----
net stop <servicename>
----

Besondere Vorsicht ist beim Löschen von .dll-Dateien geboten, die noch von anderen Produkten verwendet werden könnten.
Sie müssen individuell behandelt werden, weshalb hier leider kein allgemein gültiges Rezept gegeben werden kann.

Um einzelne Einträge aus der Registry mittels opsi-script zu löschen, kommt der Befehl +DeleteVar+ zum Einsatz,
der innerhalb einer 'Registry'-Sektion eines opsi-script-Skripts verwendet werden kann.
Er löscht Einträge aus dem momentan geöffneten Key:

[source,winst]
----
DeleteVar <VarName>
----

Möchte man einen Registry-Key samt seiner Unterschlüssel und Registry-Variablen löschen, so geschieht dies mittels des opsi-script-Befehls +DeleteKey+, z.B.:

[source,winst]
----
DeleteKey [HKLM\Software\Macromedia]
----

[[opsi-getting-started-softwintegration-tutorial-64bit]]
===== Bekannte Besonderheiten der 64 Bit-Unterstützung

Der opsi-script ist ein 32-Bit Programm.
Skripte zur Installation von 32-Bit Programmen funktionieren in der Regel auch auf 64-Bit Systemen korrekt.
Einige Konstanten, wie +%ProgramFilesDir%+, liefern Werte, die für die Verwendung mit 64-Bit-Programmen nicht richtig sind.
Neuere {opsi-script}-Versionen kennen spezielle Befehle und Konstanten für 64-Bit-Systeme.
Beachten Sie beim Arbeiten auf 64-Bit-Systemen das entsprechende Kapitel im {opsi-script}-Handbuch.

[[opsi-getting-started-softwintegration-create-opsi-package]]
=== Erstellen eines opsi-Produkt-Pakets

In opsi werden die Installationsdateien, das opsi-script-Skript zur Installation auf den Client und die Metadaten zu einem Paket zusammengefasst, welches zur Installation dieses Softwareproduktes auf einem opsi-Server dient.

Die wesentlichen Vorteile dieses Paketformates sind:

* Einfache menügeführte Erstellung mit dem Programm `opsi-newprod`.

* Ablage aller relevanten Metadaten in einer einfach zu editierenden Datei.

* Optional menügeführtes Auspacken des Paketes mit der Möglichkeit Vorgaben zu ändern.

* Informationen über die im Paket enthaltene Produktversion, Paketversion und eventueller kundenspezifischer Erweiterungen werden abgespeichert und sind am Paketnamen erkennbar. Diese werden im Installationsverzeichnis abgelegt und im opsi-Configeditor angezeigt. Auf diese Weise wird der Überblick über unterschiedliche Versionen erleichtert (Productlifecycle Management).

* Zur Erstellung und zum Auspacken von Produkten sind keine root-Rechte erforderlich. Es langen hierzu die Rechte der Gruppe `pcpatch`.

Das Paket selber besteht aus einem per Gzip komprimierten cpio Archiv. In diesem Archiv befinden sich zwei Verzeichnisse:

*CLIENT_DATA* +
Hier liegen die Dateien, die im opsi-Depot (`/var/lib/opsi/depot/<productid>`) für die Clients verfügbar sein sollen.

*OPSI* +
In der Datei `control` finden sich die Metadaten des Produkts wie der Name, die Version oder auch Produkt-Abhängigkeiten.
Weiterhin finden sich im Verzeichnis `OPSI` die Skripte `preinst` und `postinst`, die vor bzw. nach der Installation
des Produkt-Pakets auf einem opsi-Depotserver ausgeführt werden.
Hier können Sie, wenn benötigt, entsprechende Erweiterungen unterbringen.

[[opsi-getting-started-softwintegration-create-opsi-package-handling]]
==== Erstellen, Packen und Auspacken eines neuen Produktes

Zum Erstellen eines Produktes müssen Sie sich auf dem Server einloggen
(von Windows aus z.B. per `putty.exe` http://www.chiark.greenend.org.uk/~sgtatham/putty/download.html).

Die wesentlichen Befehle zum Erstellen und Installieren eines opsi-Produktes sind:

* `opsi-newprod`
* `opsi-makepackage`
* `opsi-package-manager -i <opsi-product-file>`

Zum Erstellen eines neuen Produktes benötigt man mindestens die Rechte der Gruppe +pcpatch+.

Opsi unterstützt die parallele Kompression mittels `pigz`, sofern dieses mindestens in Version 2.2.3 vorliegt. Ist diese oder eine höhere Version installiert, so wird opsi diese automatisch zur (De-)Kompression von Produkten verwenden.
Bitte beachten Sie dabei, dass sowohl `gzip` als auch `pigz` Archive erstellen, welche von der bandbreitenschonenden Synchronisierung mittels `rsync` profitieren können, allerdings sind die Dateien nicht bit-kompatibel. Das bedeutet, dass falls bereits Produkte mittels `gzip` komprimiert und an ein anderes Depot übertragen wurden, nun aber ein mittels `pigz` komprimiertes Paket übertragen wird, mehr als nur die eigentlichen Deltas übertragen werden. Das ist nur bei der ersten Umstellung des verwendeten Komprimierungsprogramms der Fall, bei alle nachfolgenden Übertragungen werden wiederum nur die Unterschiede übertragen.
Um die Verwendung von `pigz` auf einem Server explizit zu deaktivieren, setzen Sie bitte den Wert `use_pigz` in der Sektion `packages` in der Datei `/etc/opsi/opsi.conf` wie nachfolgend gezeigt auf `False`:

[source,configfile]
----
[packages]
use_pigz = False
----

Sie sollten die Produkte in dem Verzeichnis `/var/lib/opsi/workbench` erstellen,
welches der Gruppe +pcpatch+ gehört und die Rechte 2770 hat (Setgroupid Bit für Gruppe +pcpatch+ gesetzt),
sowie als Share `opsi_workbench` freigegeben ist.


[[opsi-getting-started-softwintegration-create-opsi-package-newprod]]
===== Erstellen mit opsi-newprod

Zum Erstellen wechselt man in dieses Verzeichnis und ruft `opsi-newprod` auf.
Das Programm fragt daraufhin nach dem Typ des zu erstellenden Paketes.
Dies ist üblicherweise der Typ +localboot+ für Produkte, die über den '{opsi-client-agent}'/'{opsi-script}' installiert werden.
Der Typ +netboot+ steht für Produkte, die über das opsi-Linux-Bootimage ausgeführt werden (wie z.B. die Betriebssystem-Installationen).

.Auswahl des Produkttyps: localboot
image::newprod-localboot.png[Screenshot: Auswahl des Produkttyps: localboot]

Wählen Sie nun mit Tab OK (oder bestätigen mit F12). Nun müssen Sie die wesentlichen Produktdaten eingeben. Am oberen Rand ist hierzu eine Hilfe, die erläutert was die Felder bedeuten.

.Eingabe der Produktinformationen
image::newprod-product-info.png[Screenshot: Eingabe der Produktinformationen]

Product Id:: ist ein eindeutiger Bezeichner für das Produkt in der Regel unabhängig von der Version +
Bitte nur Kleinbuchstaben verwenden, keine Umlaute, keine Leerzeichen, keine Sonderzeichen - '-' ist als Trenner erlaubt.

Product name:: ist der Klartextname des Produkts (wir empfehlen die Vermeidung von Umlauten, '-' ist erlaubt, keine Leerzeichen).

Description:: ist eine ergänzende Beschreibung zum Produkt, die z.B. im opsi-Configeditor unter `Beschreibung` angezeigt wird.

Advice:: ist eine ergänzende Beschreibung, in der Regel zum Umgang mit dem Produkt, die zu beachten ist und im opsi-Configeditor unter `Notiz` angezeigt wird.

Product version:: ist die Version der eingepackten Software (max. 32 Zeichen).

Package Version:: ist die Version des Paketes für die Produktversion. Sie dient dazu, Pakete mit gleicher Produktversion, aber z.B. korrigiertem opsi-script-Skript zu unterscheiden.

License required:: hat bei localboot Produkten keinen Einfluss. Bei netboot Produkten entscheidet diese Option, ob ein Lizenzkey aus dem Lizenzmanagement geholt wird.

Priority:: beeinflusst die Installationsreihenfolge. Mögliche Werte liegen zwischen 100 (ganz am Anfang) und -100 (ganz am Ende). Existieren auch Produktabhängigkeiten, so beeinflussen diese zusätzlich die Installationsreihenfolge.

.Eingabe der opsi-script-Skript Namen für unterschiedliche Aktionen
image::newprod-script-names.png[Screenshot: Eingabe der opsi-script-Skript Namen für unterschiedliche Aktionen]

Nach Eingabe der Produktinformationen werden Sie aufgefordert, die Skripte anzugeben, die Sie für die unterschiedlichen möglichen Aktionen bereit stellen werden.

Üblicherweise heißt das *+Setup script+* gleich `setup.ins`.

Üblicherweise heißt das *+Uninstall script+* gleich `uninstall.ins`.

Ein *+Update-Script+* dient zur geringfügigen Veränderung einer existierenden großen Installation. Wird das Produkt auf setup gestellt, so wird nach dem Abarbeiten des Setup-Skriptes automatisch auch das Update-Skript ausgeführt.

Ein *+Always-Script+* wird bei jedem aktiv werden des opsi-Clientagenten ausgeführt (z.B. bei jedem Boot).

Ein *+Once-Script+* hat den Folgestatus `not_installed`. Es handelt sich hierbei um einen sehr selten verwendeten Schalter, den Sie ignorieren sollten, wenn Sie nicht genau wissen, was Sie damit tun wollen.

Ein *+Custom-Script+* verändert weder Folgeaktion noch Folgestatus. Es handelt sich hierbei um einen sehr selten verwendeten Schalter, den Sie ignorieren sollten, wenn Sie nicht genau wissen, was Sie damit tun wollen.

Ein *+userLoginScript+* dient dazu nach dem Login des users Modifikationen am Profil des eingeloggten users vorzunehmen. Dies Funktioniert nur im Zusammenhang mit der opsi Erweiterung 'User Profile Management' und ist im entsprechenden Kapitel des opsi-Handbuchs beschrieben.


|=======================
| Typ | Folgestatus | Folgeaktion
| setup | installed | none
| uninstall | not_installed | none
| update | installed | none
| always | installed | always
| once | not_installed | none
| custom | _unverändert_ | _unverändert_
| User login | _unverändert_ | _unverändert_
|=======================

Nachdem nun das Produkt selber beschrieben ist, können Sie eine oder mehrere Produktabhängigkeiten definieren. Wollen Sie keine Produktabhängigkeit definieren so geben Sie +No+ ein.

.Eine (weitere) Produktabhängigkeit definieren: Ja / Nein
image::newprod-product-new-dependency.png["Screenshot: Eine (weitere) Produktabhängigkeit definieren: Ja / Nein", pdfwidth=90%]

Zur Erstellung einer Produktabhängigkeit geben Sie die folgenden Daten an. Beachten Sie auch die Hilfe im oberen Teil des Fensters:

.Eingabe der Daten zur Erstellung einer Produktabhängigkeit
image::newprod-product-dependency.png["Screenshot: Eingabe der Daten zur Erstellung einer Produktabhängigkeit", pdfwidth=90%]

Dependency for Action:: Für welche Aktion des Produktes, welches Sie gerade erstellen, soll die Abhängigkeit gelten (nur setup implementiert).

Required product id:: Productid (Bezeichner) des Produkts zu dem eine Abhängigkeit besteht.

Required  action:: Sie können entweder die Aktion +setup+ anfordern oder (siehe unten) den Status (+installed+).

Required installation status:: Status den das Produkt, zu dem eine Abhängigkeit besteht, haben soll (+installed+). Liegt ein anderer Status vor, so wird das Produkt auf +setup+ gestellt.

Requirement type:: Installationsreihenfolge. Wenn das Produkt, zu dem eine Abhängigkeit besteht, installiert sein muss bevor mit der Installation des aktuellen Produkts begonnen werden kann, dann ist dies +before+. Muss es nach dem aktuellen Produkt installiert werden so ist dies +after+. Ist die Reihenfolge egal so muss hier nichts eingetragen werden.

*Hinweis:*

Leider gibt es derzeit keinen generischen Mechanismus für Deinstallations-Produktabhängigkeiten. Zuverlässig ist der ProductDependency-Mechanismus nur für action: setup und die hierbei zu triggernden (before- oder after-) setup Aktionen und installed Status. Ein requiredAction: uninstall führt leider definitiv zu Fehlern.

Nachdem eine Produktabhängigkeit definiert ist, werden Sie wieder gefragt, ob Sie eine (weitere) Produktabhängigkeit definieren wollen. Wenn ja, wiederholt sich der Vorgang; wenn nein, so werden Sie gefragt, ob Sie eine Produkteigenschaft (Zusatzschalter) definieren wollen mit dem Sie die Installation des Produktes modifizieren können.

*Noch ein Hinweis:*

Die tatsächliche Installationsreihenfolge ermittelt sich aus einer Kombination von Produktabhängigkeiten und Produktpriorisierung. Details hierzu finden Sie im opsi-Handbuch im Kapitel 'Beeinflussung der Installationsreihenfolge durch Prioritäten und Produktabhängigkeiten'

.Eine (weitere) Produkteigenschaft definieren
image::newprod-new-property.png["Screenshot: Eine (weitere) Produkteigenschaft definieren", pdfwidth=90%]

Antworten Sie ja, so müssen Sie die Produkteigenschaft beschreiben:

Die Produkteigenschaft wird clientspezifisch gespeichert und besteht aus einem Namen (key) der verschiedene Werte (Values) zugeordnet bekommen kann und die dann vom opsi-script-Skript abgefragt werden können.

Zunächst müssen Sie angeben, ob es sich um ein Textwert (unicode) oder um einen logische Wert also wahr/falsch (boolean) handelt. Wenn Sie unsicher sind, wählen Sie +unicode+.

.Datentyp der Produkteigenschaft wählen
image::newprod-property-type.png["Screenshot: Datentyp der Produkteigenschaft wählen", pdfwidth=90%]

Weiterhin wird eine Beschreibung benötigt, die im opsi-configed als Hilfe angezeigt wird. Weiterhin müssen Sie, durch Kommas getrennt, alle Werte angeben, die der Key annehmen darf. Wird hier nichts angegeben, so kann später im opsi-Configeditor ein beliebiger Wert eingegeben werden. Über `Editable` (true/false) können Sie entscheiden, ob neben der vorgegebenen Liste auch andere Werte eingegeben werden dürfen.

NOTE: Enthält ein Wert einen Backslash `\`, so muss dieser doppelt angegeben werden. +
Eine Pfadangabe kann beispielsweise wie folgt aussehen: `C:\\temp`

.Beschreibung der Produkteigenschaft
image::newprod-property-desc.png["Screenshot: Beschreibung der Produkteigenschaft", pdfwidth=90%]

Im Folgefenster müssen Sie festlegen, was der Defaultwert dieser Produkteigenschaft ist.

.Festlegung des Defaultwerts der Produkteigenschaft
image::newprod-property-default.png["Screenshot: Festlegung des Defaultwerts der Produkteigenschaft", pdfwidth=90%]

Wenn Sie als Typ 'boolean' wählen, so reduziert sich die Beschreibung auf 'Property name' und 'Property description'.

.Beschreibung eines boolschen Properties
image::newprod-property-boolean.png["Screenshot: Beschreibung eines boolschen Properties", pdfwidth=90%]

Nachdem eine Produkteigenschaft definiert ist, werden Sie wieder gefragt, ob Sie eine (weitere) Produkteigenschaft definieren wollen. Wenn ja, wiederholt sich der Vorgang; wenn nein, so werden Sie als nächstes nach Name und Mail-Adresse gefragt. Diese werden im Changelog des Paketes verwendet und müssen angegeben werden.

.Eingabe der Maintainer Daten
image::newprod-maintainer.png["Screenshot: Eingabe der Maintainer Daten", pdfwidth=90%]

Danach ist das Grundgerüst des Produktes fertig gestellt.

Mithilfe des `ls` Befehls finden Sie die oben beschriebene Verzeichnis Struktur. Wechseln Sie in den OPSI-Ordner und setzen Sie erneut den `ls` Befehl ab. Hier befindet sich unter anderem die 'control'-Datei, welche die eben eingegebenen Daten enthält und Ihnen auch die Möglichkeit bietet, diese im Editor zu kontrollieren oder zu modifizieren.

.Beispiel einer 'control' Datei

[source,configfile]
----
[Package]
version: 1
depends:

[Product]
type: localboot
id: mytest
name: My Test
description: A test product
advice:
version: 3.14
priority: 10
licenseRequired: False
productClasses:
setupScript: setup.ins
uninstallScript:
updateScript:
alwaysScript:
onceScript:
customScript:
userLoginScript:

[ProductDependency]
action: setup
requiredProduct: javavm
requiredStatus: installed

[ProductProperty]
type: unicode
name: mytextprop
multivalue: False
editable: True
description: hint
values: ["off", "on"]
default: ["off"]

[ProductProperty]
type: bool
name: myboolprop
description: yes or no
default: False

[Changelog]
mytest (3.14-1) testing; urgency=low

  * Initial package

 -- jane doe <j.doe@opsi.org>  Mi, 14 Jul 2010 12:47:53 +0000
----

Als nächstes müssen Sie das, für das Produkt erstellte, opsi-script-Skript und die entsprechenden Dateien nach 'CLIENT_DATA' kopieren.

Wenn Sie z.B. das erstellte Skript unter 'c:\test' liegen haben, so mounten Sie '\\<opsiserver\opsi_workbench' z.B. nach 'w:' und kopieren den Inhalt von 'c:\test' in das Verzeichnis 'CLIENT_DATA'.

[[opsi-getting-started-softwintegration-create-opsi-package-makeproductfile]]
===== Packen mit opsi-makepackage

Danach können Sie das Produkt packen. Gehen Sie dazu in das Stammverzeichnis des Produkts und rufen Sie 'opsi-makepackage' auf. Es wird nun das Produkt gepackt.

opsi-makepackage kennt einige Optionen, die sein Verhalten modifizieren:

[source,shell]
----
$ opsi-makepackage --help
usage: opsi-makepackage [--help] [--version] [--quiet] [--verbose]
                        [--log-level {0,1,2,3,4,5,6,7,8,9}] [--no-compression]
                        [--archive-format {cpio,tar}] [--follow-symlinks]
                        [--custom-name custom name | --custom-only custom name]
                        [--temp-directory directory] [--md5 | --no-md5]
                        [--zsync | --no-zsync] [--no-pigz] [--keep-versions]
                        [--package-version packageversion]
                        [--product-version productversion]
                        [source directory]

Provides an opsi package from a package source directory. If no source
directory is supplied, the current directory will be used.

positional arguments:
  source directory

optional arguments:
  --help                Show help.
  --version, -V         show program's version number and exit
  --quiet, -q           do not show progress
  --verbose, -v         verbose
  --log-level {0,1,2,3,4,5,6,7,8,9}, -l {0,1,2,3,4,5,6,7,8,9}
                        Set log-level (0..9)
  --no-compression, -n  Do not compress
  --archive-format {cpio,tar}, -F {cpio,tar}
                        Archive format to use. Default: cpio
  --follow-symlinks, -h
                        follow symlinks
  --custom-name custom name, -i custom name
                        custom name (add custom files)
  --custom-only custom name, -c custom name
                        custom name (custom only)
  --temp-directory directory, -t directory
                        temp dir
  --md5, -m             Create file with md5 checksum.
  --no-md5              Do not create file with md5 checksum.
  --zsync, -z           Create zsync file.
  --no-zsync            Do not create zsync file.
  --no-pigz             Disable the usage of pigz

Versions:
  Set versions for package. Combinations are possible.

  --keep-versions, -k   Keep versions and overwrite package
  --package-version packageversion
                        Set new package version
  --product-version productversion
                        Set new product version for package
----

Es ist zu empfehlen die Pakete gleich mit einer zugehörigen md5-Prüfsummendatei zu erstellen.
Diese Datei wird unter anderem vom `opsi-package-updater` genutzt, um nach der Paketübertragung die Paketintegrität sicher zu stellen.
Eine solche Datei wird automatisch erstellt, aber für besondere Einsatzszenarien kann die Erstellung unterdrückt werden.

Bei der Übertragung von Paketen auf opsi-Depotserver kann auf 'zsync' zurück gegriffen werden, um nur Unterschiede zwischen verschiedenen Paketen zu übertragen.
Damit dieses Verfahren verwendet werde kann, wird eine Datei besondere `.zsync`-Datei benötigt.
Eine solche Datei wird automatisch erstellt, aber für besondere Einsatzszenarien kann die Erstellung unterdrückt werden.

Wenn es beim Erstellen großer Pakete zu Platzproblemen im temporären Verzeichnis `/tmp` kommt, ist es möglich mittels `--temp-directory` ein abweichendes temporäres Verzeichnis anzugeben.

Wenn schon ein Paket dieser Version existiert, so zeigt `opsi-makepackage` eine Rückfrage:

[source,shell]
----
Package file '/var/lib/opsi/workbench/mytest/mytest_3.14-1.opsi' already exists.
Press <O> to overwrite, <C> to abort or <N> to specify a new version:
----

Mit `o` wählen Sie überschreiben, mit `c` brechen Sie den Vorgang ab und mit `n` können Sie wählen, dass Sie nach einer neuen Product- bzw. Package-Version gefragt werden.

Das gepackte Paket können Sie mit `opsi-package-manager --install <paketdatei>` auf dem Server installieren.

Weitere Informationen zum opsi-packet-manager siehe opsi-Handbuch.

////
